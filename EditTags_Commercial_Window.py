# Form implementation generated from reading ui file 'EditTags_Commercial_Window.ui'
#
# Created by: PyQt6 UI code generator 6.4.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6 import QtSql
from PyQt6.QtWidgets import QApplication
import re
import configparser
from Database_Connection import createConnection
from config import config
import psycopg2
from PyQt6.QtCore import Qt, QSortFilterProxyModel
from PyQt6.QtSql import QSqlDatabase, QSqlQuery
from PyQt6.QtGui import QKeySequence, QClipboard, QTextDocument, QTextCursor


def imagen_to_base64(imagen):
    buffer = QtCore.QBuffer()
    buffer.open(QtCore.QIODevice.OpenModeFlag.WriteOnly)
    imagen.save(buffer, "PNG")
    base64_data = buffer.data().toBase64().data().decode()
    return base64_data


class CheckboxWidget(QtWidgets.QWidget):
    def __init__(self, text):
        super().__init__()
        layout = QtWidgets.QHBoxLayout(self)
        self.checkbox = QtWidgets.QCheckBox(text)
        layout.addWidget(self.checkbox)


class AlignDelegate(QtWidgets.QStyledItemDelegate):
    def initStyleOption(self, option, index):
        super(AlignDelegate, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter


class EditableComboBoxDelegate(QtWidgets.QStyledItemDelegate):
    def __init__(self, parent=None, options=None):
        super().__init__(parent)
        self.options = options

    def createEditor(self, parent, option, index):
        editor = QtWidgets.QComboBox(parent)
        editor.setEditable(True)
        return editor

    def setEditorData(self, editor, index):
        text = index.data(Qt.ItemDataRole.DisplayRole)
        editor.addItems(self.options)
        editor.setEditText(text)

    def setModelData(self, editor, model, index):
        model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)


class CustomProxyModel(QtCore.QSortFilterProxyModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._filters = dict()
        self.header_names = {}

    @property
    def filters(self):
        return self._filters

    def setFilter(self, expresion, column, action_name=None):
        if expresion or expresion == '':
            if column in self.filters:
                if action_name or action_name == '':
                    self.filters[column].remove(expresion)
                else:
                    self.filters[column].append(expresion)
            else:
                self.filters[column] = [expresion]
        elif column in self.filters:
            if action_name or action_name == '':
                self.filters[column].remove(expresion)
                if not self.filters[column]:
                    del self.filters[column]
            else:
                del self.filters[column]
        self.invalidateFilter()


    def filterAcceptsRow(self, source_row, source_parent):
        for column, expresions in self.filters.items():
            text = self.sourceModel().index(source_row, column, source_parent).data()

            if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
                text = text.toString("yyyy-MM-dd")

            for expresion in expresions:
                if expresion == '':  # Si la expresión es vacía, coincidir con celdas vacías
                    if text == '':
                        break

                elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', expresion):
                    expresion = QtCore.QDate.fromString(expresion, "dd/MM/yyyy")
                    expresion = expresion.toString("yyyy-MM-dd")
                    regex = QtCore.QRegularExpression(f".*{re.escape(expresion)}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        break

                else:
                    regex = QtCore.QRegularExpression(f".*{re.escape(expresion)}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        break
            else:
                return False
        return True


class EditableTableModel(QtSql.QSqlTableModel):
    updateFailed = QtCore.pyqtSignal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        # self.originalData = {}
        # self.modifiedCells = []

    def setAllColumnHeaders(self, headers):
        for column, header in enumerate(headers):
            self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIndividualColumnHeader(self, column, header):
        self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIconColumnHeader(self, column, icon):
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return super().headerData(section, orientation, role)
        return super().headerData(section, orientation, role)

    def flags(self, index):
        flags = super().flags(index)
        if index.column() == 0:
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        else:
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable 

    # def update_record(self, record, index):
    #     query = QSqlQuery(self.database())
    #     primary_key = self.primaryKey()
    #     id_column = primary_key.fieldName(0)

    #     column_index = index.column() # Obtaining modified column index from modified cell index
    #     column_name = self.record().fieldName(column_index) # Obtaining modified column name
    #     new_value = index.data(Qt.ItemDataRole.EditRole) #Obtaining new value
    #     old_value = self.originalData.get(column_index, "") # Obtaining old value

    #     # Verify if values are NULL
    #     if new_value is None:
    #         new_value = ""
    #     if old_value is None:
    #         old_value = ""

    #     query.prepare(f"UPDATE {self.tableName()} SET {column_name} = :newValue WHERE {id_column} = :id")
    #     query.bindValue(":newValue", new_value)
    #     query.bindValue(":id", record.value(id_column))

    #     query.exec()
    #     query_text = query.executedQuery()
    #     # print("SQL Query:", query_text)

    #     if query.lastError().isValid():
    #         dlg = QtWidgets.QMessageBox()
    #         new_icon = QtGui.QIcon()
    #         new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
    #         dlg.setWindowIcon(new_icon)
    #         dlg.setWindowTitle("Editar Tags")
    #         dlg.setText("Ha habido un error al actualizar los datos. No serán guardados")
    #         dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
    #         dlg.exec()

    #         print("Error en la consulta:", query.lastError().nativeErrorCode())
    #         print("Mensaje de error:", query.lastError().text())
    #         return None
    #     else:
    #         return query_text


class EditableComboBoxDelegate(QtWidgets.QStyledItemDelegate):
    def __init__(self, parent=None, options=None):
        super().__init__(parent)
        self.options = options

    def createEditor(self, parent, option, index):
        editor = QtWidgets.QComboBox(parent)
        editor.setEditable(True)
        return editor

    def setEditorData(self, editor, index):
        text = index.data(Qt.ItemDataRole.DisplayRole)
        editor.addItems(self.options)
        editor.setEditText(text)

    def setModelData(self, editor, model, index):
        model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)


class Ui_EditTags_Window(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.model = EditableTableModel()
        self.proxy = CustomProxyModel()
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []
        self.setupUi(self)
        self.model.dataChanged.connect(self.saveChanges)


    def setupUi(self, EditTags_Window):
        EditTags_Window.setObjectName("EditTags_Window")
        EditTags_Window.resize(790, 595)
        EditTags_Window.setMinimumSize(QtCore.QSize(790, 595))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        EditTags_Window.setWindowIcon(icon)
        EditTags_Window.setStyleSheet(
".QFrame {\n"
"    border: 2px solid black;\n"
"}")
        self.centralwidget = QtWidgets.QWidget(parent=EditTags_Window)
        self.centralwidget.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_2.setVerticalSpacing(10)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.hcab=QtWidgets.QHBoxLayout()
        self.hcab.setObjectName("hcab")
        # self.toolSave = QtWidgets.QToolButton(self.frame)
        # self.toolSave.setObjectName("Save_Button")
        # self.hcab.addWidget(self.toolSave)
        # icon = QtGui.QIcon()
        # icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/Save.png"),QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        # self.toolSave.setIcon(icon)
        # self.hcabspacer1=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        # self.hcab.addItem(self.hcabspacer1)
        self.toolDeleteFilter = QtWidgets.QToolButton(self.frame)
        self.toolDeleteFilter.setObjectName("DeleteFilter_Button")
        self.toolDeleteFilter.setToolTip("Borrar filtros")
        self.toolDeleteFilter.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolDeleteFilter)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/Filter_Delete.png"),QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolDeleteFilter.setIcon(icon)
        self.hcabspacer1=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer1)
        self.toolShow = QtWidgets.QToolButton(self.frame)
        self.toolShow.setObjectName("Show_Button")
        self.toolShow.setToolTip("Mostrar columnas")
        self.hcab.addWidget(self.toolShow)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/Eye.png"),QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolShow.setIcon(icon)
        self.toolShow.setIconSize(QtCore.QSize(25, 25))

        self.hcabspacer2=QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer2)
        self.gridLayout_2.addLayout(self.hcab, 0, 0, 1, 1)
        self.hLayout1 = QtWidgets.QHBoxLayout()
        self.hLayout1.setObjectName("hLayout1")
        self.label_NumOrder = QtWidgets.QLabel(parent=self.frame)
        self.label_NumOrder.setMinimumSize(QtCore.QSize(80, 25))
        self.label_NumOrder.setMaximumSize(QtCore.QSize(80, 25))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        self.label_NumOrder.setFont(font)
        self.label_NumOrder.setObjectName("label_NumOrder")
        self.hLayout1.addWidget(self.label_NumOrder)
        self.Numorder_EditTags = QtWidgets.QLineEdit(parent=self.frame)
        self.Numorder_EditTags.setMinimumSize(QtCore.QSize(250, 25))
        self.Numorder_EditTags.setMaximumSize(QtCore.QSize(250, 25))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.Numorder_EditTags.setFont(font)
        self.Numorder_EditTags.setObjectName("Numorder_EditTags")
        self.hLayout1.addWidget(self.Numorder_EditTags)
        self.Button_Clean = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Clean.setMinimumSize(QtCore.QSize(150, 35))
        self.Button_Clean.setMaximumSize(QtCore.QSize(150, 35))
        self.Button_Clean.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.Button_Clean.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 8px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:focus {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255)\n"
"}\n"
"\n"
"QPushButton:focus:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        self.Button_Clean.setObjectName("Button_Clean")
        self.hLayout1.addWidget(self.Button_Clean)
        self.gridLayout_2.addLayout(self.hLayout1, 1, 0, 1, 1)
        self.hLayout2 = QtWidgets.QHBoxLayout()
        self.hLayout2.setObjectName("hLayout2")
        self.label_NumOffer = QtWidgets.QLabel(parent=self.frame)
        self.label_NumOffer.setMinimumSize(QtCore.QSize(80, 25))
        self.label_NumOffer.setMaximumSize(QtCore.QSize(80, 25))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        self.label_NumOffer.setFont(font)
        self.label_NumOffer.setObjectName("label_NumOffer")
        self.hLayout2.addWidget(self.label_NumOffer)
        self.Numoffer_EditTags = QtWidgets.QLineEdit(parent=self.frame)
        self.Numoffer_EditTags.setMinimumSize(QtCore.QSize(250, 25))
        self.Numoffer_EditTags.setMaximumSize(QtCore.QSize(250, 25))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.Numoffer_EditTags.setFont(font)
        self.Numoffer_EditTags.setObjectName("Numoffer_EditTags")
        self.hLayout2.addWidget(self.Numoffer_EditTags)
        self.Button_Query = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Query.setMinimumSize(QtCore.QSize(150, 35))
        self.Button_Query.setMaximumSize(QtCore.QSize(150, 35))
        self.Button_Query.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.Button_Query.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 8px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:focus {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255)\n"
"}\n"
"\n"
"QPushButton:focus:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        self.Button_Query.setObjectName("Button_Query")
        self.hLayout2.addWidget(self.Button_Query)
        self.gridLayout_2.addLayout(self.hLayout2, 2, 0, 1, 1)
        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 3, 0, 1, 1)
        self.tableEditTags=QtWidgets.QTableView(parent=self.frame)
        self.model = EditableTableModel()
        # self.model.select()
        # # self.model.setEditStrategy(QtSql.QSqlTableModel.EditStrategy.OnManualSubmit)
        # self.proxy.setSourceModel(self.model)
        # self.tableEditTags.setModel(self.proxy)
        self.tableEditTags.setObjectName("tableEditTags")
        self.gridLayout_2.addWidget(self.tableEditTags, 4, 0, 1, 1)
        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 0, 0, 1, 1)
        self.gridLayout.addWidget(self.frame, 0, 0, 1, 1)
        EditTags_Window.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=EditTags_Window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 790, 22))
        self.menubar.setObjectName("menubar")
        EditTags_Window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=EditTags_Window)
        self.statusbar.setObjectName("statusbar")
        EditTags_Window.setStatusBar(self.statusbar)

        self.retranslateUi(EditTags_Window)
        QtCore.QMetaObject.connectSlotsByName(EditTags_Window)
        self.Button_Clean.clicked.connect(self.clean_boxes)
        self.Button_Query.clicked.connect(self.query_tags)
        # self.toolSave.clicked.connect(self.submit_all)
        self.toolDeleteFilter.clicked.connect(self.delete_allFilters)
        self.toolShow.clicked.connect(self.show_columns)
        self.Numoffer_EditTags.returnPressed.connect(self.query_tags)
        self.Numorder_EditTags.returnPressed.connect(self.query_tags)
        self.model.dataChanged.connect(self.saveChanges)

        commands_comboboxes_flow = [
            "SELECT item_type FROM validation_data.flow_item_type",
            "SELECT line_size FROM validation_data.flow_line_size",
            "SELECT rating FROM validation_data.flow_rating",
            "SELECT facing FROM validation_data.flow_facing",
            "SELECT schedule FROM validation_data.flow_schedule",
            "SELECT flange_material FROM validation_data.flow_flange_material",
            "SELECT flange_type FROM validation_data.flow_flange_type",
            "SELECT element_material FROM validation_data.flow_element_material",
            "SELECT tapping FROM validation_data.flow_tapping",
            "SELECT element_material FROM validation_data.flow_element_material",
            "SELECT plate_type FROM validation_data.flow_plate_type",
            "SELECT plate_thk FROM validation_data.flow_plate_thk",
            "SELECT plate_std FROM validation_data.flow_plate_std",
            "SELECT gasket_material FROM validation_data.flow_gasket_material",
            "SELECT bolts_nuts_material FROM validation_data.flow_bolts_nuts_material",
            "SELECT nace FROM validation_data.flow_nace"
            ]
        
        commands_comboboxes_temp = [
            "SELECT item_type FROM validation_data.temp_item_type",
            "SELECT tw_type FROM validation_data.temp_tw_type",
            "SELECT flange_size FROM validation_data.temp_flange_size",
            "SELECT flange_rating FROM validation_data.temp_flange_rating",
            "SELECT flange_facing FROM validation_data.temp_flange_facing",
            "SELECT tw_material FROM validation_data.temp_tw_material",
            "SELECT root_diam FROM validation_data.temp_root_diam",
            "SELECT tip_diam FROM validation_data.temp_tip_diam",
            "SELECT sensor_element FROM validation_data.temp_sensor_element",
            "SELECT sheath_stem_material FROM validation_data.temp_sheath_stem_material",
            "SELECT sheath_stem_diam FROM validation_data.temp_sheath_stem_diam",
            "SELECT insulation FROM validation_data.temp_insulation",
            "SELECT temp_inf FROM validation_data.temp_temp_inf",
            "SELECT temp_sup FROM validation_data.temp_temp_sup",
            "SELECT nipple_ext_material FROM validation_data.temp_nipple_ext_material",
            "SELECT nipple_ext_length FROM validation_data.temp_nipple_ext_length",
            "SELECT head_case_material FROM validation_data.temp_head_case_material",
            "SELECT head_conn_case_diam FROM validation_data.temp_head_conn_case_diam",
            "SELECT tttb FROM validation_data.temp_tttb",
            "SELECT flange_material_lapjoint FROM validation_data.temp_flange_material_lapjoint",
            "SELECT gasket_material FROM validation_data.temp_gasket_material",
            "SELECT puntal FROM validation_data.temp_puntal",
            "SELECT tube_t FROM validation_data.temp_tube_t",
            "SELECT nace FROM validation_data.temp_nace",
            "SELECT plug FROM validation_data.temp_plug"
            ]

        self.all_results_flow = []
        self.all_results_temp = []

        conn = None
        try:
        # read the connection parameters
            params = config()
        # connect to the PostgreSQL server
            conn = psycopg2.connect(**params)
            cur = conn.cursor()
        # execution of commands
            for query in commands_comboboxes_flow:
                cur.execute(query)
                results_flow=cur.fetchall()
                self.all_results_flow.append(results_flow)
            for query in commands_comboboxes_temp:
                cur.execute(query)
                results_temp=cur.fetchall()
                self.all_results_temp.append(results_temp)
            # for query in commands_comboboxes_level:
            #     cur.execute(query)
            #     results_level=cur.fetchall()
            #     self.all_results_level.append(results_level)
        # close communication with the PostgreSQL database server
            cur.close()
        # commit the changes
            conn.commit()
        except (Exception, psycopg2.DatabaseError) as error:
            print(error)
        finally:
            if conn is not None:
                conn.close()

    def retranslateUi(self, EditTags_Window):
        _translate = QtCore.QCoreApplication.translate
        EditTags_Window.setWindowTitle(_translate("EditTags_Window", "Editar Tags"))
        self.tableEditTags.setSortingEnabled(True)
        self.label_NumOffer.setText(_translate("EditTags_Window", "Nº Oferta:"))
        self.Button_Query.setText(_translate("EditTags_Window", "Buscar"))
        self.label_NumOrder.setText(_translate("EditTags_Window", "Nº Pedido:"))
        self.Button_Clean.setText(_translate("EditTags_Window", "Vaciar Cuadros"))

# Function to clear the text boxes
    def clean_boxes(self):
        self.Numorder_EditTags.setText("")
        self.Numoffer_EditTags.setText("")

# Function when delete all filters button is clicked
    def delete_allFilters(self):
        columns_number=self.model.columnCount()
        for index in range(columns_number):
            if index in self.proxy.filters:
                self.proxy.setFilter("", index)
            self.model.setIconColumnHeader(index, '')

        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}

        # Getting the unique values for each column of the model
        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            if column not in self.checkbox_states:
                self.checkbox_states[column] = {}
                self.checkbox_states[column]['Seleccionar todo'] = True
                for row in range(self.model.rowCount()):
                    value = self.model.record(row).value(column)
                    if value not in list_valuesUnique:
                        if isinstance(value, QtCore.QDate):
                            value=value.toString("dd/MM/yyyy")
                        list_valuesUnique.append(str(value))
                        self.checkbox_states[column][value] = True
                self.dict_valuesuniques[column] = list_valuesUnique

# Function to upload changes in database when field change
    def saveChanges(self):
        self.model.submitAll()

        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            for row in range(self.model.rowCount()):
                value = self.model.record(row).value(column)
                if value not in list_valuesUnique:
                    if isinstance(value, QtCore.QDate):
                        value=value.toString("dd/MM/yyyy")
                    list_valuesUnique.append(str(value))
                    if value not in self.checkbox_states[column]:
                        self.checkbox_states[column][value] = True
            self.dict_valuesuniques[column] = list_valuesUnique

# Function to upload changes when save button is pressed
    # def submit_all(self):
    #     columns_number=self.model.columnCount()
    #     if self.model.database().isOpen():
    #         self.model.database().transaction()
    #         success = True

    #         for index in range(columns_number):
    #             self.proxy.setFilter("", index)
    #             self.model.setIconColumnHeader(index, '')

    #         for row in range(self.model.rowCount()):
    #             for column in range(self.model.columnCount()):
    #                 index = self.model.index(row, column)
    #                 current_value = index.data(Qt.ItemDataRole.DisplayRole)
    #                 original_value = self.model.getOriginalValue(index)
    #                 if current_value != original_value:
    #                     record = self.model.record(row)
    #                     query = self.model.update_record(record, index)
    #                     if not query:
    #                         success = False
    #                         break

    #         if success:
    #             self.model.database().commit()
    #             dlg = QtWidgets.QMessageBox()
    #             new_icon = QtGui.QIcon()
    #             new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
    #             dlg.setWindowIcon(new_icon)
    #             dlg.setWindowTitle("Editar Tags")
    #             dlg.setText("Datos guardados con éxito")
    #             dlg.setIcon(QtWidgets.QMessageBox.Icon.Information)
    #             dlg.exec()
    #         else:
    #             self.model.database().rollback()
    #             dlg = QtWidgets.QMessageBox()
    #             new_icon = QtGui.QIcon()
    #             new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
    #             dlg.setWindowIcon(new_icon)
    #             dlg.setWindowTitle("Editar Tags")
    #             dlg.setText("Ha habido un problema al guardar los datos")
    #             dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
    #             dlg.exec()

    #     else:
    #         dlg = QtWidgets.QMessageBox()
    #         new_icon = QtGui.QIcon()
    #         new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
    #         dlg.setWindowIcon(new_icon)
    #         dlg.setWindowTitle("Editar Tags")
    #         dlg.setText("No ha sido posible conectar con la base de datos. Contacte con su administrador")
    #         dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
    #         dlg.exec()

# Function to load table and setting in the window
    def query_tags(self):
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []
    
        self.model.dataChanged.disconnect(self.saveChanges)
        numorder = self.Numorder_EditTags.text()
        numoffer = self.Numoffer_EditTags.text()
        variable = ''

        if numoffer=="" and numorder=="":
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("Rellena alguno de los campos")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg.exec()
            del dlg, new_icon
            self.model.dataChanged.connect(self.saveChanges)

        elif numoffer=="":
            if not re.match(r'^(P|PA)-\d{2}/\d{3}.*$', numorder):
                dlg = QtWidgets.QMessageBox()
                new_icon = QtGui.QIcon()
                new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                dlg.setWindowIcon(new_icon)
                dlg.setWindowTitle("ERP EIPSA")
                dlg.setText("El número de pedido debe tener formato P-XX/YYY o PA-XX/YYY")
                dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                dlg.exec()
                del dlg, new_icon
                self.model.dataChanged.connect(self.saveChanges)

            else:
                query = ('''
                        SELECT num_order, product_type."variable"
                        FROM orders
                        INNER JOIN offers ON (offers."num_offer" = orders."num_offer")
                        INNER JOIN product_type ON (product_type."material" = offers."material")
                        WHERE
                        UPPER (orders."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')
                conn = None
                try:
                # read the connection parameters
                    params = config()
                # connect to the PostgreSQL server
                    conn = psycopg2.connect(**params)
                    cur = conn.cursor()
                # execution of commands
                    cur.execute(query,(numorder,))
                    results_variable=cur.fetchone()
                    variable = results_variable[1] if results_variable != None else ''
                # close communication with the PostgreSQL database server
                    cur.close()
                # commit the changes
                    conn.commit()
                except (Exception, psycopg2.DatabaseError) as error:
                    print(error)
                finally:
                    if conn is not None:
                        conn.close()

                if results_variable == None:
                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("ERP EIPSA")
                    dlg.setText("EL número de pedido no existe")
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                    dlg.exec()
                    del dlg, new_icon
                    self.model.dataChanged.connect(self.saveChanges)

                else:
                    if variable == 'Caudal':
                        self.model.setTable("tags_data.tags_flow_prueba")
                    elif variable == 'Temperatura':
                        self.model.setTable("tags_data.tags_temp_prueba")
                    # elif variable == 'Level':
                    #     self.model.setTable("tags_data.tags_level_prueba")
                    self.model.setFilter(f"num_order <>'' AND UPPER(num_order) LIKE '%{numorder.upper()}%'")

        elif numorder=="":
            if not re.match(r'^O-\d{2}/\d{3}.*$', numoffer):
                dlg = QtWidgets.QMessageBox()
                new_icon = QtGui.QIcon()
                new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                dlg.setWindowIcon(new_icon)
                dlg.setWindowTitle("ERP EIPSA")
                dlg.setText("El número de oferta debe tener formato O-XX/YYY")
                dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                dlg.exec()
                del dlg, new_icon
                self.model.dataChanged.connect(self.saveChanges)

            else:
                query = ('''
                        SELECT num_offer, product_type."variable"
                        FROM offers
                        INNER JOIN product_type ON (product_type."material" = offers."material")
                        WHERE
                        UPPER (offers."num_offer") LIKE UPPER('%%'||%s||'%%')
                        ''')
                conn = None
                try:
                # read the connection parameters
                    params = config()
                # connect to the PostgreSQL server
                    conn = psycopg2.connect(**params)
                    cur = conn.cursor()
                # execution of commands
                    cur.execute(query,(numoffer,))
                    results_variable=cur.fetchone()
                    variable = results_variable[1] if results_variable != None else ''
                # close communication with the PostgreSQL database server
                    cur.close()
                # commit the changes
                    conn.commit()
                except (Exception, psycopg2.DatabaseError) as error:
                    print(error)
                finally:
                    if conn is not None:
                        conn.close()

                if results_variable == None:
                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("ERP EIPSA")
                    dlg.setText("El número de oferta no existe")
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                    dlg.exec()
                    del dlg, new_icon
                    self.model.dataChanged.connect(self.saveChanges)

                else:
                    if variable == 'Caudal':
                        self.model.setTable("tags_data.tags_flow_prueba")
                    elif variable == 'Temperatura':
                        self.model.setTable("tags_data.tags_temp_prueba")
                    # elif variable == 'Level':
                    #     self.model.setTable("tags_data.tags_level_prueba")
                    self.model.setFilter(f"num_offer <>'' AND UPPER(num_offer) LIKE '%{numoffer.upper()}%'")

        else:
            if not re.match(r'^(P|PA)-\d{2}/\d{3}.*$', numorder) or not re.match(r'^O-\d{2}/\d{3}.*$', numoffer):
                dlg = QtWidgets.QMessageBox()
                new_icon = QtGui.QIcon()
                new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                dlg.setWindowIcon(new_icon)
                dlg.setWindowTitle("ERP EIPSA")
                dlg.setText("El número de pedido debe tener formato P-XX/YYY o PA-XX/YYY \n"
                            "El número de oferta debe tener formato O-XX/YYY")
                dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                dlg.exec()
                del dlg, new_icon
                self.model.dataChanged.connect(self.saveChanges)

            else:
                query = ('''
                        SELECT num_offer, product_type."variable"
                        FROM offers
                        INNER JOIN product_type ON (product_type."material" = offers."material")
                        WHERE
                        UPPER (offers."num_offer") LIKE UPPER('%%'||%s||'%%')
                        ''')
                conn = None
                try:
                # read the connection parameters
                    params = config()
                # connect to the PostgreSQL server
                    conn = psycopg2.connect(**params)
                    cur = conn.cursor()
                # execution of commands
                    cur.execute(query,(numorder,))
                    results_variable=cur.fetchone()
                    variable = results_variable[1] if results_variable != None else ''
                # close communication with the PostgreSQL database server
                    cur.close()
                # commit the changes
                    conn.commit()
                except (Exception, psycopg2.DatabaseError) as error:
                    print(error)
                finally:
                    if conn is not None:
                        conn.close()

                if results_variable == None:
                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("ERP EIPSA")
                    dlg.setText("EL número de oferta no existe")
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                    dlg.exec()
                    del dlg, new_icon
                    self.model.dataChanged.connect(self.saveChanges)

                else:
                    if variable == 'Caudal':
                        self.model.setTable("tags_data.tags_flow_prueba")
                    elif variable == 'Temperatura':
                        self.model.setTable("tags_data.tags_temp_prueba")
                    # elif variable == 'Level':
                    #     self.model.setTable("tags_data.tags_level_prueba")
                    self.model.setFilter(f"num_order <>'' AND UPPER(num_order) LIKE '%{numorder.upper()}%' AND num_offer <>'' AND UPPER(num_offer) LIKE '%{numoffer.upper()}%'")

        if variable != '':
            self.model.select()
            # self.model.setEditStrategy(QtSql.QSqlTableModel.EditStrategy.OnManualSubmit)

            self.proxy.setSourceModel(self.model)
            self.tableEditTags.setModel(self.proxy)

            columns_number=self.model.columnCount()

            if variable == 'Caudal':
                self.tableEditTags.hideColumn(32)
                self.tableEditTags.hideColumn(33)
                for i in range(36,columns_number):
                    self.tableEditTags.hideColumn(i)
            elif variable == 'Temperatura':
                for i in range(39,45):
                    self.tableEditTags.hideColumn(i)
                for i in range(47,columns_number):
                    self.tableEditTags.hideColumn(i)

            self.tableEditTags.verticalHeader().hide()
            self.tableEditTags.setItemDelegate(AlignDelegate(self.tableEditTags))
            self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditTags.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")
            self.tableEditTags.setObjectName("tableEditTags")
            self.gridLayout_2.addWidget(self.tableEditTags, 3, 0, 1, 1)
            self.tableEditTags.setSortingEnabled(False)
            self.tableEditTags.horizontalHeader().sectionClicked.connect(self.on_view_horizontalHeader_sectionClicked)

        # Change all column names
            headers_flow = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido", "PO", "Posición", "Subposición",
                        "Tipo", "Tamaño Línea", "Rating", "Facing", "Schedule", "Material Brida", "Tipo Brida",
                        "Material Tubo", "Tamaño Tomas (Nº)", "Material Elemento", "Tipo Placa", "Espesor Placa",
                        "Estándar Placa", "Material Junta", "Material Tornillería", "NACE", "Nº Saltos",
                        "Pipe Spec.", "Peso Aprox. (kg)", "Long. Aprox. (mm)", "Precio (€)", "Notas Oferta",
                        "Cambio Comercial", "Fecha Contractual", "","", "Cambios Técnicos", "Notas Técnicas"]
            
            headers_temp = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido", "PO", "Posición", "Subposición",
                        "Tipo", "Tipo TW", "Tamaño Brida", "Rating Brida", "Facing Brida", "Standard TW",
                        "Material TW", "Long. STD (mm)", "Long. Ins. (mm)", "Ø Raíz (mm)", "Ø Punta (mm)",
                        "Sensor", "Material Sheath/Stem", "Ø Sheath/Stem (mm)", "Insulation", "Temp Inf (ºC)",
                        "Temp Sup ºC", "Material Nipple Ext.", "Long. Nipple Ext. (mm)", "Material Head/Case", "Con. Elec./Diam. Case",
                        "TT/Terminal Insulation", "Material Brida LapJoint", "Material Junta", "Puntal", "Tubo",
                        "NACE", "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual",
                        "", "", "", "", "", "", "Cambios Técnicos", "Notas Técnicas"]
            
            headers_level = []

            if variable == 'Caudal':
                self.model.setAllColumnHeaders(headers_flow)
            elif variable == 'Temperatura':
                self.model.setAllColumnHeaders(headers_temp)
            elif variable == 'Nivel':
                self.model.setAllColumnHeaders(headers_level)

        # Getting the unique values for each column of the model
            for column in range(self.model.columnCount()):
                list_valuesUnique = []
                if column not in self.checkbox_states:
                    self.checkbox_states[column] = {}
                    self.checkbox_states[column]['Seleccionar todo'] = True
                    for row in range(self.model.rowCount()):
                        value = self.model.record(row).value(column)
                        if value not in list_valuesUnique:
                            if isinstance(value, QtCore.QDate):
                                value=value.toString("dd/MM/yyyy")
                            list_valuesUnique.append(str(value))
                            self.checkbox_states[column][value] = True
                    self.dict_valuesuniques[column] = list_valuesUnique

            # Setting cells with comboboxes
            if variable == 'Caudal':
                for i in range(16):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_flow[i]]))
                    self.tableEditTags.setItemDelegateForColumn(i+8, self.combo_itemtype)
            elif variable == 'Temperatura':
                for i in range(5):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_temp[i]]))
                    self.tableEditTags.setItemDelegateForColumn(i+8, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_temp[5]]))
                self.tableEditTags.setItemDelegateForColumn(14, self.combo_itemtype)
                for i in range(6,25):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_temp[i]]))
                    self.tableEditTags.setItemDelegateForColumn(i+11, self.combo_itemtype)
            # elif variable == 'Nivel':
            #     for i in range(16):
            #         self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_level[i]]))
            #         self.tableEditTags.setItemDelegateForColumn(i+8, self.combo_itemtype)

            self.model.dataChanged.connect(self.saveChanges)

# Function when clicking on header
    def on_view_horizontalHeader_sectionClicked(self, logicalIndex):
        self.logicalIndex = logicalIndex
        self.menuValues = QtWidgets.QMenu(self.tableEditTags)
        self.signalMapper = QtCore.QSignalMapper(self.tableEditTags)

        valuesUnique_view = []
        for row in range(self.tableEditTags.model().rowCount()):
            index = self.tableEditTags.model().index(row, self.logicalIndex)
            value = index.data(Qt.ItemDataRole.DisplayRole)
            if value not in valuesUnique_view:
                if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
                valuesUnique_view.append(value)
                if self.logicalIndex in self.proxy.filters and str(value) in self.proxy.filters[self.logicalIndex]:
                    pass
                else:
                    if self.logicalIndex not in self.proxy.filters:
                        self.proxy.filters[self.logicalIndex] = []
                    self.proxy.filters[self.logicalIndex].append(str(value))

        actionHideColumn = QtGui.QAction("Ocultar Columna", self.tableEditTags)
        actionHideColumn.triggered.connect(self.hide_column)
        self.menuValues.addAction(actionHideColumn)
        self.menuValues.addSeparator()

        actionSortAscending = QtGui.QAction("Ordenar Ascendente", self.tableEditTags)
        actionSortAscending.triggered.connect(self.on_actionSortAscending_triggered)
        self.menuValues.addAction(actionSortAscending)
        actionSortDescending = QtGui.QAction("Ordenar Descendente", self.tableEditTags)
        actionSortDescending.triggered.connect(self.on_actionSortDescending_triggered)
        self.menuValues.addAction(actionSortDescending)
        self.menuValues.addSeparator()

        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro", self.tableEditTags)
        actionDeleteFilterColumn.triggered.connect(self.on_actionDeleteFilterColumn_triggered)
        self.menuValues.addAction(actionDeleteFilterColumn)
        self.menuValues.addSeparator()

        actionTextFilter = QtGui.QAction("Buscar...", self.tableEditTags)
        actionTextFilter.triggered.connect(self.on_actionTextFilter_triggered)
        self.menuValues.addAction(actionTextFilter)
        self.menuValues.addSeparator()

        self.moreMenu = self.menuValues.addMenu("Más")

        if len(self.dict_ordersort) != 0 and self.logicalIndex in self.dict_ordersort:
            list_uniquevalues = sorted(list(set(self.dict_valuesuniques[self.logicalIndex])))
        else:
            list_uniquevalues = sorted(list(set(valuesUnique_view)))

        for actionNumber, actionName in enumerate(['Seleccionar todo'] + list_uniquevalues):
            checkbox_widget = CheckboxWidget(str(actionName))
            action = QtWidgets.QWidgetAction(self.moreMenu)
            action.setDefaultWidget(checkbox_widget)
            self.moreMenu.addAction(action)

            if not self.checkbox_states[self.logicalIndex][actionName] == True:
                checkbox_widget.checkbox.setChecked(False)
            else:
                checkbox_widget.checkbox.setChecked(True)

            checkbox_widget.checkbox.toggled.connect(lambda checked, name=actionName: self.on_checkbox_toggled(checked, name))

        self.moreMenu.setStyleSheet("QMenu { menu-scrollable: True; }")

        self.menuValues.setStyleSheet("QMenu { color: black; }"
                                        "QMenu::item:selected { background-color: #33bdef; }"
                                        "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")
        # self.signalMapper.mappedInt.connect(self.on_signalMapper_mapped)

        headerPos = self.tableEditTags.mapToGlobal(self.tableEditTags.horizontalHeader().pos())        

        posY = headerPos.y() + self.tableEditTags.horizontalHeader().height()
        scrollX = self.tableEditTags.horizontalScrollBar().value()
        xInView = self.tableEditTags.horizontalHeader().sectionViewportPosition(logicalIndex)
        posX = headerPos.x() + xInView - scrollX
        # posX = headerPos.x() + self.tableEditTags.horizontalHeader().sectionPosition(self.logicalIndex)

        self.menuValues.exec(QtCore.QPoint(posX, posY))

# Function when checkbox of header menu is clicked
    def on_checkbox_toggled(self, checked, action_name):
        filterColumn = self.logicalIndex
        imagen_path = "//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/Filter_Active.png"
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if len(self.dict_ordersort) == 0:
            self.dict_ordersort[self.logicalIndex] = 1

        if action_name == "Seleccionar todo":
            if checked:
                for action in self.moreMenu.actions()[0:]:
                    checkbox_widget = action.defaultWidget().checkbox
                    checkbox_widget.setChecked(checked)
                    self.checkbox_states[self.logicalIndex][checkbox_widget.text()] = True

            else:
                for action in self.moreMenu.actions()[0:]:
                    checkbox_widget = action.defaultWidget().checkbox
                    checkbox_widget.setChecked(checked)
                    self.checkbox_states[self.logicalIndex][checkbox_widget.text()] = False

        else:
            if checked:
                self.proxy.setFilter(str(action_name), filterColumn)
                self.checkbox_states[self.logicalIndex][action_name] = True
                self.model.setIconColumnHeader(filterColumn, icono)

                # select_all_checkbox = self.moreMenu.actions()[0].defaultWidget().checkbox
                # if all(action.defaultWidget().checkbox.isChecked() for action in self.moreMenu.actions()[1:]):
                #     select_all_checkbox.setChecked(True)

            else:
                if action_name in self.checkbox_states[self.logicalIndex]:
                    self.checkbox_states[self.logicalIndex][action_name] = False
                    self.proxy.setFilter(str(action_name), filterColumn, str(action_name))
                    self.model.setIconColumnHeader(filterColumn, icono)

                    # select_all_checkbox = self.moreMenu.actions()[0].defaultWidget().checkbox
                    # select_all_checkbox.setCheckState(QtCore.Qt.CheckState.PartiallyChecked)

            if all(action.defaultWidget().checkbox.isChecked() for action in self.moreMenu.actions()[1:]):
                self.model.setIconColumnHeader(filterColumn, '')

# Function when delete filter action in header is clicked
    def on_actionDeleteFilterColumn_triggered(self):
        filterColumn = self.logicalIndex
        if filterColumn in self.proxy.filters:
                del self.proxy.filters[filterColumn]
        self.model.setIconColumnHeader(filterColumn, '')
        self.proxy.invalidateFilter()

        self.tableEditTags.setModel(None)  # Eliminar el modelo actual de la vista
        self.tableEditTags.setModel(self.proxy)

        self.checkbox_states[self.logicalIndex].clear()
        self.checkbox_states[self.logicalIndex]['Seleccionar todo'] = True
        for row in range(self.tableEditTags.model().rowCount()):
            value = self.model.record(row).value(filterColumn)
            if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
            self.checkbox_states[self.logicalIndex][value] = True

# Function when sort ascending action in header is clicked
    def on_actionSortAscending_triggered(self):
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.AscendingOrder
        self.tableEditTags.sortByColumn(sortColumn, sortOrder)

# Function when sort descending action in header is clicked
    def on_actionSortDescending_triggered(self):
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.DescendingOrder
        self.tableEditTags.sortByColumn(sortColumn, sortOrder)

# Function when text filter action in header is used
    def on_actionTextFilter_triggered(self):
        filterColumn = self.logicalIndex
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap("//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle('Buscar')
        clickedButton=dlg.exec()

        if clickedButton == 1:
            stringAction = dlg.textValue()
            if re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', stringAction):
                stringAction=QtCore.QDate.fromString(stringAction,"dd/MM/yyyy")
                stringAction=stringAction.toString("yyyy-MM-dd")

            filterString = QtCore.QRegularExpression(stringAction, QtCore.QRegularExpression.PatternOption(0))

            self.proxy.setFilter(filterString, filterColumn)

# Function when delete filter action in header is clicked
    def on_signalMapper_mapped(self, i):
        stringAction = self.signalMapper.mapping(i).text()
        filterColumn = self.logicalIndex
        self.proxy.setFilter(stringAction, filterColumn)

        imagen_path = "//nas01/DATOS/Comunes/EIPSA-ERP/Recursos/Iconos/Filter_Active.png"
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
        self.model.setIconColumnHeader(filterColumn, icono)

# Function to hide column when action clicked
    def hide_column(self):
        filterColumn = self.logicalIndex  # Supongo que esta variable contiene el índice de la columna a ocultar
        self.tableEditTags.setColumnHidden(filterColumn, True)
        self.hiddencolumns.append(filterColumn)
        # header_view = self.tableEditTags.horizontalHeader()
        # model = header_view.model()
        # header_item = model.headerData(filterColumn, Qt.Orientation.Horizontal)
        # if header_item is not None:
        #     header_text = header_item
        #     print(f"Texto del encabezado de la columna {filterColumn}: {header_text}")
        # else:
        #     print(f"No se encontró encabezado para la columna {filterColumn}")

# Function to show all hidden columns
    def show_columns(self):
        for column in self.hiddencolumns:
            self.tableEditTags.setColumnHidden(column, False)
            self.hiddencolumns.remove(column)


    def keyPressEvent(self, event):
        if event.matches(QKeySequence.StandardKey.Copy):
            selected_indexes = self.tableEditTags.selectionModel().selectedIndexes()
            if selected_indexes:
                clipboard = QApplication.clipboard()
                text = self.get_selected_text(selected_indexes)
                clipboard.setText(text)
        # if event.matches(QKeySequence.StandardKey.Copy):
        #     selected = self.table_view.selectionModel().selectedIndexes()
        #     if selected:
        #         clipboard = QApplication.clipboard()
        #         clipboard.setText(self.model.data(selected[0], Qt.ItemDataRole.DisplayRole))

        elif event.matches(QKeySequence.StandardKey.Paste):
            selected_indexes = self.tableEditTags.selectionModel().selectedIndexes()
            if selected_indexes:
                clipboard = QApplication.clipboard()
                text = clipboard.text()
                for index in selected_indexes:
                    current_row = index.row()
                    current_column = index.column()
                    first_column_value = self.proxy.data(self.proxy.index(current_row, 0))
                    target_row = None
                    for row in range(self.model.rowCount()):
                        if self.model.data(self.model.index(row, 0)) == first_column_value:
                            target_row = row
                            break
                    if target_row is not None:
                        target_index = self.model.index(target_row, current_column)
                        self.model.setData(target_index, text, Qt.ItemDataRole.EditRole)  # Pegar el valor en todas las celdas seleccionadas
                self.model.submitAll()

        super().keyPressEvent(event)

    def get_selected_text(self, indexes):
        if len(indexes) == 1:  # Si solo hay una celda seleccionada
            index = indexes[0]
            cell_data = index.data(Qt.ItemDataRole.DisplayRole)
            return cell_data
        else:
            rows = set()
            cols = set()
            for index in indexes:
                rows.add(index.row())
                cols.add(index.column())

            text_doc = QTextDocument()
            cursor = QTextCursor(text_doc)

            for row in sorted(rows):
                for col in sorted(cols):
                    index = self.model.index(row, col)  # Obtener el índice correspondiente
                    cell_data = index.data(Qt.ItemDataRole.DisplayRole)
                    cursor.insertText(str(cell_data))
                    cursor.insertText('\t')  # Tab separador de columnas
                cursor.insertText('\n')  # Salto de línea al final de la fila

            return text_doc.toPlainText()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    config_obj = configparser.ConfigParser()
    config_obj.read(r"C:\Program Files\ERP EIPSA\database.ini")
    dbparam = config_obj["postgresql"]
    # set your parameters for the database connection URI using the keys from the configfile.ini
    user_database = dbparam["user"]
    password_database = dbparam["password"]

    if not createConnection(user_database, password_database):
        sys.exit()

    EditTags_Window = Ui_EditTags_Window()
    EditTags_Window.show()
    sys.exit(app.exec())
