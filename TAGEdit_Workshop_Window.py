# Form implementation generated from reading ui file 'EditTags_Commercial_Window.ui'
#
# Created by: PyQt6 UI code generator 6.4.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6 import QtSql
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import Qt, QDate
from PyQt6.QtGui import QKeySequence, QTextDocument, QTextCursor
from utils.Database_Manager import Create_DBconnection
from config import config
import psycopg2
import re
import configparser
import locale
from datetime import *
import os
import pandas as pd
from tkinter.filedialog import asksaveasfilename
from openpyxl import load_workbook


basedir = r"\\nas01\DATOS\Comunes\EIPSA-ERP"


def imagen_to_base64(imagen):
    """
    Converts an image in PNG format to a base64 encoded string.

    Args:
        imagen: An instance of QImage or QPixmap to be converted.
    Return: 
        A base64 encoded string representing the image in PNG format.
    """
    buffer = QtCore.QBuffer()
    buffer.open(QtCore.QIODevice.OpenModeFlag.WriteOnly)
    imagen.save(buffer, ".png")
    base64_data = buffer.data().toBase64().data().decode()
    return base64_data

class FreezeTableWidget(QtWidgets.QTableView):
    """
    Custom QTableView that creates a frozen pane for the first two columns to remain fixed while scrolling horizontally. 
    It synchronizes the vertical scrolling between the main table and the frozen columns.

    Args:
        model (QAbstractTableModel): The data model that the table displays.
        variable (str): The type of variable that determines which images to open on double-click (e.g., 'Caudal', 'Temperatura').
    """
    def __init__(self, model, variable):
        """
        Initializes the FreezeTableWidget by setting up the model, frozen table, and event connections for section resizing 
        and scrolling. It also establishes the double-click connection for opening images.
        """
        super(FreezeTableWidget, self).__init__()
        self.setModel(model)
        self.frozenTableView = QtWidgets.QTableView(self)
        self.init()
        self.horizontalHeader().sectionResized.connect(self.updateSectionWidth)
        self.verticalHeader().sectionResized.connect(self.updateSectionHeight)
        self.frozenTableView.verticalScrollBar().valueChanged.connect(
            self.verticalScrollBar().setValue)
        self.verticalScrollBar().valueChanged.connect(
            self.frozenTableView.verticalScrollBar().setValue)
        self.variable_table = variable
        self.doubleClicked.connect(self.open_pics)

    def init(self):
        """
        Initializes the appearance and behavior of the frozen table, hiding columns after the second one, and synchronizes
        selection and scrolling with the main table.
        """
        self.frozenTableView.setModel(self.model())
        self.frozenTableView.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.frozenTableView.verticalHeader().hide()
        self.frozenTableView.horizontalHeader().setSectionResizeMode(
                QtWidgets.QHeaderView.ResizeMode.Fixed)
        self.viewport().stackUnder(self.frozenTableView)
        self.frozenTableView.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")

        self.frozenTableView.setSelectionModel(self.selectionModel())
        for col in range(self.model().columnCount()):
            if col < 2:
                self.frozenTableView.setColumnWidth(col, self.columnWidth(col))
            else:
                self.frozenTableView.setColumnHidden(col, True)
        self.frozenTableView.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.frozenTableView.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.frozenTableView.show()
        self.updateFrozenTableGeometry()
        self.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollMode.ScrollPerPixel)
        self.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollMode.ScrollPerPixel)
        self.frozenTableView.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollMode.ScrollPerPixel)

    def updateSectionWidth(self, logicalIndex, oldSize, newSize):
        """
        Updates the width of the corresponding column in the frozen table when resized in the main table.

        Args:
            logicalIndex (int): The index of the resized column.
            oldSize (int): The previous size of the column.
            newSize (int): The new size of the column.
        """
        if logicalIndex < 2:
            self.frozenTableView.setColumnWidth(logicalIndex, newSize)
            self.updateFrozenTableGeometry()

    def updateSectionHeight(self, logicalIndex, oldSize, newSize):
        """
        Updates the row height in the frozen table when resized in the main table.

        Args:
            logicalIndex (int): The index of the resized row.
            oldSize (int): The previous height of the row.
            newSize (int): The new height of the row.
        """
        self.frozenTableView.setRowHeight(logicalIndex, newSize)

    def resizeEvent(self, event):
        """
        Handles the resizing of the main table, updating the geometry of the frozen table.

        Args:
            event (QResizeEvent): The resize event.
        """
        super(FreezeTableWidget, self).resizeEvent(event)
        self.updateFrozenTableGeometry()

    def moveCursor(self, cursorAction, modifiers):
        """
        Moves the cursor within the table, adjusting the horizontal scroll when the cursor moves past the frozen columns.

        Args:
            cursorAction (QKeyEvent): The key event associated with cursor movement.
            modifiers (Qt.KeyboardModifiers): Keyboard modifiers active during cursor movement.

        Returns:
            QModelIndex: The new position of the cursor after movement.
        """
        current = super(FreezeTableWidget, self).moveCursor(cursorAction, modifiers)
        if (cursorAction == Qt.Key.Key_Left and
                self.current.column() > 1 and
                self.visualRect(current).topLeft().x() <
                self.frozenTableView.columnWidth(0) + self.frozenTableView.columnWidth(1)):
            newValue = (self.horizontalScrollBar().value() +
                        self.visualRect(current).topLeft().x() -
                        self.frozenTableView.columnWidth(0) - self.frozenTableView.columnWidth(1))
            self.horizontalScrollBar().setValue(newValue)
        return current

    def scrollTo(self, index, hint):
        """
        Scrolls the table to a specific index, only if the column is beyond the frozen columns.

        Args:
            index (QModelIndex): The index to scroll to.
            hint (QAbstractItemView.ScrollHint): Scroll hint for how to display the item.
        """
        if index.column() > 1:
            super(FreezeTableWidget, self).scrollTo(index, hint)

    def updateFrozenTableGeometry(self):
        """
        Updates the geometry of the frozen table based on the dimensions of the main table.
        """
        self.frozenTableView.setGeometry(
            self.verticalHeader().width() + self.frameWidth(),
            self.frameWidth(), self.columnWidth(0) + self.columnWidth(1),
            self.viewport().height() + self.horizontalHeader().height())

    def open_pics(self, index):
        """
        Opens the image file associated with the current cell based on the variable and column.

        Args:
            index (QModelIndex): The index of the selected cell.

        Raises:
            Exception: If there is an error while trying to open the file, it displays an error message.
        """
        if ((self.variable_table == 'Caudal' and index.column() in [156, 166])
        or (self.variable_table == 'Temperatura' and index.column() in [166, 176])
        or (self.variable_table == 'Nivel' and index.column() in [169, 179])
        or (self.variable_table == 'Otros' and index.column() in [56, 66])):
            value = index.data()


            if value != '':
                try:
                    file_path = os.path.normpath(value)
                    os.startfile(file_path)

                except (Exception, psycopg2.DatabaseError) as error:
                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("ERP EIPSA")
                    dlg.setText("Ha ocurrido el siguiente error:\n"
                                + str(error))
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                    dlg.exec()
                    del dlg, new_icon

class FreezeTableWidget2(QtWidgets.QTableView):
    """
    Custom QTableView that creates a frozen pane for the first two columns to remain fixed while scrolling horizontally. 
    It synchronizes the vertical scrolling between the main table and the frozen columns.

    Args:
        model (QAbstractTableModel): The data model that the table displays.
        variable (str): The type of variable that determines which images to open on double-click (e.g., 'Caudal', 'Temperatura').
    """
    def __init__(self, model, variable):
        """
        Initializes the FreezeTableWidget2 by setting up the model, frozen table, and event connections for section resizing 
        and scrolling. It also establishes the double-click connection for opening images.
        """
        super(FreezeTableWidget2, self).__init__()
        self.setModel(model)
        self.frozenTableView = QtWidgets.QTableView(self)
        self.init()
        self.horizontalHeader().sectionResized.connect(self.updateSectionWidth)
        self.verticalHeader().sectionResized.connect(self.updateSectionHeight)
        self.frozenTableView.verticalScrollBar().valueChanged.connect(
            self.verticalScrollBar().setValue)
        self.verticalScrollBar().valueChanged.connect(
            self.frozenTableView.verticalScrollBar().setValue)
        self.variable_table = variable
        self.doubleClicked.connect(self.open_pics)

    def init(self):
        """
        Initializes the appearance and behavior of the frozen table, hiding columns after the second one, and synchronizes
        selection and scrolling with the main table.
        """
        self.frozenTableView.setModel(self.model())
        self.frozenTableView.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.frozenTableView.verticalHeader().hide()
        self.frozenTableView.horizontalHeader().setSectionResizeMode(
                QtWidgets.QHeaderView.ResizeMode.Fixed)
        self.viewport().stackUnder(self.frozenTableView)
        self.frozenTableView.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")

        self.frozenTableView.setSelectionModel(self.selectionModel())
        for col in range(self.model().columnCount()):
            if col < 2:
                self.frozenTableView.setColumnWidth(col, self.columnWidth(col))
            else:
                self.frozenTableView.setColumnHidden(col, True)
        self.frozenTableView.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.frozenTableView.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.frozenTableView.show()
        self.updateFrozenTableGeometry()
        self.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollMode.ScrollPerPixel)
        self.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollMode.ScrollPerPixel)
        self.frozenTableView.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollMode.ScrollPerPixel)

    def updateSectionWidth(self, logicalIndex, oldSize, newSize):
        """
        Updates the width of the corresponding column in the frozen table when resized in the main table.

        Args:
            logicalIndex (int): The index of the resized column.
            oldSize (int): The previous size of the column.
            newSize (int): The new size of the column.
        """
        if logicalIndex < 2:
            self.frozenTableView.setColumnWidth(logicalIndex, newSize)
            self.updateFrozenTableGeometry()

    def updateSectionHeight(self, logicalIndex, oldSize, newSize):
        """
        Updates the row height in the frozen table when resized in the main table.

        Args:
            logicalIndex (int): The index of the resized row.
            oldSize (int): The previous height of the row.
            newSize (int): The new height of the row.
        """
        self.frozenTableView.setRowHeight(logicalIndex, newSize)

    def resizeEvent(self, event):
        """
        Handles the resizing of the main table, updating the geometry of the frozen table.

        Args:
            event (QResizeEvent): The resize event.
        """
        super(FreezeTableWidget2, self).resizeEvent(event)
        self.updateFrozenTableGeometry()

    def moveCursor(self, cursorAction, modifiers):
        """
        Moves the cursor within the table, adjusting the horizontal scroll when the cursor moves past the frozen columns.

        Args:
            cursorAction (QKeyEvent): The key event associated with cursor movement.
            modifiers (Qt.KeyboardModifiers): Keyboard modifiers active during cursor movement.

        Returns:
            QModelIndex: The new position of the cursor after movement.
        """
        current = super(FreezeTableWidget2, self).moveCursor(cursorAction, modifiers)
        if (cursorAction == Qt.Key.Key_Left and
                self.current.column() > 1 and
                self.visualRect(current).topLeft().x() <
                self.frozenTableView.columnWidth(0) + self.frozenTableView.columnWidth(1)):
            newValue = (self.horizontalScrollBar().value() +
                        self.visualRect(current).topLeft().x() -
                        self.frozenTableView.columnWidth(0) - self.frozenTableView.columnWidth(1))
            self.horizontalScrollBar().setValue(newValue)
        return current

    def scrollTo(self, index, hint):
        """
        Scrolls the table to a specific index, only if the column is beyond the frozen columns.

        Args:
            index (QModelIndex): The index to scroll to.
            hint (QAbstractItemView.ScrollHint): Scroll hint for how to display the item.
        """
        if index.column() > 1:
            super(FreezeTableWidget2, self).scrollTo(index, hint)

    def updateFrozenTableGeometry(self):
        """
        Updates the geometry of the frozen table based on the dimensions of the main table.
        """
        self.frozenTableView.setGeometry(
            self.verticalHeader().width() + self.frameWidth(),
            self.frameWidth(), self.columnWidth(0) + self.columnWidth(1),
            self.viewport().height() + self.horizontalHeader().height())

    def open_pics(self, index):
        """
        Opens the image file associated with the current cell based on the variable and column.

        Args:
            index (QModelIndex): The index of the selected cell.

        Raises:
            Exception: If there is an error while trying to open the file, it displays an error message.
        """
        if ((self.variable_table == 'Caudal' and index.column() == 156)
        or (self.variable_table == 'Temperatura' and index.column() == 166)
        or (self.variable_table == 'Nivel' and index.column() == 169)
        or (self.variable_table == 'Otros' and index.column() == 56)):
            value = index.data()

            if value != '':
                try:
                    file_path = os.path.normpath(value)
                    os.startfile(file_path)

                except (Exception, psycopg2.DatabaseError) as error:
                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("ERP EIPSA")
                    dlg.setText("Ha ocurrido el siguiente error:\n"
                                + str(error))
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                    dlg.exec()
                    del dlg, new_icon

class AlignDelegate(QtWidgets.QStyledItemDelegate):
    """
    A custom item delegate for aligning cell content in a QTableView or QTableWidget to the center.

    Inherits from:
        QtWidgets.QStyledItemDelegate: Provides custom rendering and editing for table items.

    """
    def initStyleOption(self, option, index):
        """
        Initializes the style option for the item, setting its display alignment to center.

        Args:
            option (QtWidgets.QStyleOptionViewItem): The style option to initialize.
            index (QtCore.QModelIndex): The model index of the item.
        """
        super(AlignDelegate, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

class CustomProxyModel(QtCore.QSortFilterProxyModel):
    """
    A custom proxy model that filters table rows based on expressions set for specific columns.

    Attributes:
        _filters (dict): A dictionary to store filter expressions for columns.
        header_names (dict): A dictionary to store header names for the table.

    Properties:
        filters: Getter for the current filter dictionary.

    """
    def __init__(self, parent=None):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        super().__init__(parent)
        self._filters = dict()
        self.header_names = {}

    @property
    def filters(self):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        return self._filters

    def setFilter(self, expresion, column, action_name=None, exact_match=False):
        """
        Apply a filter expression to a specific column, or remove it if necessary.

        Args:
            expresion (str): The filter expression.
            column (int): The index of the column to apply the filter to.
            action_name (str, optional): Name of the action, can be empty. Defaults to None.
            exact_match (bool, optional): If True, use exact matching for the filter. Defaults to False.
        """
        if expresion or expresion == '':
            if column in self.filters:
                if action_name or action_name == '':
                    self.filters[column].remove(expresion)
                else:
                    self.filters[column].append((expresion, exact_match))
            else:
                self.filters[column] = [(expresion, exact_match)]
        elif column in self.filters:
            if action_name or action_name == '':
                self.filters[column].remove(expresion)
                if not self.filters[column]:
                    del self.filters[column]
            else:
                del self.filters[column]
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        """
        Check if a row passes the filter criteria based on the column filters.

        Args:
            source_row (int): The row number in the source model.
            source_parent (QModelIndex): The parent index of the row.

        Returns:
            bool: True if the row meets the filter criteria, False otherwise.
        """
        for column, expresions in self.filters.items():
            text = self.sourceModel().index(source_row, column, source_parent).data()

            if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
                text = text.toString("yyyy-MM-dd")

            match_found = False 

            for expresion, exact_match in expresions:
                if expresion == '':  # If expression is empty, match empty cells
                    if text == '':
                        break

                if exact_match:
                    if text in expresion:  # Verificar si `text` está en la lista `expresion`
                        match_found = True
                        break
                
                elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', expresion[0]):
                    expresion = QtCore.QDate.fromString(expresion[0], "dd/MM/yyyy")
                    expresion = expresion.toString("yyyy-MM-dd")
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

                else:
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion[0]))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

            if not match_found:
                return False
        return True

class EditableTableModel(QtSql.QSqlTableModel):
    """
    A custom SQL table model that supports editable columns, headers, and special flagging behavior based on user permissions.

    Signals:
        updateFailed (str): Signal emitted when an update to the model fails.
    """
    updateFailed = QtCore.pyqtSignal(str)

    def __init__(self, parent=None, column_range=None, table_check=None):
        """
        Initialize the model with user permissions and optional database and column range.

        Args:
            username (str): The username for permission-based actions.
            parent (QObject, optional): Parent object for the model. Defaults to None.
            column_range (list, optional): A list specifying the range of columns. Defaults to None.
            table_check (str, optional): A text scpecifying the table selected. Defaults to None
        """
        super().__init__(parent)
        self.column_range = column_range
        self.table_check = table_check

    def setAllColumnHeaders(self, headers):
        """
        Set headers for all columns in the model.

        Args:
            headers (list): A list of header names.
        """
        for column, header in enumerate(headers):
            self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIndividualColumnHeader(self, column, header):
        """
        Set the header for a specific column.

        Args:
            column (int): The column index.
            header (str): The header name.
        """
        self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIconColumnHeader(self, column, icon):
        """
        Set an icon in the header for a specific column.

        Args:
            column (int): The column index.
            icon (QIcon): The icon to display in the header.
        """
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        """
        Retrieve the header data for a specific section of the model.

        Args:
            section (int): The section index (column or row).
            orientation (Qt.Orientation): The orientation (horizontal or vertical).
            role (Qt.ItemDataRole, optional): The role for the header data. Defaults to DisplayRole.

        Returns:
            QVariant: The header data for the specified section.
        """
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return super().headerData(section, orientation, role)
        return super().headerData(section, orientation, role)

    def flags(self, index):
        """
        Get the item flags for a given index, controlling editability and selection based on user permissions.

        Args:
            index (QModelIndex): The index of the item.

        Returns:
            Qt.ItemFlags: The flags for the specified item.
        """
        flags = super().flags(index)

        flags &= ~Qt.ItemFlag.ItemIsEditable
        return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled

    def getColumnHeaders(self, visible_columns):
        """
        Retrieve the headers for the specified visible columns.

        Args:
            visible_columns (list): List of column indices that are visible.

        Returns:
            list: A list of column headers for the visible columns.
        """
        column_headers = [self.headerData(col, Qt.Orientation.Horizontal) for col in visible_columns]
        return column_headers

class CustomProxyModel2(QtCore.QSortFilterProxyModel):
    """
    A custom proxy model that filters table rows based on expressions set for specific columns.

    Attributes:
        _filters (dict): A dictionary to store filter expressions for columns.
        header_names (dict): A dictionary to store header names for the table.

    Properties:
        filters: Getter for the current filter dictionary.

    """
    def __init__(self, parent=None):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        super().__init__(parent)
        self._filters = dict()
        self.header_names = {}

    @property
    def filters(self):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        return self._filters

    def setFilter(self, expresion, column, action_name=None, exact_match=False):
        """
        Apply a filter expression to a specific column, or remove it if necessary.

        Args:
            expresion (str): The filter expression.
            column (int): The index of the column to apply the filter to.
            action_name (str, optional): Name of the action, can be empty. Defaults to None.
            exact_match (bool, optional): If True, use exact matching for the filter. Defaults to False.
        """
        if expresion or expresion == '':
            if column in self.filters:
                if action_name or action_name == '':
                    self.filters[column].remove(expresion)
                else:
                    self.filters[column].append((expresion, exact_match))
            else:
                self.filters[column] = [(expresion, exact_match)]
        elif column in self.filters:
            if action_name or action_name == '':
                self.filters[column].remove(expresion)
                if not self.filters[column]:
                    del self.filters[column]
            else:
                del self.filters[column]
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        """
        Check if a row passes the filter criteria based on the column filters.

        Args:
            source_row (int): The row number in the source model.
            source_parent (QModelIndex): The parent index of the row.

        Returns:
            bool: True if the row meets the filter criteria, False otherwise.
        """
        for column, expresions in self.filters.items():
            text = self.sourceModel().index(source_row, column, source_parent).data()

            if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
                text = text.toString("yyyy-MM-dd")

            match_found = False 

            for expresion, exact_match in expresions:
                if expresion == '':  # If expression is empty, match empty cells
                    if text == '':
                        break

                if exact_match:
                    if text in expresion:  # Verificar si `text` está en la lista `expresion`
                        match_found = True
                        break
                
                elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', expresion[0]):
                    expresion = QtCore.QDate.fromString(expresion[0], "dd/MM/yyyy")
                    expresion = expresion.toString("yyyy-MM-dd")
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

                else:
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion[0]))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

            if not match_found:
                return False
        return True

class EditableTableModel2(QtSql.QSqlTableModel):
    """
    A custom SQL table model that supports editable columns, headers, and special flagging behavior based on user permissions.

    Signals:
        updateFailed (str): Signal emitted when an update to the model fails.
    """
    updateFailed = QtCore.pyqtSignal(str)

    def __init__(self, parent=None, column_range=None, table_check=None):
        """
        Initialize the model with user permissions and optional database and column range.

        Args:
            username (str): The username for permission-based actions.
            parent (QObject, optional): Parent object for the model. Defaults to None.
            column_range (list, optional): A list specifying the range of columns. Defaults to None.
            table_check (str, optional): A text scpecifying the table selected. Defaults to None
        """
        super().__init__(parent)
        self.column_range = column_range
        self.table_check = table_check

    def setAllColumnHeaders(self, headers):
        """
        Set headers for all columns in the model.

        Args:
            headers (list): A list of header names.
        """
        for column, header in enumerate(headers):
            self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIndividualColumnHeader(self, column, header):
        """
        Set the header for a specific column.

        Args:
            column (int): The column index.
            header (str): The header name.
        """
        self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIconColumnHeader(self, column, icon):
        """
        Set an icon in the header for a specific column.

        Args:
            column (int): The column index.
            icon (QIcon): The icon to display in the header.
        """
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        """
        Retrieve the header data for a specific section of the model.

        Args:
            section (int): The section index (column or row).
            orientation (Qt.Orientation): The orientation (horizontal or vertical).
            role (Qt.ItemDataRole, optional): The role for the header data. Defaults to DisplayRole.

        Returns:
            QVariant: The header data for the specified section.
        """
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return super().headerData(section, orientation, role)
        return super().headerData(section, orientation, role)

    def flags(self, index):
        """
        Get the item flags for a given index, controlling editability and selection based on user permissions.

        Args:
            index (QModelIndex): The index of the item.

        Returns:
            Qt.ItemFlags: The flags for the specified item.
        """
        flags = super().flags(index)

        value = index.model().data(index, role=Qt.ItemDataRole.DisplayRole)

        if index.column() == 165 and value == 'Facturado' and self.table_check == 'tags_data.tags_flow':
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        elif index.column() == 178 and value == 'Facturado' and self.table_check == 'tags_data.tags_temp':
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        elif index.column() == 175 and value == 'Facturado' and self.table_check == 'tags_data.tags_level':
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        elif index.column() == 65 and value == 'Facturado' and self.table_check == 'tags_data.tags_others':
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        else:
            if index.column() == 0 or index.column() in self.column_range:
                flags &= ~Qt.ItemFlag.ItemIsEditable
                return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
            else:
                return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable

    def getColumnHeaders(self, visible_columns):
        """
        Retrieve the headers for the specified visible columns.

        Args:
            visible_columns (list): List of column indices that are visible.

        Returns:
            list: A list of column headers for the visible columns.
        """
        column_headers = [self.headerData(col, Qt.Orientation.Horizontal) for col in visible_columns]
        return column_headers

class Ui_EditTags_Workshop_Window(QtWidgets.QMainWindow):
    """
    A window for editing tags in the application for workshop.

    Attributes:
        model (EditableTableModel): The data model for the table.
        proxy (CustomProxyModel): The proxy model for filtering and sorting.
        db (object): Database connection.
        checkbox_states (dict): States of checkboxes.
        dict_valuesuniques (dict): Unique values for columns.
        dict_ordersort (dict): Sorting order for columns.
        hiddencolumns (list): List of hidden column indices.
        action_checkbox_map (dict): Map of actions to checkboxes.
        checkbox_filters (dict): Filters based on checkbox states.
        name (str): Name associated with the window.
        variable (str): Variable used in the window.
    """
    def __init__(self,name,db):
        """
        Initializes the Ui_EditTags_Workshop_Window with the specified name and database connection.

        Args:
            name (str): Name associated with the window.
            db (object): Database connection.
        """
        super().__init__()
        self.model = EditableTableModel()
        self.proxy = CustomProxyModel()
        self.model2 = EditableTableModel2()
        self.proxy2 = CustomProxyModel2()
        self.db = db

        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []
        self.variable = ''
        self.action_checkbox_map = {}
        self.checkbox_filters = {}

        self.checkbox_states2 = {}
        self.dict_valuesuniques2 = {}
        self.dict_ordersort2 = {}
        self.hiddencolumns2 = []
        self.variable2 = None
        self.action_checkbox_map2 = {}
        self.checkbox_filters2 = {}
        self.tableEditTags2 = None

        self.name = name
        self.variable = ''
        self.setupUi(self)

    def closeEvent(self, event):
        """
        Handles the event triggered when the window is closed. Ensures models are cleared and database connections are closed.

        Args:
            event (QCloseEvent): The close event triggered when the window is about to close.
        """
        if self.model:
            self.model.clear()
        if self.model2:
            self.model2.clear()
        self.closeConnection()

    def closeConnection(self):
        """
        Closes the database connection and clears any references to the models.
        Also removes the 'drawing_index' database connection from Qt's connection list if it exists.
        """
        self.tableEditTags.setModel(None)
        del self.model
        if self.tableEditTags2:
            self.tableEditTags2.setModel(None)
        del self.model2
        if self.db:
            self.db.close()
            del self.db
            if QtSql.QSqlDatabase.contains("qt_sql_default_connection"):
                QtSql.QSqlDatabase.removeDatabase("qt_sql_default_connection")

    def setupUi(self, EditTagsWorkshop_Window):
        """
        Sets up the user interface for the EditTagsWorkshop_Window.

        Args:
            EditTagsWorkshop_Window (QtWidgets.QMainWindow): The main window for the UI setup.
        """
        EditTagsWorkshop_Window.setObjectName("EditTagsWorkshop_Window")
        EditTagsWorkshop_Window.resize(790, 595)
        EditTagsWorkshop_Window.setMinimumSize(QtCore.QSize(790, 595))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        EditTagsWorkshop_Window.setWindowIcon(icon)
        EditTagsWorkshop_Window.setStyleSheet(
".QFrame {\n"
"    border: 2px solid black;\n"
"}")
        self.centralwidget = QtWidgets.QWidget(parent=EditTagsWorkshop_Window)
        self.centralwidget.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_2.setVerticalSpacing(10)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.hcab=QtWidgets.QHBoxLayout()
        self.hcab.setObjectName("hcab")
        self.toolDeleteFilter = QtWidgets.QToolButton(self.frame)
        self.toolDeleteFilter.setObjectName("Save_Button")
        self.hcab.addWidget(self.toolDeleteFilter)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Delete.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolDeleteFilter.setIcon(icon)
        self.toolDeleteFilter.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer1=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer1)
        self.toolShow = QtWidgets.QToolButton(self.frame)
        self.toolShow.setObjectName("Show_Button")
        self.toolShow.setToolTip("Mostrar columnas")
        self.hcab.addWidget(self.toolShow)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Eye.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolShow.setIcon(icon)
        self.toolShow.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer2=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer2)
        self.toolExpExcel = QtWidgets.QToolButton(self.frame)
        self.toolExpExcel.setObjectName("ExpExcel_Button")
        self.toolExpExcel.setToolTip("Exportar a Excel")
        self.hcab.addWidget(self.toolExpExcel)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Excel.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolExpExcel.setIcon(icon)
        self.toolExpExcel.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer3=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer3)
        self.toolStickers = QtWidgets.QToolButton(self.frame)
        self.toolStickers.setObjectName("toolStickers")
        self.toolStickers.setToolTip("Generar Pegatinas")
        self.hcab.addWidget(self.toolStickers)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Sticker.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolStickers.setIcon(icon)
        self.toolStickers.setIconSize(QtCore.QSize(25, 25))

        self.hcabspacer=QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer)
        self.gridLayout_2.addLayout(self.hcab, 0, 0, 1, 1)
        self.hLayout1 = QtWidgets.QHBoxLayout()
        self.hLayout1.setObjectName("hLayout1")
        self.label_NumOrder = QtWidgets.QLabel(parent=self.frame)
        self.label_NumOrder.setMinimumSize(QtCore.QSize(80, 25))
        self.label_NumOrder.setMaximumSize(QtCore.QSize(80, 25))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        self.label_NumOrder.setFont(font)
        self.label_NumOrder.setObjectName("label_NumOrder")
        self.hLayout1.addWidget(self.label_NumOrder)
        self.Numorder_EditTags = QtWidgets.QLineEdit(parent=self.frame)
        self.Numorder_EditTags.setMinimumSize(QtCore.QSize(250, 25))
        self.Numorder_EditTags.setMaximumSize(QtCore.QSize(250, 25))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.Numorder_EditTags.setFont(font)
        self.Numorder_EditTags.setObjectName("Numorder_EditTags")
        self.hLayout1.addWidget(self.Numorder_EditTags)
        self.gridLayout_2.addLayout(self.hLayout1, 1, 0, 1, 1)
        self.Button_Query = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Query.setMinimumSize(QtCore.QSize(150, 35))
        self.Button_Query.setMaximumSize(QtCore.QSize(150, 35))
        self.Button_Query.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.Button_Query.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 8px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:focus {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255)\n"
"}\n"
"\n"
"QPushButton:focus:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        self.Button_Query.setObjectName("Button_Query")
        self.hLayout1.addWidget(self.Button_Query)
        self.model = EditableTableModel()
        self.tableEditTags=FreezeTableWidget(self.model, '')
        self.tableEditTags.setObjectName("tableEditTags")
        self.gridLayout_2.addWidget(self.tableEditTags, 3, 0, 1, 1)
        self.hLayout3 = QtWidgets.QHBoxLayout()
        self.hLayout3.setObjectName("hLayout3")
        spacerItem2 = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hLayout3.addItem(spacerItem2)
        self.label_SumItems = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setText("")
        self.label_SumItems.setObjectName("label_SumItems")
        self.hLayout3.addWidget(self.label_SumItems)
        self.label_SumValue = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setText("")
        self.label_SumValue.setObjectName("label_SumValue")
        self.hLayout3.addWidget(self.label_SumValue)
        self.label_CountItems = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setText("")
        self.label_CountItems.setObjectName("label_CountItems")
        self.hLayout3.addWidget(self.label_CountItems)
        self.label_CountValue = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setText("")
        self.label_CountValue.setObjectName("label_CountValue")
        self.hLayout3.addWidget(self.label_CountValue)
        self.gridLayout_2.addLayout(self.hLayout3, 4, 0, 1, 1)
        self.model2 = EditableTableModel2()
        self.tableEditTags2=FreezeTableWidget2(self.model2, '')
        self.tableEditTags2.setObjectName("tableEditTags2")
        self.gridLayout_2.addWidget(self.tableEditTags2, 5, 0, 1, 1)
        self.tableEditTags2.hide()
        self.hLayout4 = QtWidgets.QHBoxLayout()
        self.hLayout4.setObjectName("hLayout4")
        spacerItem1 = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hLayout4.addItem(spacerItem1)
        self.label_SumItems2 = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems2.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems2.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems2.setText("")
        self.label_SumItems2.setObjectName("label_SumItems2")
        self.hLayout4.addWidget(self.label_SumItems2)
        self.label_SumValue2 = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue2.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue2.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue2.setText("")
        self.label_SumValue2.setObjectName("label_SumValue2")
        self.hLayout4.addWidget(self.label_SumValue2)
        self.label_CountItems2 = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems2.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems2.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems2.setText("")
        self.label_CountItems2.setObjectName("label_CountItems2")
        self.hLayout4.addWidget(self.label_CountItems2)
        self.label_CountValue2 = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue2.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue2.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue2.setText("")
        self.label_CountValue2.setObjectName("label_CountValue2")
        self.hLayout4.addWidget(self.label_CountValue2)
        self.gridLayout_2.addLayout(self.hLayout4, 6, 0, 1, 1)
        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 0, 0, 1, 1)
        self.gridLayout.addWidget(self.frame, 0, 0, 1, 1)
        EditTagsWorkshop_Window.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=EditTagsWorkshop_Window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 790, 22))
        self.menubar.setObjectName("menubar")
        EditTagsWorkshop_Window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=EditTagsWorkshop_Window)
        self.statusbar.setObjectName("statusbar")
        EditTagsWorkshop_Window.setStatusBar(self.statusbar)

        self.retranslateUi(EditTagsWorkshop_Window)
        QtCore.QMetaObject.connectSlotsByName(EditTagsWorkshop_Window)
        self.Button_Query.clicked.connect(self.query_tags)
        self.toolDeleteFilter.clicked.connect(self.delete_allFilters)
        self.toolShow.clicked.connect(self.show_columns)
        self.toolExpExcel.clicked.connect(self.exporttoexcel)
        self.toolStickers.clicked.connect(self.stickerexcel)
        self.Numorder_EditTags.returnPressed.connect(self.query_tags)
        self.createContextMenu()


# Function to translate and updates the text of various UI elements
    def retranslateUi(self, EditTagsWorkshop_Window):
        """
        Translates and updates the text of various UI elements.
        """
        _translate = QtCore.QCoreApplication.translate
        EditTagsWorkshop_Window.setWindowTitle(_translate("EditTagsWorkshop_Window", "Consultar Tags"))
        self.tableEditTags.setSortingEnabled(True)
        self.Button_Query.setText(_translate("EditTagsWorkshop_Window", "Buscar"))
        self.label_NumOrder.setText(_translate("EditTagsWorkshop_Window", "Nº Pedido:"))

# Function to clear the text boxes
    def clean_boxes(self):
        """
        Clear text boxes to write new data

        Returns:
            dict: Dictionary of column filters.
        """
        self.Numorder_EditTags.setText("")

# Function to delete all filters when tool button is clicked
    def delete_allFilters(self):
        """
        Resets all filters and updates the table model with unique values for each column.
        """
        if self.proxy.rowCount() != 0:
            columns_number=self.model.columnCount()
            for index in range(columns_number):
                if index in self.proxy.filters:
                    del self.proxy.filters[index]
                self.model.setIconColumnHeader(index, '')

            self.checkbox_states = {}
            self.dict_valuesuniques = {}
            self.dict_ordersort = {}
            self.checkbox_filters = {}

            self.proxy.invalidateFilter()
            # self.tableEditTags.setModel(None)
            # self.tableEditTags.setModel(self.proxy)
            self.proxy.setSourceModel(self.model)
            self.tableEditTags=FreezeTableWidget(self.proxy)

            # Getting the unique values for each column of the model
            for column in range(self.model.columnCount()):
                list_valuesUnique = []
                if column not in self.checkbox_states:
                    self.checkbox_states[column] = {}
                    self.checkbox_states[column]['Seleccionar todo'] = True
                    for row in range(self.model.rowCount()):
                        value = self.model.record(row).value(column)
                        if value not in list_valuesUnique:
                            if isinstance(value, QtCore.QDate):
                                value=value.toString("dd/MM/yyyy")
                            list_valuesUnique.append(str(value))
                            self.checkbox_states[column][value] = True
                    self.dict_valuesuniques[column] = list_valuesUnique

            self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditTags.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditTags.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function to save changes into database
    def saveChanges(self):
        """
        Saves changes made to the data models and updates unique values for each column.
        """
        self.model.submitAll()

        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            for row in range(self.model.rowCount()):
                value = self.model.record(row).value(column)
                if value not in list_valuesUnique:
                    if isinstance(value, QtCore.QDate):
                        value=value.toString("dd/MM/yyyy")
                    list_valuesUnique.append(str(value))
                    if value not in self.checkbox_states[column]:
                        self.checkbox_states[column][value] = True
            self.dict_valuesuniques[column] = list_valuesUnique

        self.model2.submitAll()

        for column in range(self.model2.columnCount()):
            list_valuesUnique2 = []
            for row in range(self.model2.rowCount()):
                value = self.model2.record(row).value(column)
                if value not in list_valuesUnique2:
                    if isinstance(value, QtCore.QDate):
                        value=value.toString("dd/MM/yyyy")
                    list_valuesUnique2.append(str(value))
                    if value not in self.checkbox_states2[column]:
                        self.checkbox_states2[column][value] = True
            self.dict_valuesuniques2[column] = list_valuesUnique2

# Function to load table and setting in the window
    def query_tags(self):
        """
        Queries the database for tags based on the number order, configures and populates tables with the query results, 
        and updates the UI accordingly. Handles potential database errors and updates the UI with appropriate messages.
        """
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []

        self.variable2 = None

        self.numorder = self.Numorder_EditTags.text()

        if self.numorder=="":
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("Rellena alguno de los campos")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg.exec()
            del dlg, new_icon

        else:
            if not re.match(r'^(P|PA)-\d{2}/\d{3}.*$', self.numorder):
                dlg = QtWidgets.QMessageBox()
                new_icon = QtGui.QIcon()
                new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                dlg.setWindowIcon(new_icon)
                dlg.setWindowTitle("ERP EIPSA")
                dlg.setText("El número de pedido debe tener formato P-XX/YYY o PA-XX/YYY")
                dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                dlg.exec()
                del dlg, new_icon

            else:
                query = ('''
                        SELECT num_order, product_type."variable"
                        FROM orders
                        INNER JOIN offers ON (offers."num_offer" = orders."num_offer")
                        INNER JOIN product_type ON (product_type."material" = offers."material")
                        WHERE
                        UPPER (orders."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')
                conn = None
                try:
                # read the connection parameters
                    params = config()
                # connect to the PostgreSQL server
                    conn = psycopg2.connect(**params)
                    cur = conn.cursor()
                # execution of commands
                    cur.execute(query,(self.numorder,))
                    results_variable=cur.fetchone()
                    self.variable = results_variable[1] if results_variable != None else ''
                # close communication with the PostgreSQL database server
                    cur.close()
                # commit the changes
                    conn.commit()
                except (Exception, psycopg2.DatabaseError) as error:
                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("ERP EIPSA")
                    dlg.setText("Ha ocurrido el siguiente error:\n"
                                + str(error))
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                    dlg.exec()
                    del dlg, new_icon
                finally:
                    if conn is not None:
                        conn.close()

                if results_variable == None:
                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("ERP EIPSA")
                    dlg.setText("EL número de pedido no existe")
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                    dlg.exec()
                    del dlg, new_icon

                else:
                    query_flow = ('''
                        SELECT tags_data.tags_flow."num_order"
                        FROM tags_data.tags_flow
                        WHERE UPPER (tags_data.tags_flow."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')
                    query_temp = ('''
                        SELECT tags_data.tags_temp."num_order"
                        FROM tags_data.tags_temp
                        WHERE UPPER (tags_data.tags_temp."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')
                    query_level = ('''
                        SELECT tags_data.tags_level."num_order"
                        FROM tags_data.tags_level
                        WHERE UPPER (tags_data.tags_level."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')
                    query_others = ('''
                        SELECT tags_data.tags_others."num_order"
                        FROM tags_data.tags_others
                        WHERE UPPER (tags_data.tags_others."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')
                    conn = None
                    try:
                    # read the connection parameters
                        params = config()
                    # connect to the PostgreSQL server
                        conn = psycopg2.connect(**params)
                        cur = conn.cursor()
                    # execution of commands
                        cur.execute(query_flow,(self.numorder,))
                        results_flow=cur.fetchall()
                        cur.execute(query_temp,(self.numorder,))
                        results_temp=cur.fetchall()
                        cur.execute(query_level,(self.numorder,))
                        results_level=cur.fetchall()
                        cur.execute(query_others,(self.numorder,))
                        results_others=cur.fetchall()

                        if len(results_flow) != 0 and len(results_temp) != 0:
                            self.variable = 'Caudal+Temp'
                        elif len(results_flow) != 0 and len(results_level) != 0:
                            self.variable = 'Caudal+Nivel'
                        elif len(results_flow) != 0:
                            self.variable = 'Caudal'
                        elif len(results_temp) != 0:
                            self.variable = 'Temperatura'
                        elif len(results_level) != 0:
                            self.variable = 'Nivel'
                        elif len(results_others) != 0:
                            self.variable = 'Otros'
                        else:
                            self.variable = ''

                    # close communication with the PostgreSQL database server
                        cur.close()
                    # commit the changes
                        conn.commit()
                    except (Exception, psycopg2.DatabaseError) as error:
                        dlg = QtWidgets.QMessageBox()
                        new_icon = QtGui.QIcon()
                        new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                        dlg.setWindowIcon(new_icon)
                        dlg.setWindowTitle("ERP EIPSA")
                        dlg.setText("Ha ocurrido el siguiente error:\n"
                                    + str(error))
                        dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                        dlg.exec()
                        del dlg, new_icon
                    finally:
                        if conn is not None:
                            conn.close()

                    if self.variable == 'Caudal+Temp':
                        self.variable = 'Caudal'
                        self.variable2 = 'Temperatura'
                        self.model.setTable("tags_data.tags_flow")
                        self.model2.setTable("tags_data.tags_temp")
                        self.variable_cells = [47,48]
                        self.variable_cells2 = [57,58,62]
                    elif self.variable =='Caudal+Nivel':
                        self.variable = 'Caudal'
                        self.variable2 = 'Nivel'
                        self.model.setTable("tags_data.tags_flow")
                        self.model2.setTable("tags_data.tags_level")
                        self.variable_cells = [47,48]
                        self.variable_cells2 = [51,52]
                    elif self.variable =='Temp+Nivel':
                        self.variable = 'Temperatura'
                        self.variable2 = 'Nivel'
                        self.model.setTable("tags_data.tags_temp")
                        self.model2.setTable("tags_data.tags_level")
                        self.variable_cells = [57,58,62]
                        self.variable_cells2 = [51,52]
                    elif self.variable == 'Caudal':
                        self.model.setTable("tags_data.tags_flow")
                        self.variable_cells = [47,48]
                        self.initial_column = 34
                    elif self.variable == 'Temperatura':
                        self.model.setTable("tags_data.tags_temp")
                        self.variable_cells = [57,58,62]
                    elif self.variable == 'Nivel':
                        self.model.setTable("tags_data.tags_level")
                        self.variable_cells = [51,52]
                    elif self.variable == 'Otros':
                        self.model.setTable("tags_data.tags_others")
                        self.variable_cells = [15,16]
                    self.model.setFilter(f"num_order <>'' AND UPPER(num_order) LIKE '%{self.numorder.upper()}%' AND tag_state <> 'FOR INVOICING'")
                    self.model2.setFilter(f"num_order <>'' AND UPPER(num_order) LIKE '%{self.numorder.upper()}%' AND tag_state <> 'FOR INVOICING'")

        if self.variable != '':
            self.tableEditTags2.hide()
            self.tableEditTags.setModel(None)
            self.model.select()

            self.proxy.setSourceModel(self.model)
            self.tableEditTags=FreezeTableWidget(self.proxy, self.variable)

            columns_number=self.model.columnCount()
            for column in range(columns_number):
                self.tableEditTags.setItemDelegateForColumn(column, None)
            self.model.column_range = self.variable_cells

            if self.variable == 'Caudal':
                for i in range(72,125):
                    self.tableEditTags.hideColumn(i)
                for i in range(127,131):
                    self.tableEditTags.hideColumn(i)
                for i in range(132,136):
                    self.tableEditTags.hideColumn(i)
                for i in range(137,142):
                    self.tableEditTags.hideColumn(i)
                for i in range(143,150):
                    self.tableEditTags.hideColumn(i)
                for i in range(151,153):
                    self.tableEditTags.hideColumn(i)
                for i in range(154,156):
                    self.tableEditTags.hideColumn(i)
                for i in range(157,columns_number-1):
                    self.tableEditTags.hideColumn(i)

            elif self.variable == 'Temperatura':
                for i in range(80,132):
                    self.tableEditTags.hideColumn(i)
                for i in range(134,138):
                    self.tableEditTags.hideColumn(i)
                for i in range(139,143):
                    self.tableEditTags.hideColumn(i)
                for i in range(144,149):
                    self.tableEditTags.hideColumn(i)
                for i in range(150,157):
                    self.tableEditTags.hideColumn(i)
                for i in range(158,160):
                    self.tableEditTags.hideColumn(i)
                for i in range(161,163):
                    self.tableEditTags.hideColumn(i)
                for i in range(164,166):
                    self.tableEditTags.hideColumn(i)
                for i in range(167,columns_number-1):
                    self.tableEditTags.hideColumn(i)

            elif self.variable == 'Nivel':
                for i in range(66,138):
                    self.tableEditTags.hideColumn(i)
                for i in range(140,144):
                    self.tableEditTags.hideColumn(i)
                for i in range(145,149):
                    self.tableEditTags.hideColumn(i)
                for i in range(150,154):
                    self.tableEditTags.hideColumn(i)
                for i in range(155,163):
                    self.tableEditTags.hideColumn(i)
                for i in range(165,166):
                    self.tableEditTags.hideColumn(i)
                for i in range(167,169):
                    self.tableEditTags.hideColumn(i)
                for i in range(170,columns_number-1):
                    self.tableEditTags.hideColumn(i)

            elif self.variable == 'Otros':
                for i in range(27,31):
                    self.tableEditTags.hideColumn(i)
                for i in range(33,36):
                    self.tableEditTags.hideColumn(i)
                for i in range(37,42):
                    self.tableEditTags.hideColumn(i)
                for i in range(43,50):
                    self.tableEditTags.hideColumn(i)
                for i in range(51,53):
                    self.tableEditTags.hideColumn(i)
                for i in range(54,56):
                    self.tableEditTags.hideColumn(i)
                for i in range(57,columns_number-1):
                    self.tableEditTags.hideColumn(i)

            if self.name != 'Jesús Martínez':
                if self.variable == 'Caudal':
                    self.tableEditTags.hideColumn(30)
                elif self.variable == 'Temperatura':
                    self.tableEditTags.hideColumn(35)
                elif self.variable == 'Nivel':
                    self.tableEditTags.hideColumn(36)
                elif self.variable == 'Otros':
                    self.tableEditTags.hideColumn(11)

            # self.tableEditTags.verticalHeader().hide()
            self.tableEditTags.setItemDelegate(AlignDelegate(self.tableEditTags))
            self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditTags.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditTags.horizontalHeader().setSectionResizeMode(columns_number-2,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditTags.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")
            self.tableEditTags.setObjectName("tableEditTags")
            self.gridLayout_2.addWidget(self.tableEditTags, 3, 0, 1, 1)
            self.tableEditTags.setSortingEnabled(False)
            self.tableEditTags.horizontalHeader().sectionDoubleClicked.connect(lambda logicalIndex: self.on_view_horizontalHeader_sectionClicked(logicalIndex, self.tableEditTags, self.model, self.proxy))
            self.tableEditTags.horizontalHeader().customContextMenuRequested.connect(self.showColumnContextMenu)
            self.tableEditTags.horizontalHeader().setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)

        # Change all column names
            headers_flow = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                            "PO", "Posición", "Subposición", "Tipo", "Tamaño Línea",
                            "Rating", "Facing", "Schedule", "Material Brida", "Tipo Brida",
                            "Material Tubo", "Tamaño Tomas (Nº x Brida)", "Material Elemento", "Tipo Placa", "Espesor Placa",
                            "Estándar Placa", "Material Junta", "Material Tornillería", "Con. Válvula", "Material Cuerpo Vlv.",
                            "Nº Saltos", "Pipe Spec.", "Peso Aprox. (kg)", "Long. Aprox. (mm)", "NACE",
                            "Precio (€)", "Notas Oferta", "Cambios Comercial", "Fecha Contractual", "Ø Orif. (mm)",
                            "Ø D/V (mm)", "Cambios Técnicos", "Notas Técnicas", "Nº Doc. EIPSA Cálculo", "Estado Cálculo",
                            "Fecha Estado Cálculo", "Nº Doc. EIPSA Plano", "Estado Plano", "Fecha Estado Plano", "Orden de Compra",
                            "Fecha Orden Compra", "Notas Orden Compra", 'Plano Dimensional', "Plano OF", "Fecha OF",
                            "Notas Equipo", "Colada Placa", "Cert. Placa", "Colada Brida", "Cert. Brida", "Nº Tapones",
                            "Tamaño Tomas", "Nº Tomas x Brida", "RTJ Porta Material", "RTJ Espesor", "RTJ Dim",
                            "Ø Ext. Placa (mm)", "Mango", "Tamaño Espárragos", "Cantidad Espárragos", "Tamaño Extractor",
                            "Cantidad Extractor", "Estado Fabricación", "Inspección", "Fecha Inspección", "Envío RN", "Fecha RN", "Cod. Equipo",
                            "Cod. Fab. Equipo", "Trad. Equipo", "Cod. Brida Orif.", "Cod. Fab. Brida Orif.", "Cant. Brida Orif.",
                            "Cod. Brida Línea", "Cod. Fab. Brida Línea", "Cant. Brida Línea", "Cod. Junta", "Cod. Fab. Junta",
                            "Cant. Junta", "Cod. Tornillería", "Cod. Fab. Tornillería", "Cant. Tornillería", "Cod. Tapones",
                            "Cod. Fab. Tapones", "Cant. Tapones", "Cod. Extractor", "Cod. Fab. Extractor", "Cant. Extractor",
                            "Cod. Placa", "Cod. Fab. Placa", "Cant. Placa", "Cod. Niplo", "Cod. Fab. Niplo",
                            "Cant. Niplo", "Cod. Mango", "Cod. Fab. Mango", "Cant. Mango", "Cod. Ch. Ring",
                            "Cod. Fab. Ch. Ring", "Cant. Ch. Ring", "Cod. Tubo", "Cod. Fab. Tubo", "Cant. Tubo",
                            "Cod. Pieza2", "Cod. Fab. Pieza2", "Cant. Pieza2", "Diam. Int", "Pedido Tipo Tag",
                            "Trad. Brida. Orif", "Trad. Brida Línea", "Trad. Junta", "Trad. Tornillería", "Trad. Tapones",
                            "Trad. Extractor", "Trad. Placa", "Trad. Niplo", "Trad. Mango", "Trad. Ch. Ring",
                            "Trad. Tubo", "Trad. Pieza2", "Fecha PMI", "Fecha PH1", "Manómetro PH1", "Presión PH1",
                            "Estado PH1", "Notas PH1", "Fecha PH2", "Manómetro PH2", "Presión PH2",
                            "Estado PH2", "Notas PH2", "Fecha LP", "LP Colada 9PR5", "LP Colada 9D1B",
                            "LP Colada 996PB", "Estado LP", "Notas LP", "Fecha Dureza", "Dureza",
                            "Dureza HB", "Bola", "Carga", "Colada Dureza", "Estado Dureza",
                            "Notas Dureza", "Fecha Verif. Dim.", "Estado Verif. Dim.", "Notas Verif. Dim", "Fecha Verif. OF",
                            "Estado Verif. OF", "Notas Verif. OF", "Fotos",
                            "Posición", "Subposición", "Importe", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas", "Estado Fact", "Fotos 2"]

            headers_temp = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                            "PO", "Posición", "Subposición", "Tipo", "Tipo TW",
                            "Tamaño", "Rating", "Facing", "Standard TW", "Material TW",
                            "Long. STD (mm)", "Long. Ins. (mm)", "Ø Raíz (mm)", "Ø Punta (mm)", "Sensor",
                            "Material Sheath/Stem", "Ø Sheath/Stem (mm)", "Insulation", "Temp Inf (ºC)", "Temp Sup ºC",
                            "Material Nipple Ext.", "Long. Nipple Ext. (mm)", "Material Head/Case", "Con. Elec./Diam. Case", "TT/Terminal Insulation",
                            "Material Brida LapJoint", "Material Junta", "Puntal", "Tubo", "NACE",
                            "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual", "Stress",
                            "Geometría", "Long. Cónica (mm)", "Long. Recta (mm)", "Bore // Tip", "Notas Cálculo",
                            "Cambios Técnicos", "Notas Técnicas", "Nº Doc. EIPSA Cálculo", "Estado Cálculo", "Fecha Estado Cálculo",
                            "Nº Doc. EIPSA Plano", "Estado Plano", "Fecha Estado Plano", "Notas Planos", "Orden de Compra",
                            "Fecha Orden Compra", "Notas Orden Compra", "Plano Dimensional", "Plano OF Sensor", "Fecha OF Sensor", 
                            "Notas Sensor", "Estado Fabricación Sensor", "Plano OF TW", "Fecha OF TW", "Notas TW",
                            "Estado Fabricación TW", "Colada Barra", "Cert. Barra", "Colada Brida", "Cert. Brida",
                            "Long. Corte TW (mm)", "Cota A Sensor (mm)", "Cota B Sensor (mm)", "Cota L Sensor (mm)", "Tapón",
                            "Estado Fabricación", "Inspección", "Fecha Inspección", "Envío RN", "Fecha RN", "Cod. Equipo", "Cod. Fab. Equipo",
                            "Trad. Equipo", "Cod. Barra", "Cod. Fab. Barra", "Cant. Barra", "Cod. Tubo",
                            "Cod. Fab. Tubo", "Cant. Tubo", "Cod. Brida", "Cod. Fab. Brida", "Cant. Brida",
                            "Cod. Sensor", "Cod. Fab. Sensor", "Cant. Sensor", "Cod. Cabeza", "Cod. Fab. Cabeza",
                            "Cant. Cabeza", "Cod. BTB", "Cod. Fab. BTB", "Cant. BTB", "Cod. Niplo Ext.",
                            "Cod. Fab. Niplo Ext.", "Cant. Niplo Ext.", "Cod. Muelle", "Cod. Fab. Muelle", "Cant. Muelle",
                            "Cod. Puntal", "Cod. Fab. Puntal", "Cant. Puntal", "Cod. Tapón", "Cod. Fab. Tapón", "Cant. Tapón",
                            "Cod. TW", "Cod. Fab. TW", "Cant. TW", "Cod. Adit.", "Cod. Fab. Adit.",
                            "Cant. Adit", "Pedido Tipo Tag", "Trad. Barra", "Trad. Tubo", "Trad. Brida",
                            "Trad. Sensor", "Trad. Cabeza", "Trad. BTB", "Trad. Niplo Ext.", "Trad. Muelle",
                            "Trad. Puntal", "Trad. Tapón", "Trad. TW", "Trad. Adit.", "Fecha PMI", "Fecha PH1",
                            "Manómetro PH1", "Presión PH1", "Estado PH1", "Notas PH1", "Fecha PH2",
                            "Manómetro PH2", "Presión PH2", "Estado PH2", "Notas PH2", "Fecha LP",
                            "LP Colada 9PR5", "LP Colada 9D1B", "LP Colada 996PB", "Estado LP", "Notas LP",
                            "Fecha Dureza", "Dureza", "Dureza HB", "Bola", "Carga",
                            "Colada Dureza", "Estado Dureza", "Notas Dureza", "Fecha Verif. Dim.", "Estado Verif. Dim.",
                            "Notas Verif. Dim", "Fecha Verif. OF", "Estado Verif. OF.", "Notas Verif. OF", "Fecha Verif. OF Sensor",
                            "Estado Verif. OF Sensor", "Notas Verif. OF Sensor", "Fotos",
                            "Posición", "Subposición", "Importe Factura", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas", "Estado Fact", "Fotos 2"]

            headers_level = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                            "PO", "Posición", "Subposición", "Tipo", "Modelo",
                            "Material Cuerpo", "Tipo Conex. Proc.", "Tamaño Conex. Proc.", "Rating Conex. Proc.", "Facing Conex. Proc.",
                            "Tipo Conex.", "Visibilidad (mm)", "Long. C-C (mm)", "Tipo Válv.", "Tipo Conex. Ext.",
                            "Tamaño Conex. Ext.", "Rating Conex. Ext.", "Facing Conex. Ext.", "Junta", "Tornillería",
                            "Iluminador", "Mat. Flotador", "Mat. Cubierta", "Escala", "Banderas",
                            "Cod. IP", "Tipo Brida", "Niplo Hex.", "Niplo Tubo", "Antifrost",
                            "NACE", "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual",
                            "Dim. Flotador", "Junta Bridas", "Cambios Técnicos", "Notas Técnicas", "Nº Doc. EIPSA Plano",
                            "Estado Plano", "Fecha Estado Plano", "Notas Plano", "Orden de Compra", "Fecha Orden Compra",
                            "Notas Orden Compra", "Plano Dimensional", "Plano OF", "Fecha OF", "Notas Equipo",
                            "Colada Cuerpo", "Cert. Cuerpo", "Colada Cuerpo Vlv", "Cert. Cuerpo Vlv", "Colada Brida Vlv", "Cert. Brida Vlv",
                            "Estado Fabricación", "Inspección", "Fecha Inspección", "Envío RN", "Fecha RN", "Cod. Equipo", "Cod. Fab. Equipo",
                            "Trad. Equipo", "Cod. Cuerpo", "Cod. Fab. Cuerpo", "Cant. Cuerpo", "Cod. Cubierta",
                            "Cod. Fab. Cubierta", "Cant. Cubierta", "Cod. Tornillería", "Cod. Fab. Tornillería", "Cant. Tornillería",
                            "Cdo. Niplo Hex.", "Cod. Fab. Niplo Hex.", "Cant. Niplo Hex.", "Cod. Válv.", "Cod. Fab. Válv.",
                            "Cant. Válv.", "Cod. Brida", "Cod. Fab. Brida", "Cant. Brida", "Cod. DV",
                            "Cod. Fab. DV", "Cant. DV", "Cod. Escala", "Cod. Fab. Escala", "Cant. Escala",
                            "Cod. Ilum.", "Cod. Fab. Ilum", "Cant. Ilum", "Cod. Junta Vidrio", "Cod. Fab. Junta Vidrio",
                            "Cant. Junta Vidrio", "Cod. Vidrio", "Cod. Fab. Vidrio", "Cant. Vidrio", "Cod. Flotador",
                            "Cod. Fab. Flotador", "Cant. Flotador", "Cod. Mica", "Cod. Fab. Mica", "Cant. Mica",
                            "Cod. Flags", "Cod. Fab. Flags", "Cant. Flags", "Cod. Junta Brida", "Cod. Fab. Junta Brida",
                            "Cant. Junta Brida", "Cod. Niplo Tubo", "Cod. Fab. Niplo Tubo", "Cant. Niplo Tubo", "Cod. Antifrost",
                            "Cod. Fab. Antifrost", "Cant. Antifrost", "Pedido Tipo Tag", "Trad. Cuerpo", "Trad. Cubierta",
                            "Trad. Tornillería", "Trad. Niplo Hex.", "Trad. Válv", "Trad. Brida", "Trad. DV",
                            "Trad. Escala", "Trad. Ilum.", "Trad. Junta Vidrio", "Trad. Vidrio", "Trad. Flotador",
                            "Trad. Mica", "Trad. Flags", "Trad. Junta Brida", "Trad. Niplo Tubo", "Trad. Antifrost",
                            "Fecha PMI", "Fecha PH1", "Manómetro PH1", "Presión PH1",
                            "Estado PH1", "Notas PH1", "Fecha PH2", "Manómetro PH2", "Presión PH2",
                            "Estado PH2", "Notas PH2", "Fecha LP", "LP Colada 9PR5", "LP Colada 9D1B",
                            "LP Colada 996PB", "Estado LP", "Notas LP", "Fecha Dureza", "Dureza",
                            "Dureza HB", "Bola", "Carga", "Colada Dureza", "Estado Dureza",
                            "Notas Dureza", "Fecha Verif. Dim.", "Estado Verif. Dim.", "Notas Verif. Dim", "Fecha Verif. OF",
                            "Estado Verif. OF", "Notas Verif. OF", "Fotos",
                            "Posición", "Subposición", "Importe", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas", "Estado Fact", "Fotos 2"]

            headers_others = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                            "PO", "Posición", "Subposición", "Descripción", "Código Equipo",
                            "NACE", "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual",
                            "Plano Dimensional", "Plano OF", "Fecha OF", "Colada", "Cert. Colada", "Estado Fabricación", "Inspección", "Fecha Inspección", "Envío RN", "Fecha RN",
                            "Fecha PMI", "Fecha PH1", "Manómetro PH1", "Presión PH1",
                            "Estado PH1", "Notas PH1", "Fecha PH2", "Manómetro PH2", "Presión PH2",
                            "Estado PH2", "Notas PH2", "Fecha LP", "LP Colada 9PR5", "LP Colada 9D1B",
                            "LP Colada 996PB", "Estado LP", "Notas LP", "Fecha Dureza", "Dureza",
                            "Dureza HB", "Bola", "Carga", "Colada Dureza", "Estado Dureza",
                            "Notas Dureza", "Fecha Verif. Dim.", "Estado Verif. Dim.", "Notas Verif. Dim", "Fecha Verif. OF",
                            "Estado Verif. OF", "Notas Verif. OF", "Fotos",
                            "Posición", "Subposición", "Importe", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas", "Estado Fact", "Fotos 2"]

            if self.variable == 'Caudal':
                self.model.setAllColumnHeaders(headers_flow)
            elif self.variable == 'Temperatura':
                self.model.setAllColumnHeaders(headers_temp)
            elif self.variable == 'Nivel':
                self.model.setAllColumnHeaders(headers_level)
            elif self.variable == 'Otros':
                self.model.setAllColumnHeaders(headers_others)

        # Getting the unique values for each column of the model
            for column in range(self.model.columnCount()):
                list_valuesUnique = []
                if column not in self.checkbox_states:
                    self.checkbox_states[column] = {}
                    self.checkbox_states[column]['Seleccionar todo'] = True
                    for row in range(self.model.rowCount()):
                        value = self.model.record(row).value(column)
                        if value not in list_valuesUnique:
                            if isinstance(value, QtCore.QDate):
                                value=value.toString("dd/MM/yyyy")
                            list_valuesUnique.append(str(value))
                            self.checkbox_states[column][value] = True
                    self.dict_valuesuniques[column] = list_valuesUnique

            self.selection_model = self.tableEditTags.selectionModel()
            self.selection_model.selectionChanged.connect(self.countSelectedCells)

            if self.variable2 is not None:
                self.tableEditTags2.show()
                self.checkbox_states2 = {}
                self.dict_valuesuniques2 = {}
                self.dict_ordersort2 = {}
                self.hiddencolumns2 = []

                self.tableEditTags2.setModel(None)
                self.model2.select()

                self.proxy2.setSourceModel(self.model2)
                self.tableEditTags2=FreezeTableWidget2(self.proxy2, self.variable2)

                columns_number=self.model2.columnCount()
                for column in range(columns_number):
                    self.tableEditTags2.setItemDelegateForColumn(column, None)
                self.model2.column_range = self.variable_cells2

                if self.variable2 == 'Caudal':
                    for i in range(72,125):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(127,131):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(132,136):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(137,142):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(143,150):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(151,153):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(154,156):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(157,columns_number):
                        self.tableEditTags2.hideColumn(i)

                elif self.variable2 == 'Temperatura':
                    for i in range(80,132):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(134,138):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(139,143):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(144,149):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(150,157):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(158,160):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(161,163):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(164,166):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(167,columns_number):
                        self.tableEditTags2.hideColumn(i)

                elif self.variable2 == 'Nivel':
                    for i in range(66,138):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(140,144):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(145,149):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(150,154):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(155,163):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(165,166):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(167,169):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(170,columns_number):
                        self.tableEditTags2.hideColumn(i)

                elif self.variable2 == 'Otros':
                    for i in range(27,31):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(33,36):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(37,42):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(43,50):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(51,53):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(54,56):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(57,columns_number):
                        self.tableEditTags2.hideColumn(i)

                if self.name != 'Jesús Martínez':
                    if self.variable2 == 'Caudal':
                        self.tableEditTags2.hideColumn(30)
                    elif self.variable2 == 'Temperatura':
                        self.tableEditTags2.hideColumn(35)
                    elif self.variable2 == 'Nivel':
                        self.tableEditTags2.hideColumn(36)
                    elif self.variable2 == 'Otros':
                        self.tableEditTags2.hideColumn(11)

                self.tableEditTags2.setItemDelegate(AlignDelegate(self.tableEditTags2))
                self.tableEditTags2.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
                self.tableEditTags2.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
                self.tableEditTags2.horizontalHeader().setSectionResizeMode(columns_number-1,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
                self.tableEditTags2.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")
                self.tableEditTags2.setObjectName("tableEditTags2")
                self.gridLayout_2.addWidget(self.tableEditTags2, 5, 0, 1, 1)
                self.tableEditTags2.setSortingEnabled(False)
                self.tableEditTags2.horizontalHeader().sectionDoubleClicked.connect(lambda logicalIndex: self.on_view_horizontalHeader_sectionClicked(logicalIndex, self.tableEditTags2, self.model2, self.proxy2))
                self.tableEditTags2.horizontalHeader().customContextMenuRequested.connect(self.showColumnContextMenu)
                self.tableEditTags2.horizontalHeader().setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)

            # Change all column names
                headers_flow = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                                "PO", "Posición", "Subposición", "Tipo", "Tamaño Línea",
                                "Rating", "Facing", "Schedule", "Material Brida", "Tipo Brida",
                                "Material Tubo", "Tamaño Tomas (Nº)", "Material Elemento", "Tipo Placa", "Espesor Placa",
                                "Estándar Placa", "Material Junta", "Material Tornillería", "Con. Válvula", "Material Cuerpo Vlv.",
                                "Nº Saltos", "Pipe Spec.", "Peso Aprox. (kg)", "Long. Aprox. (mm)", "NACE",
                                "Precio (€)", "Notas Oferta", "Cambios Comercial", "Fecha Contractual", "Ø Orif. (mm)",
                                "Ø D/V (mm)", "Cambios Técnicos", "Notas Técnicas", "Nº Doc. EIPSA Cálculo", "Estado Cálculo",
                                "Fecha Estado Cálculo", "Nº Doc. EIPSA Plano", "Estado Plano", "Fecha Estado Plano", "Orden de Compra",
                                "Fecha Orden Compra", "Notas Orden Compra", 'Plano Dimensional', "Plano OF", "Fecha OF",
                                "Notas Equipo", "Colada Placa", "Cert. Placa", "Colada Brida", "Cert. Brida", "Nº Tapones",
                                "Tamaño Tomas", "Nº Tomas", "RTJ Porta Material", "RTJ Espesor", "RTJ Dim",
                                "Ø Ext. Placa (mm)", "Mango", "Tamaño Espárragos", "Cantidad Espárragos", "Tamaño Extractor",
                                "Cantidad Extractor", "Estado Fabricación", "Inspección", "Fecha Inspección", "Envío RN", "Fecha RN", "Cod. Equipo",
                                "Cod. Fab. Equipo", "Trad. Equipo", "Cod. Brida Orif.", "Cod. Fab. Brida Orif.", "Cant. Brida Orif.",
                                "Cod. Brida Línea", "Cod. Fab. Brida Línea", "Cant. Brida Línea", "Cod. Junta", "Cod. Fab. Junta",
                                "Cant. Junta", "Cod. Tornillería", "Cod. Fab. Tornillería", "Cant. Tornillería", "Cod. Tapones",
                                "Cod. Fab. Tapones", "Cant. Tapones", "Cod. Extractor", "Cod. Fab. Extractor", "Cant. Extractor",
                                "Cod. Placa", "Cod. Fab. Placa", "Cant. Placa", "Cod. Niplo", "Cod. Fab. Niplo",
                                "Cant. Niplo", "Cod. Mango", "Cod. Fab. Mango", "Cant. Mango", "Cod. Ch. Ring",
                                "Cod. Fab. Ch. Ring", "Cant. Ch. Ring", "Cod. Tubo", "Cod. Fab. Tubo", "Cant. Tubo",
                                "Cod. Pieza2", "Cod. Fab. Pieza2", "Cant. Pieza2", "Diam. Int", "Pedido Tipo Tag",
                                "Trad. Brida. Orif", "Trad. Brida Línea", "Trad. Junta", "Trad. Tornillería", "Trad. Tapones",
                                "Trad. Extractor", "Trad. Placa", "Trad. Niplo", "Trad. Mango", "Trad. Ch. Ring",
                                "Trad. Tubo", "Trad. Pieza2", "Fecha PMI", "Fecha PH1", "Manómetro PH1", "Presión PH1",
                                "Estado PH1", "Notas PH1", "Fecha PH2", "Manómetro PH2", "Presión PH2",
                                "Estado PH2", "Notas PH2", "Fecha LP", "LP Colada 9PR5", "LP Colada 9D1B",
                                "LP Colada 996PB", "Estado LP", "Notas LP", "Fecha Dureza", "Dureza",
                                "Dureza HB", "Bola", "Carga", "Colada Dureza", "Estado Dureza",
                                "Notas Dureza", "Fecha Verif. Dim.", "Estado Verif. Dim.", "Notas Verif. Dim", "Fecha Verif. OF",
                                "Estado Verif. OF", "Notas Verif. OF", "Fotos",
                                "Posición", "Subposición", "Importe", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas"]

                headers_temp = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                                "PO", "Posición", "Subposición", "Tipo", "Tipo TW",
                                "Tamaño Brida", "Rating Brida", "Facing Brida", "Standard TW", "Material TW",
                                "Long. STD (mm)", "Long. Ins. (mm)", "Ø Raíz (mm)", "Ø Punta (mm)", "Sensor",
                                "Material Sheath/Stem", "Ø Sheath/Stem (mm)", "Insulation", "Temp Inf (ºC)", "Temp Sup ºC",
                                "Material Nipple Ext.", "Long. Nipple Ext. (mm)", "Material Head/Case", "Con. Elec./Diam. Case", "TT/Terminal Insulation",
                                "Material Brida LapJoint", "Material Junta", "Puntal", "Tubo", "NACE",
                                "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual", "Stress",
                                "Geometría", "Long. Cónica (mm)", "Long. Recta (mm)", "Bore // Tip", "Notas Cálculo",
                                "Cambios Técnicos", "Notas Técnicas", "Nº Doc. EIPSA Cálculo", "Estado Cálculo", "Fecha Estado Cálculo",
                                "Nº Doc. EIPSA Plano", "Estado Plano", "Fecha Estado Plano", "Notas Planos", "Orden de Compra",
                                "Fecha Orden Compra", "Notas Orden Compra", "Plano Dimensional", "Plano OF Sensor", "Fecha OF Sensor", 
                                "Notas Sensor", "Estado Fabricación Sensor", "Plano OF TW", "Fecha OF TW", "Notas TW",
                                "Estado Fabricación TW", "Colada Barra", "Cert. Barra", "Colada Brida", "Cert. Brida",
                                "Long. Corte TW (mm)", "Cota A Sensor (mm)", "Cota B Sensor (mm)", "Cota L Sensor (mm)", "Tapón",
                                "Estado Fabricación", "Inspección", "Fecha Inspección", "Envío RN", "Fecha RN", "Cod. Equipo", "Cod. Fab. Equipo",
                                "Trad. Equipo", "Cod. Barra", "Cod. Fab. Barra", "Cant. Barra", "Cod. Tubo",
                                "Cod. Fab. Tubo", "Cant. Tubo", "Cod. Brida", "Cod. Fab. Brida", "Cant. Brida",
                                "Cod. Sensor", "Cod. Fab. Sensor", "Cant. Sensor", "Cod. Cabeza", "Cod. Fab. Cabeza",
                                "Cant. Cabeza", "Cod. BTB", "Cod. Fab. BTB", "Cant. BTB", "Cod. Niplo Ext.",
                                "Cod. Fab. Niplo Ext.", "Cant. Niplo Ext.", "Cod. Muelle", "Cod. Fab. Muelle", "Cant. Muelle",
                                "Cod. Puntal", "Cod. Fab. Puntal", "Cant. Puntal", "Cod. Tapón", "Cod. Fab. Tapón", "Cant. Tapón",
                                "Cod. TW", "Cod. Fab. TW", "Cant. TW", "Cod. Adit.", "Cod. Fab. Adit.",
                                "Cant. Adit", "Pedido Tipo Tag", "Trad. Barra", "Trad. Tubo", "Trad. Brida",
                                "Trad. Sensor", "Trad. Cabeza", "Trad. BTB", "Trad. Niplo Ext.", "Trad. Muelle",
                                "Trad. Puntal", "Trad. Tapón", "Trad. TW", "Trad. Adit.", "Fecha PMI", "Fecha PH1",
                                "Manómetro PH1", "Presión PH1", "Estado PH1", "Notas PH1", "Fecha PH2",
                                "Manómetro PH2", "Presión PH2", "Estado PH2", "Notas PH2", "Fecha LP",
                                "LP Colada 9PR5", "LP Colada 9D1B", "LP Colada 996PB", "Estado LP", "Notas LP",
                                "Fecha Dureza", "Dureza", "Dureza HB", "Bola", "Carga",
                                "Colada Dureza", "Estado Dureza", "Notas Dureza", "Fecha Verif. Dim.", "Estado Verif. Dim.",
                                "Notas Verif. Dim", "Fecha Verif. OF", "Estado Verif. OF.", "Notas Verif. OF", "Fecha Verif. OF Sensor",
                                "Estado Verif. OF Sensor", "Notas Verif. OF Sensor", "Fotos",
                                "Posición", "Subposición", "Importe", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas"]

                headers_level = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                                "PO", "Posición", "Subposición", "Tipo", "Modelo",
                                "Material Cuerpo", "Tipo Conex. Proc.", "Tamaño Conex. Proc.", "Rating Conex. Proc.", "Facing Conex. Proc.",
                                "Tipo Conex.", "Visibilidad (mm)", "Long. C-C (mm)", "Tipo Válv.", "Tipo Conex. Ext.",
                                "Tamaño Conex. Ext.", "Rating Conex. Ext.", "Facing Conex. Ext.", "Junta", "Tornillería",
                                "Iluminador", "Mat. Flotador", "Mat. Cubierta", "Escala", "Banderas",
                                "Cod. IP", "Tipo Brida", "Niplo Hex.", "Niplo Tubo", "Antifrost",
                                "NACE", "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual",
                                "Dim. Flotador", "Junta Bridas", "Cambios Técnicos", "Notas Técnicas", "Nº Doc. EIPSA Plano",
                                "Estado Plano", "Fecha Estado Plano", "Notas Plano", "Orden de Compra", "Fecha Orden Compra",
                                "Notas Orden Compra", "Plano Dimensional", "Plano OF", "Fecha OF", "Notas Equipo",
                                "Colada Cuerpo", "Cert. Cuerpo", "Colada Cuerpo Vlv", "Cert. Cuerpo Vlv", "Colada Brida Vlv", "Cert. Brida Vlv",
                                "Estado Fabricación", "Inspección", "Fecha Inspección", "Envío RN", "Fecha RN", "Cod. Equipo", "Cod. Fab. Equipo",
                                "Trad. Equipo", "Cod. Cuerpo", "Cod. Fab. Cuerpo", "Cant. Cuerpo", "Cod. Cubierta",
                                "Cod. Fab. Cubierta", "Cant. Cubierta", "Cod. Tornillería", "Cod. Fab. Tornillería", "Cant. Tornillería",
                                "Cdo. Niplo Hex.", "Cod. Fab. Niplo Hex.", "Cant. Niplo Hex.", "Cod. Válv.", "Cod. Fab. Válv.",
                                "Cant. Válv.", "Cod. Brida", "Cod. Fab. Brida", "Cant. Brida", "Cod. DV",
                                "Cod. Fab. DV", "Cant. DV", "Cod. Escala", "Cod. Fab. Escala", "Cant. Escala",
                                "Cod. Ilum.", "Cod. Fab. Ilum", "Cant. Ilum", "Cod. Junta Vidrio", "Cod. Fab. Junta Vidrio",
                                "Cant. Junta Vidrio", "Cod. Vidrio", "Cod. Fab. Vidrio", "Cant. Vidrio", "Cod. Flotador",
                                "Cod. Fab. Flotador", "Cant. Flotador", "Cod. Mica", "Cod. Fab. Mica", "Cant. Mica",
                                "Cod. Flags", "Cod. Fab. Flags", "Cant. Flags", "Cod. Junta Brida", "Cod. Fab. Junta Brida",
                                "Cant. Junta Brida", "Cod. Niplo Tubo", "Cod. Fab. Niplo Tubo", "Cant. Niplo Tubo", "Cod. Antifrost",
                                "Cod. Fab. Antifrost", "Cant. Antifrost", "Pedido Tipo Tag", "Trad. Cuerpo", "Trad. Cubierta",
                                "Trad. Tornillería", "Trad. Niplo Hex.", "Trad. Válv", "Trad. Brida", "Trad. DV",
                                "Trad. Escala", "Trad. Ilum.", "Trad. Junta Vidrio", "Trad. Vidrio", "Trad. Flotador",
                                "Trad. Mica", "Trad. Flags", "Trad. Junta Brida", "Trad. Niplo Tubo", "Trad. Antifrost",
                                "Fecha PMI", "Fecha PH1", "Manómetro PH1", "Presión PH1",
                                "Estado PH1", "Notas PH1", "Fecha PH2", "Manómetro PH2", "Presión PH2",
                                "Estado PH2", "Notas PH2", "Fecha LP", "LP Colada 9PR5", "LP Colada 9D1B",
                                "LP Colada 996PB", "Estado LP", "Notas LP", "Fecha Dureza", "Dureza",
                                "Dureza HB", "Bola", "Carga", "Colada Dureza", "Estado Dureza",
                                "Notas Dureza", "Fecha Verif. Dim.", "Estado Verif. Dim.", "Notas Verif. Dim", "Fecha Verif. OF",
                                "Estado Verif. OF", "Notas Verif. OF", "Fotos",
                                "Posición", "Subposición", "Importe", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas"]

                headers_others = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                                "PO", "Posición", "Subposición", "Descripción", "Código Equipo",
                                "NACE", "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual",
                                "Plano Dimensional", "Plano OF", "Fecha OF", "Colada", "Cert. Colada", "Estado Fabricación", "Inspección", "Fecha Inspección", "Envío RN", "Fecha RN",
                                "Fecha PMI", "Fecha PH1", "Manómetro PH1", "Presión PH1",
                                "Estado PH1", "Notas PH1", "Fecha PH2", "Manómetro PH2", "Presión PH2",
                                "Estado PH2", "Notas PH2", "Fecha LP", "LP Colada 9PR5", "LP Colada 9D1B",
                                "LP Colada 996PB", "Estado LP", "Notas LP", "Fecha Dureza", "Dureza",
                                "Dureza HB", "Bola", "Carga", "Colada Dureza", "Estado Dureza",
                                "Notas Dureza", "Fecha Verif. Dim.", "Estado Verif. Dim.", "Notas Verif. Dim", "Fecha Verif. OF",
                                "Estado Verif. OF", "Notas Verif. OF", "Fotos",
                                "Posición", "Subposición", "Importe", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas"]

                if self.variable2 == 'Caudal':
                    self.model2.setAllColumnHeaders(headers_flow)
                elif self.variable2 == 'Temperatura':
                    self.model2.setAllColumnHeaders(headers_temp)
                elif self.variable2 == 'Nivel':
                    self.model2.setAllColumnHeaders(headers_level)
                elif self.variable2 == 'Otros':
                    self.model2.setAllColumnHeaders(headers_others)

            # Getting the unique values for each column of the model
                for column in range(self.model2.columnCount()):
                    list_valuesUnique = []
                    if column not in self.checkbox_states2:
                        self.checkbox_states2[column] = {}
                        self.checkbox_states2[column]['Seleccionar todo'] = True
                        for row in range(self.model2.rowCount()):
                            value = self.model2.record(row).value(column)
                            if value not in list_valuesUnique:
                                if isinstance(value, QtCore.QDate):
                                    value=value.toString("dd/MM/yyyy")
                                list_valuesUnique.append(str(value))
                                self.checkbox_states2[column][value] = True
                        self.dict_valuesuniques2[column] = list_valuesUnique

                self.tableEditTags2.sortByColumn(1, QtCore.Qt.SortOrder.AscendingOrder)

                self.model2.dataChanged.connect(self.saveChanges)
                self.selection_model = self.tableEditTags2.selectionModel()
                self.selection_model.selectionChanged.connect(lambda: self.countSelectedCells(self.model2))

            else:
                self.tableEditTags2.hide()

        else:
            self.model.dataChanged.connect(self.saveChanges)

            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("No hay TAGS introducidos para este pedido")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg.exec()
            del dlg, new_icon

# Function when header is clicked
    def on_view_horizontalHeader_sectionClicked(self, logicalIndex, table, model, proxy):
        """
        Displays a menu when a column header is clicked. The menu includes options for sorting, filtering, and managing column visibility.
        
        Args:
            logicalIndex (int): Index of the clicked column.
            table (QtWidgets.QTableView): The table view displaying the data.
            model (QtGui.QStandardItemModel): The model associated with the table.
            proxy (QtCore.QSortFilterProxyModel): The proxy model used for filtering and sorting.
        """
        if isinstance(model, EditableTableModel2):
            self.logicalIndex = logicalIndex
            self.menuValues = QtWidgets.QMenu(self)
            self.signalMapper = QtCore.QSignalMapper(table)

            valuesUnique_view = {table.model().index(row, self.logicalIndex).data(Qt.ItemDataRole.DisplayRole) for row in range(table.model().rowCount())}
            valuesUnique_view = [value.toString("dd/MM/yyyy") if isinstance(value, QtCore.QDate) else value for value in valuesUnique_view]

            actionSortAscending = QtGui.QAction("Ordenar Ascendente", table)
            actionSortAscending.triggered.connect(lambda: self.on_actionSortAscending_triggered(table))
            self.menuValues.addAction(actionSortAscending)
            actionSortDescending = QtGui.QAction("Ordenar Descendente", table)
            actionSortDescending.triggered.connect(lambda: self.on_actionSortDescending_triggered(table))
            self.menuValues.addAction(actionSortDescending)
            self.menuValues.addSeparator()

            actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro", table)
            actionDeleteFilterColumn.triggered.connect(lambda: self.on_actionDeleteFilterColumn_triggered(table, model, proxy))
            self.menuValues.addAction(actionDeleteFilterColumn)
            self.menuValues.addSeparator()

            actionTextFilter = QtGui.QAction("Buscar...", table)
            actionTextFilter.triggered.connect(lambda: self.on_actionTextFilter_triggered(model, proxy))
            self.menuValues.addAction(actionTextFilter)
            self.menuValues.addSeparator()

            scroll_menu = QtWidgets.QScrollArea()
            scroll_menu.setStyleSheet("background-color: rgb(255, 255, 255)")
            scroll_menu.setWidgetResizable(True)
            scroll_widget = QtWidgets.QWidget(scroll_menu)
            scroll_menu.setWidget(scroll_widget)
            scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

            checkbox_all_widget = QtWidgets.QCheckBox('Seleccionar todo')

            if not self.checkbox_states2[self.logicalIndex]['Seleccionar todo'] == True:
                checkbox_all_widget.setChecked(False)
            else:
                checkbox_all_widget.setChecked(True)
            
            checkbox_all_widget.toggled.connect(lambda checked, name='Seleccionar todo': self.on_select_all_toggled(checked, name, model))

            scroll_layout.addWidget(checkbox_all_widget)
            self.action_checkbox_map2['Seleccionar todo'] = checkbox_all_widget

            if len(self.dict_ordersort2) != 0 and self.logicalIndex in self.dict_ordersort2:
                list_uniquevalues = sorted(list(set(self.dict_valuesuniques2[self.logicalIndex])))
            else:
                list_uniquevalues = sorted(list(set(valuesUnique_view)))

            for actionName in list_uniquevalues:
                checkbox_widget = QtWidgets.QCheckBox(str(actionName))

                if self.logicalIndex not in self.checkbox_filters2:
                    checkbox_widget.setChecked(True)
                elif actionName not in self.checkbox_filters2[self.logicalIndex]:
                    checkbox_widget.setChecked(False)
                else:
                    checkbox_widget.setChecked(True)

                checkbox_widget.toggled.connect(lambda checked, name=actionName: self.on_checkbox_toggled(checked, name, model))

                scroll_layout.addWidget(checkbox_widget)
                self.action_checkbox_map2[actionName] = checkbox_widget

            action_scroll_menu = QtWidgets.QWidgetAction(self.menuValues)
            action_scroll_menu.setDefaultWidget(scroll_menu)
            self.menuValues.addAction(action_scroll_menu)

            self.menuValues.addSeparator()

            accept_button = QtGui.QAction("ACEPTAR", table)
            accept_button.triggered.connect(lambda: self.menu_acceptbutton_triggered(proxy))

            cancel_button = QtGui.QAction("CANCELAR", table)
            cancel_button.triggered.connect(self.menu_cancelbutton_triggered)

            self.menuValues.addAction(accept_button)
            self.menuValues.addAction(cancel_button)

            self.menuValues.setStyleSheet("QMenu { color: black; }"
                                            "QMenu { background-color: rgb(255, 255, 255); }"
                                            "QMenu::item:selected { background-color: #33bdef; }"
                                            "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

            headerPos = table.mapToGlobal(table.horizontalHeader().pos())        

            posY = headerPos.y() + table.horizontalHeader().height()
            scrollX = table.horizontalScrollBar().value()
            xInView = table.horizontalHeader().sectionViewportPosition(logicalIndex)
            posX = headerPos.x() + xInView - scrollX

            self.menuValues.exec(QtCore.QPoint(posX, posY))
        
        else:
            self.logicalIndex = logicalIndex
            self.menuValues = QtWidgets.QMenu(self)
            self.signalMapper = QtCore.QSignalMapper(table)

            valuesUnique_view = {table.model().index(row, self.logicalIndex).data(Qt.ItemDataRole.DisplayRole) for row in range(table.model().rowCount())}
            valuesUnique_view = [value.toString("dd/MM/yyyy") if isinstance(value, QtCore.QDate) else value for value in valuesUnique_view]

            actionSortAscending = QtGui.QAction("Ordenar Ascendente", table)
            actionSortAscending.triggered.connect(lambda: self.on_actionSortAscending_triggered(table))
            self.menuValues.addAction(actionSortAscending)
            actionSortDescending = QtGui.QAction("Ordenar Descendente", table)
            actionSortDescending.triggered.connect(lambda: self.on_actionSortDescending_triggered(table))
            self.menuValues.addAction(actionSortDescending)
            self.menuValues.addSeparator()

            actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro", table)
            actionDeleteFilterColumn.triggered.connect(lambda: self.on_actionDeleteFilterColumn_triggered(table, model, proxy))
            self.menuValues.addAction(actionDeleteFilterColumn)
            self.menuValues.addSeparator()

            actionTextFilter = QtGui.QAction("Buscar...", table)
            actionTextFilter.triggered.connect(lambda: self.on_actionTextFilter_triggered(model, proxy))
            self.menuValues.addAction(actionTextFilter)
            self.menuValues.addSeparator()

            scroll_menu = QtWidgets.QScrollArea()
            scroll_menu.setStyleSheet("background-color: rgb(255, 255, 255)")
            scroll_menu.setWidgetResizable(True)
            scroll_widget = QtWidgets.QWidget(scroll_menu)
            scroll_menu.setWidget(scroll_widget)
            scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

            checkbox_all_widget = QtWidgets.QCheckBox('Seleccionar todo')

            if not self.checkbox_states[self.logicalIndex]['Seleccionar todo'] == True:
                checkbox_all_widget.setChecked(False)
            else:
                checkbox_all_widget.setChecked(True)
            
            checkbox_all_widget.toggled.connect(lambda checked, name='Seleccionar todo': self.on_select_all_toggled(checked, name, model))

            scroll_layout.addWidget(checkbox_all_widget)
            self.action_checkbox_map['Seleccionar todo'] = checkbox_all_widget

            if len(self.dict_ordersort) != 0 and self.logicalIndex in self.dict_ordersort:
                list_uniquevalues = sorted(list(set(self.dict_valuesuniques[self.logicalIndex])))
            else:
                list_uniquevalues = sorted(list(set(valuesUnique_view)))

            for actionName in list_uniquevalues:
                checkbox_widget = QtWidgets.QCheckBox(str(actionName))

                if self.logicalIndex not in self.checkbox_filters:
                    checkbox_widget.setChecked(True)
                elif actionName not in self.checkbox_filters[self.logicalIndex]:
                    checkbox_widget.setChecked(False)
                else:
                    checkbox_widget.setChecked(True)

                checkbox_widget.toggled.connect(lambda checked, name=actionName: self.on_checkbox_toggled(checked, name, model))

                scroll_layout.addWidget(checkbox_widget)
                self.action_checkbox_map[actionName] = checkbox_widget

            action_scroll_menu = QtWidgets.QWidgetAction(self.menuValues)
            action_scroll_menu.setDefaultWidget(scroll_menu)
            self.menuValues.addAction(action_scroll_menu)

            self.menuValues.addSeparator()

            accept_button = QtGui.QAction("ACEPTAR", table)
            accept_button.triggered.connect(lambda: self.menu_acceptbutton_triggered(proxy))

            cancel_button = QtGui.QAction("CANCELAR", table)
            cancel_button.triggered.connect(self.menu_cancelbutton_triggered)

            self.menuValues.addAction(accept_button)
            self.menuValues.addAction(cancel_button)

            self.menuValues.setStyleSheet("QMenu { color: black; }"
                                            "QMenu { background-color: rgb(255, 255, 255); }"
                                            "QMenu::item:selected { background-color: #33bdef; }"
                                            "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

            headerPos = table.mapToGlobal(table.horizontalHeader().pos())        

            posY = headerPos.y() + table.horizontalHeader().height()
            scrollX = table.horizontalScrollBar().value()
            xInView = table.horizontalHeader().sectionViewportPosition(logicalIndex)
            posX = headerPos.x() + xInView - scrollX

            self.menuValues.exec(QtCore.QPoint(posX, posY))

# Function when cancel button of menu is clicked
    def menu_cancelbutton_triggered(self):
        """
        Hides the menu when the cancel button is clicked.
        """
        self.menuValues.hide()

# Function when accept button of menu is clicked
    def menu_acceptbutton_triggered(self, proxy):
        """
        Applies the selected filters and updates the table model with the new filters.
        """
        if isinstance(proxy, CustomProxyModel2):
            for column, filters in self.checkbox_filters2.items():
                if filters:
                    proxy.setFilter(filters, column, exact_match=True)
                else:
                    proxy.setFilter(None, column)
        else:
            for column, filters in self.checkbox_filters.items():
                if filters:
                    proxy.setFilter(filters, column, exact_match=True)
                else:
                    proxy.setFilter(None, column)

        # self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        # self.tableEditTags.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        # self.tableEditTags.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function when select all checkbox is clicked
    # def on_select_all_toggled(self, checked, action_name, model):
    #     """
    #     Toggles the state of all checkboxes in the filter menu when the 'Select All' checkbox is toggled.
        
    #     Args:
    #         checked (bool): The checked state of the 'Select All' checkbox.
    #         action_name (str): The name of the action (usually 'Select All').
    #     """
    #     filterColumn = self.logicalIndex
    #     imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
    #     icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

    #     if checked:
    #         if isinstance(model, EditableTableModel2):
    #             for checkbox_name, checkbox_widget in self.action_checkbox_map2.items():
    #                 checkbox_widget.setChecked(checked)
    #                 self.checkbox_states2[self.logicalIndex][checkbox_name] = checked
    #         else:
    #             for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
    #                 checkbox_widget.setChecked(checked)
    #                 self.checkbox_states[self.logicalIndex][checkbox_widget.text()] = checked

    #         if isinstance(model, EditableTableModel2):
                
    #             if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map2.values()):
    #                 model.setIconColumnHeader(filterColumn, icono)
    #             else:
    #                 model.setIconColumnHeader(filterColumn, '')
    #         else:
    #             if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
    #                 model.setIconColumnHeader(filterColumn, icono)
    #             else:
    #                 model.setIconColumnHeader(filterColumn, '')

    #     else:
    #         if isinstance(model, EditableTableModel2):
    #             for checkbox_name, checkbox_widget in self.action_checkbox_map2.items():
    #                 checkbox_widget.setChecked(checked)
    #                 self.checkbox_states2[self.logicalIndex][checkbox_widget.text()] = checked
    #         else:
    #             for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
    #                 checkbox_widget.setChecked(checked)
    #                 self.checkbox_states[self.logicalIndex][checkbox_widget.text()] = checked

    def on_select_all_toggled(self, checked, action_name, model):
        """
        Toggles the state of all checkboxes in the filter menu when the 'Select All' checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the 'Select All' checkbox.
            action_name (str): The name of the action (usually 'Select All').
            model (QAbstractItemModel): The model associated with the table view.
        """
        filterColumn = self.logicalIndex

    # Load icon
        if not hasattr(self, 'icono_filter_active'):
            imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
            self.icono_filter_active = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
        
    # Select map and state related to model
        checkbox_map = self.action_checkbox_map2 if isinstance(model, EditableTableModel2) else self.action_checkbox_map
        checkbox_states = self.checkbox_states2 if isinstance(model, EditableTableModel2) else self.checkbox_states

    # Change state of checkboxes if necessary
        for checkbox_name, checkbox_widget in checkbox_map.items():
            if checkbox_widget.isChecked() != checked:
                checkbox_widget.setChecked(checked)
                checkbox_states[self.logicalIndex][checkbox_widget.text()] = checked

    # Adjust icon of header
        all_checked = all(checkbox_widget.isChecked() for checkbox_widget in checkbox_map.values())
        model.setIconColumnHeader(filterColumn, self.icono_filter_active if all_checked else '')

# Function when checkbox of header menu is clicked
    def on_checkbox_toggled(self, checked, action_name, model):
        """
        Updates the filter state when an individual checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the checkbox.
            action_name (str): The name of the checkbox.
        """
        filterColumn = self.logicalIndex
        imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            if isinstance(model, EditableTableModel2):
                if filterColumn not in self.checkbox_filters2:
                    self.checkbox_filters2[filterColumn] = [action_name]
                else:
                    if action_name not in self.checkbox_filters2[filterColumn]:
                        self.checkbox_filters2[filterColumn].append(action_name)
            else:
                if filterColumn not in self.checkbox_filters:
                    self.checkbox_filters[filterColumn] = [action_name]
                else:
                    if action_name not in self.checkbox_filters[filterColumn]:
                        self.checkbox_filters[filterColumn].append(action_name)
        else:
            if isinstance(model, EditableTableModel2):
                if filterColumn in self.checkbox_filters2 and action_name in self.checkbox_filters2[filterColumn]:
                    self.checkbox_filters2[filterColumn].remove(action_name)
            else:
                if filterColumn in self.checkbox_filters and action_name in self.checkbox_filters[filterColumn]:
                    self.checkbox_filters[filterColumn].remove(action_name)

        if isinstance(model, EditableTableModel2):
            if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map2.values()):
                model.setIconColumnHeader(filterColumn, '')
            else:
                model.setIconColumnHeader(filterColumn, icono)
        else:
            if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
                model.setIconColumnHeader(filterColumn, '')
            else:
                model.setIconColumnHeader(filterColumn, icono)

# Function to delete individual column filter
    def on_actionDeleteFilterColumn_triggered(self, table, model, proxy):
        """
        Removes the filter from the selected column and updates the table model.
        
        Args:
            table (QtWidgets.QTableView): The table view displaying the data.
            model (QtGui.QStandardItemModel): The model associated with the table.
            proxy (QtCore.QSortFilterProxyModel): The proxy model used for filtering and sorting.
        """
        if isinstance(model, EditableTableModel2):
            filterColumn = self.logicalIndex
            if filterColumn in proxy.filters:
                del proxy.filters[filterColumn]
            model.setIconColumnHeader(filterColumn, "")
            proxy.invalidateFilter()

            if filterColumn in self.checkbox_filters2:
                del self.checkbox_filters2[filterColumn]

            self.checkbox_states2[self.logicalIndex].clear()
            self.checkbox_states2[self.logicalIndex]["Seleccionar todo"] = True
            for row in range(table.model().rowCount()):
                value = model.record(row).value(filterColumn)
                if isinstance(value, QtCore.QDate):
                    value = value.toString("dd/MM/yyyy")
                self.checkbox_states2[self.logicalIndex][str(value)] = True

        else:
            filterColumn = self.logicalIndex
            if filterColumn in proxy.filters:
                del proxy.filters[filterColumn]
            model.setIconColumnHeader(filterColumn, "")
            proxy.invalidateFilter()

            if filterColumn in self.checkbox_filters:
                del self.checkbox_filters[filterColumn]

            self.checkbox_states[self.logicalIndex].clear()
            self.checkbox_states[self.logicalIndex]["Seleccionar todo"] = True
            for row in range(table.model().rowCount()):
                value = model.record(row).value(filterColumn)
                if isinstance(value, QtCore.QDate):
                    value = value.toString("dd/MM/yyyy")
                self.checkbox_states[self.logicalIndex][str(value)] = True

        table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        table.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        table.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

        self.selection_model = table.selectionModel()
        self.selection_model.selectionChanged.connect(self.countSelectedCells)

        if isinstance(model,EditableTableModel2):
            self.label_SumItems2.setText("")
            self.label_SumValue2.setText("")
            self.label_CountItems2.setText("")
            self.label_CountValue2.setText("")
        else:
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

# Function to order column ascending
    def on_actionSortAscending_triggered(self, table):
        """
        Sorts the selected column in ascending order.
        
        Args:
            table (QtWidgets.QTableView): The table view displaying the data.
        """
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.AscendingOrder
        table.sortByColumn(sortColumn, sortOrder)

# Function to order column descending
    def on_actionSortDescending_triggered(self, table):
        """
        Sorts the selected column in descending order.
        
        Args:
            table (QtWidgets.QTableView): The table view displaying the data.
        """
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.DescendingOrder
        table.sortByColumn(sortColumn, sortOrder)

# Function when text is searched
    def on_actionTextFilter_triggered(self, model, proxy):
        """
        Opens a dialog to enter a text filter and applies it to the selected column.
        
        Args:
            model (QtGui.QStandardItemModel): The model associated with the table.
            proxy (QtCore.QSortFilterProxyModel): The proxy model used for filtering and sorting.
        """
        filterColumn = self.logicalIndex
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle("Buscar")
        clickedButton = dlg.exec()

        if clickedButton == 1:
            stringAction = dlg.textValue()
            if re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', stringAction):
                stringAction=QtCore.QDate.fromString(stringAction,"dd/MM/yyyy")
                stringAction=stringAction.toString("yyyy-MM-dd")

            filterString = QtCore.QRegularExpression(stringAction, QtCore.QRegularExpression.PatternOption(0))
            # del self.proxy.filters[filterColumn]
            proxy.setFilter([stringAction], filterColumn, None)

            imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
            icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
            model.setIconColumnHeader(filterColumn, icono)

# Function to hide column when action clicked
    def hide_column(self):
        """
        Hides the selected column in the table view.
        """
        filterColumn = self.logicalIndex 
        self.tableEditTags.setColumnHidden(filterColumn, True)
        self.hiddencolumns.append(filterColumn)

# Function to show all hidden columns
    def show_columns(self):
        """
        Makes all previously hidden columns visible in the table and clears the list of hidden columns.
        """
        for column in self.hiddencolumns:
            self.tableEditTags.setColumnHidden(column, False)
        self.hiddencolumns.clear()

# Function to export data to excel
    def exporttoexcel(self):
        """
        Exports the visible data from the table to an Excel file. If no data is loaded, displays a warning message.

        Shows a message box if there is no data to export and allows the user to save the data to an Excel file.
        """
        if self.proxy.rowCount() == 0:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("Exportar")
            dlg.setText("No hay datos cargados")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg.exec()
            del dlg,new_icon
        else:
            final_data = []

            visible_columns = [col for col in range(self.model.columnCount()) if not self.tableEditTags.isColumnHidden(col)]
            visible_headers = self.model.getColumnHeaders(visible_columns)
            for row in range(self.proxy.rowCount()):
                tag_data = []
                for column in visible_columns:
                    value = self.proxy.data(self.proxy.index(row, column))
                    if isinstance(value, QDate):
                        value = value.toString("dd/MM/yyyy")
                    tag_data.append(value)
                final_data.append(tag_data)

            final_data.insert(0, visible_headers)
            df = pd.DataFrame(final_data)
            df.columns = df.iloc[0]
            df = df[1:]

            output_path = asksaveasfilename(defaultextension=".xlsx", filetypes=[("Archivos de Excel", "*.xlsx")], title="Guardar archivo de Excel")
            if output_path:
                df.to_excel(output_path, index=False, header=True)

# Function to enable copy and paste cells
    def keyPressEvent(self, event):
        """
        Handles custom key events for cell operations in the table.

        Args:
            event (QtGui.QKeyEvent): The key event to handle.
        """
        if event.matches(QKeySequence.StandardKey.Copy):
            selected_indexes = self.tableEditTags.selectionModel().selectedIndexes()
            if selected_indexes:
                clipboard = QApplication.clipboard()
                text = self.get_selected_text(selected_indexes)
                if isinstance(text, QtCore.QDate):
                    text=text.toString("dd/MM/yyyy")
                clipboard.setText(text)

        elif event.matches(QKeySequence.StandardKey.Paste):
            selected_indexes = self.tableEditTags.selectionModel().selectedIndexes()
            if selected_indexes:
                clipboard = QApplication.clipboard()
                text = clipboard.text()
                for index in selected_indexes:
                    current_row = index.row()
                    current_column = index.column()
                    first_column_value = self.proxy.data(self.proxy.index(current_row, 0))
                    target_row = None
                    for row in range(self.model.rowCount()):
                        if self.model.data(self.model.index(row, 0)) == first_column_value:
                            target_row = row
                            break
                    if target_row is not None:
                        target_index = self.model.index(target_row, current_column)
                        self.model.setData(target_index, text, Qt.ItemDataRole.EditRole)  # Pegar el valor en todas las celdas seleccionadas
                self.model.submitAll()

        super().keyPressEvent(event)

# Function to get the text of the selected cells
    def get_selected_text(self, indexes):
        """
        Retrieves the text from the selected cells and returns it as a plain text string.

        Args:
            indexes (list of QModelIndex): A list of QModelIndex objects representing the selected cells.
        
        Returns:
            str: A string containing the text from the selected cells.
        """
        if len(indexes) == 1:  # Si solo hay una celda seleccionada
            index = indexes[0]
            cell_data = index.data(Qt.ItemDataRole.DisplayRole)
            return cell_data
        else:
            rows = set()
            cols = set()
            for index in indexes:
                rows.add(index.row())
                cols.add(index.column())

            text_doc = QTextDocument()
            cursor = QTextCursor(text_doc)

            for row in sorted(rows):
                for col in sorted(cols):
                    index = self.model.index(row, col)  # Obtain corresponding index
                    cell_data = index.data(Qt.ItemDataRole.DisplayRole)
                    cursor.insertText(str(cell_data))
                    cursor.insertText('\t')  # Tab separating columns
                cursor.insertText('\n')  # Line break at end of row

            return text_doc.toPlainText()

# Function to count selected cells and sum its values
    def countSelectedCells(self):
        """
        Counts the number of selected cells and sums their values. Updates the UI labels with the count and sum.
        """
        if len(self.tableEditTags.selectedIndexes()) > 1:
            locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

            sum_value = sum([self.euro_string_to_float(str(ix.data())) if re.match(r'^[\d.,]+\sÇ$', str(ix.data())) else float(str(ix.data()).replace(',', '.')) if str(ix.data()).replace(',', '.').replace('.', '', 1).isdigit() else 0 for ix in self.tableEditTags.selectedIndexes()])

            count_value = len([ix for ix in self.tableEditTags.selectedIndexes() if ix.data() != ""])
            if sum_value > 0:
                self.label_SumItems.setText("Suma:")
                self.label_SumValue.setText(locale.format_string("%.2f", sum_value, grouping=True))
            if count_value > 0:
                self.label_CountItems.setText("Recuento:")
                self.label_CountValue.setText(str(count_value))
        else:
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

# Function to format money string values
    def euro_string_to_float(self, euro_str):
        """
        Converts a string representing an amount in euros to a float.

        Args:
            euro_str (str): A string representing the amount in euros (e.g., "1.234,56 €").
        
        Returns:
            float: The numeric value of the amount as a float.
        """
        match = re.match(r'^([\d.,]+)\s€$', euro_str)
        if match:
            number_str = match.group(1)
            number_str = number_str.replace('.', '').replace(',', '.')
            return float(number_str)
        else:
            return 0.0

# Function for creating context menu
    def createContextMenu(self):
        """
        Creates a context menu with options for hiding selected columns.
        """
        self.context_menu = QtWidgets.QMenu(self)
        hide_columns_action = self.context_menu.addAction("Ocultar Columnas")
        hide_columns_action.triggered.connect(self.hideSelectedColumns)

# Function to show context menu when right-click
    def showColumnContextMenu(self, pos):
        """
        Displays the context menu at the specified position for column operations.

        Args:
            pos (QPoint): The position at which to display the context menu.
        """
        header = self.tableEditTags.horizontalHeader()
        column = header.logicalIndexAt(pos)
        self.context_menu.exec(self.tableEditTags.mapToGlobal(pos))

# Function to hide selected columns
    def hideSelectedColumns(self):
        """
        Hides the currently selected columns in the table and updates the list of hidden columns.
        """
        selected_columns = set()
        header = self.tableEditTags.horizontalHeader()
        for index in header.selectionModel().selectedColumns():
            selected_columns.add(index.column())

        for column in selected_columns:
            self.tableEditTags.setColumnHidden(column, True)
            self.hiddencolumns.append(column)

        self.context_menu.close()

# Function to export data on an excel template to print stickers
    def stickerexcel(self):
        """
        Exports data related to 'Caudal' to an Excel file for printing stickers. 

        Raises:
            Exception: If there is an error during the Excel file creation or saving process, the function handles it internally.
        """
        if self.variable == 'Caudal':
            id_list=[]
            data = []

            for row in range(self.proxy.rowCount()):
                first_column_value = self.proxy.data(self.proxy.index(row, 0))
                id_list.append(first_column_value)

            if len(id_list) != 0:
                for element in id_list:
                    for row in range(self.model.rowCount()):
                        if self.model.data(self.model.index(row, 0)) == element:
                            target_row = row
                            break
                    if target_row is not None:
                        tag = self.model.data(self.model.index(target_row, 1))
                        size = self.model.data(self.model.index(target_row, 9)) + " " +self.model.data(self.model.index(target_row, 10)) + " " + self.model.data(self.model.index(target_row, 11))
                        diameter = "ø = " + self.model.data(self.model.index(target_row, 34)) + " mm"
                        eipsa = 'EIPSA. Made in Spain'

                        data.append({
                            'tag': tag,
                            'size': size,
                            'diameter': diameter,
                            'eipsa': eipsa
                        })

                df = pd.concat([pd.DataFrame([item]) for item in data], ignore_index=True)
                groups = [df.iloc[i:i + 4] for i in range(0, len(df), 4)]

                self.wb = load_workbook(
                    r"\\nas01\DATOS\Comunes\EIPSA-ERP\Plantillas Exportación\PLANTILLA PEGATINAS.xlsx"
                )
                sheet_name = "Hoja1"  # Selecting template sheet
                ws = self.wb[sheet_name]

                start_row = 1
                for idx, group in enumerate(groups):
                    group_transposed = group.T
                    for r_idx, row in enumerate(group_transposed.iterrows(), start=start_row + idx * 4):
                        for c_idx, value in enumerate(row[1], 1):
                            ws.cell(row=r_idx, column=c_idx, value=value)


                output_path = asksaveasfilename(
                    defaultextension=".xlsx",
                    filetypes=[("Archivos de Excel", "*.xlsx")],
                    title="Guardar archivo de Excel",
                )
                if output_path:
                    self.wb.save(output_path)


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    config_obj = configparser.ConfigParser()
    config_obj.read(r"C:\Program Files\ERP EIPSA\database.ini")
    dbparam = config_obj["postgresql"]
    # set your parameters for the database connection URI using the keys from the configfile.ini
    user_database = dbparam["user"]
    password_database = dbparam["password"]

    db = Create_DBconnection(user_database, password_database)
    if not db:
        sys.exit()

    EditTagsWorkshop_Window = Ui_EditTags_Workshop_Window('Julio Zofio',db)
    EditTagsWorkshop_Window.show()
    sys.exit(app.exec())