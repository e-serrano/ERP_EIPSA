# Form implementation generated from reading ui file 'EditTags_Commercial_Window.ui'
#
# Created by: PyQt6 UI code generator 6.4.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6 import QtSql
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import Qt, QDate
from PyQt6.QtGui import QKeySequence, QTextDocument, QTextCursor
from Create_FabOrder_Window import Ui_CreateFabOrder_Window
from Create_MatOrder import flow_matorder, temp_matorder, level_matorder
from Create_Inspection import inspection
from Database_Connection import createConnection
from config import config
import psycopg2
import re
import configparser
import locale
from datetime import *
import os
import pandas as pd
from tkinter.filedialog import asksaveasfilename


basedir = r"\\nas01\DATOS\Comunes\EIPSA-ERP"


def imagen_to_base64(imagen):
    buffer = QtCore.QBuffer()
    buffer.open(QtCore.QIODevice.OpenModeFlag.WriteOnly)
    imagen.save(buffer, ".png")
    base64_data = buffer.data().toBase64().data().decode()
    return base64_data


class CheckboxWidget(QtWidgets.QWidget):
    def __init__(self, text):
        super().__init__()
        layout = QtWidgets.QHBoxLayout(self)
        self.checkbox = QtWidgets.QCheckBox(text)
        layout.addWidget(self.checkbox)


class AlignDelegate(QtWidgets.QStyledItemDelegate):
    def initStyleOption(self, option, index):
        super(AlignDelegate, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter


class EditableComboBoxDelegate(QtWidgets.QStyledItemDelegate):
    def __init__(self, parent=None, options=None):
        super().__init__(parent)
        self.options = options

    def createEditor(self, parent, option, index):
        editor = QtWidgets.QComboBox(parent)
        editor.setEditable(True)
        return editor

    def setEditorData(self, editor, index):
        text = index.data(Qt.ItemDataRole.DisplayRole)
        editor.addItems(self.options)
        editor.setEditText(text)

    def setModelData(self, editor, model, index):
        model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)


class CustomProxyModel(QtCore.QSortFilterProxyModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._filters = dict()
        self.header_names = {}

    @property
    def filters(self):
        return self._filters

    def setFilter(self, expresion, column, action_name=None):
        if expresion or expresion == '':
            if column in self.filters:
                if action_name or action_name == '':
                    self.filters[column].remove(expresion)
                else:
                    self.filters[column].append(expresion)
            else:
                self.filters[column] = [expresion]
        elif column in self.filters:
            if action_name or action_name == '':
                self.filters[column].remove(expresion)
                if not self.filters[column]:
                    del self.filters[column]
            else:
                del self.filters[column]
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        for column, expresions in self.filters.items():
            text = self.sourceModel().index(source_row, column, source_parent).data()

            if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
                text = text.toString("yyyy-MM-dd")

            for expresion in expresions[0]:
                if expresion == '':  # If expression is empty, match empty cells
                    if text == '':
                        break

                elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', expresion):
                    expresion = QtCore.QDate.fromString(expresion, "dd/MM/yyyy")
                    expresion = expresion.toString("yyyy-MM-dd")
                    regex = QtCore.QRegularExpression(f".*{re.escape(expresion)}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        break

                else:
                    regex = QtCore.QRegularExpression(f".*{re.escape(expresion)}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        break
            else:
                return False
        return True


class EditableTableModel(QtSql.QSqlTableModel):
    updateFailed = QtCore.pyqtSignal(str)

    def __init__(self, parent=None, column_range=None):
        super().__init__(parent)
        self.column_range = column_range

    def setAllColumnHeaders(self, headers):
        for column, header in enumerate(headers):
            self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIndividualColumnHeader(self, column, header):
        self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIconColumnHeader(self, column, icon):
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return super().headerData(section, orientation, role)
        return super().headerData(section, orientation, role)

    def flags(self, index):
        flags = super().flags(index)
        if index.column() in range (0,8) or index.column() in self.column_range:
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        else:
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable

    def getColumnHeaders(self, visible_columns):
        column_headers = [self.headerData(col, Qt.Orientation.Horizontal) for col in visible_columns]
        return column_headers


class EditableComboBoxDelegate(QtWidgets.QStyledItemDelegate):
    def __init__(self, parent=None, options=None):
        super().__init__(parent)
        self.options = options

    def createEditor(self, parent, option, index):
        editor = QtWidgets.QComboBox(parent)
        editor.setEditable(True)
        return editor

    def setEditorData(self, editor, index):
        text = index.data(Qt.ItemDataRole.DisplayRole)
        editor.addItems(self.options)
        editor.setEditText(text)

    def setModelData(self, editor, model, index):
        model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)


class Ui_EditTags_Technical_Window(QtWidgets.QMainWindow):
    def __init__(self,name,db):
        super().__init__()
        self.model = EditableTableModel()
        self.proxy = CustomProxyModel()
        self.db = db
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []
        self.action_checkbox_map = {}
        self.checkbox_filters = {}
        self.setupUi(self)
        self.model.dataChanged.connect(self.saveChanges)
        self.name = name
        self.variable = ''

    def closeEvent(self, event):
    # Closing database connection
        if self.model:
            self.model.clear()
        self.closeConnection()

    def closeConnection(self):
    # Closing database connection
        self.tableEditTags.setModel(None)
        del self.model
        if self.db:
            self.db.close()
            del self.db
            if QtSql.QSqlDatabase.contains("qt_sql_default_connection"):
                QtSql.QSqlDatabase.removeDatabase("qt_sql_default_connection")

    def setupUi(self, EditTags_Window):
        EditTags_Window.setObjectName("EditTags_Window")
        EditTags_Window.resize(790, 595)
        EditTags_Window.setMinimumSize(QtCore.QSize(790, 595))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        EditTags_Window.setWindowIcon(icon)
        EditTags_Window.setStyleSheet(
".QFrame {\n"
"    border: 2px solid black;\n"
"}")
        self.centralwidget = QtWidgets.QWidget(parent=EditTags_Window)
        self.centralwidget.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_2.setVerticalSpacing(10)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.hcab=QtWidgets.QHBoxLayout()
        self.hcab.setObjectName("hcab")
        self.toolDeleteFilter = QtWidgets.QToolButton(self.frame)
        self.toolDeleteFilter.setObjectName("Save_Button")
        self.hcab.addWidget(self.toolDeleteFilter)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Delete.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolDeleteFilter.setIcon(icon)
        self.toolDeleteFilter.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer1=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer1)
        self.toolShow = QtWidgets.QToolButton(self.frame)
        self.toolShow.setObjectName("Show_Button")
        self.toolShow.setToolTip("Mostrar columnas")
        self.hcab.addWidget(self.toolShow)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Eye.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolShow.setIcon(icon)
        self.toolShow.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer2=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer2)
        self.toolMatOrder = QtWidgets.QToolButton(self.frame)
        self.toolMatOrder.setObjectName("MatOrder_Button")
        self.toolMatOrder.setToolTip("Pedido Materiales")
        self.hcab.addWidget(self.toolMatOrder)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Purchase_Order.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolMatOrder.setIcon(icon)
        self.toolMatOrder.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer3=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer3)
        self.toolFabOrder = QtWidgets.QToolButton(self.frame)
        self.toolFabOrder.setObjectName("FabOrder_Button")
        self.toolFabOrder.setToolTip("Orden Fabricación")
        self.hcab.addWidget(self.toolFabOrder)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Fab_Order.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolFabOrder.setIcon(icon)
        self.toolFabOrder.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer4=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer4)
        self.toolInspection = QtWidgets.QToolButton(self.frame)
        self.toolInspection.setObjectName("Inspection_Button")
        self.toolInspection.setToolTip("Inspeccion")
        self.hcab.addWidget(self.toolInspection)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Inspection.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolInspection.setIcon(icon)
        self.toolInspection.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer5=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer5)
        self.toolExpExcel = QtWidgets.QToolButton(self.frame)
        self.toolExpExcel.setObjectName("ExpExcel_Button")
        self.toolExpExcel.setToolTip("Exportar a Excel")
        self.hcab.addWidget(self.toolExpExcel)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Excel.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolExpExcel.setIcon(icon)
        self.toolExpExcel.setIconSize(QtCore.QSize(25, 25))

        self.hcabspacer=QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer)
        self.gridLayout_2.addLayout(self.hcab, 0, 0, 1, 1)
        self.hLayout1 = QtWidgets.QHBoxLayout()
        self.hLayout1.setObjectName("hLayout1")
        self.label_NumOrder = QtWidgets.QLabel(parent=self.frame)
        self.label_NumOrder.setMinimumSize(QtCore.QSize(80, 25))
        self.label_NumOrder.setMaximumSize(QtCore.QSize(80, 25))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        self.label_NumOrder.setFont(font)
        self.label_NumOrder.setObjectName("label_NumOrder")
        self.hLayout1.addWidget(self.label_NumOrder)
        self.Numorder_EditTags = QtWidgets.QLineEdit(parent=self.frame)
        self.Numorder_EditTags.setMinimumSize(QtCore.QSize(250, 25))
        self.Numorder_EditTags.setMaximumSize(QtCore.QSize(250, 25))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.Numorder_EditTags.setFont(font)
        self.Numorder_EditTags.setObjectName("Numorder_EditTags")
        self.hLayout1.addWidget(self.Numorder_EditTags)
        self.Button_Clean = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Clean.setMinimumSize(QtCore.QSize(150, 35))
        self.Button_Clean.setMaximumSize(QtCore.QSize(150, 35))
        self.Button_Clean.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.Button_Clean.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 8px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:focus {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255)\n"
"}\n"
"\n"
"QPushButton:focus:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        self.Button_Clean.setObjectName("Button_Clean")
        self.gridLayout_2.addLayout(self.hLayout1, 1, 0, 1, 1)
        self.Button_Query = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Query.setMinimumSize(QtCore.QSize(150, 35))
        self.Button_Query.setMaximumSize(QtCore.QSize(150, 35))
        self.Button_Query.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.Button_Query.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 8px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:focus {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255)\n"
"}\n"
"\n"
"QPushButton:focus:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        self.Button_Query.setObjectName("Button_Query")
        self.hLayout1.addWidget(self.Button_Query)
        self.hLayout1.addWidget(self.Button_Clean)
        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 3, 0, 1, 1)
        self.tableEditTags=QtWidgets.QTableView(parent=self.frame)
        self.model = EditableTableModel()
        self.tableEditTags.setObjectName("tableEditTags")
        self.gridLayout_2.addWidget(self.tableEditTags, 4, 0, 1, 1)
        self.hLayout3 = QtWidgets.QHBoxLayout()
        self.hLayout3.setObjectName("hLayout3")
        spacerItem2 = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hLayout3.addItem(spacerItem2)
        self.label_SumItems = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setText("")
        self.label_SumItems.setObjectName("label_SumItems")
        self.hLayout3.addWidget(self.label_SumItems)
        self.label_SumValue = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setText("")
        self.label_SumValue.setObjectName("label_SumValue")
        self.hLayout3.addWidget(self.label_SumValue)
        self.label_CountItems = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setText("")
        self.label_CountItems.setObjectName("label_CountItems")
        self.hLayout3.addWidget(self.label_CountItems)
        self.label_CountValue = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setText("")
        self.label_CountValue.setObjectName("label_CountValue")
        self.hLayout3.addWidget(self.label_CountValue)
        self.gridLayout_2.addLayout(self.hLayout3, 5, 0, 1, 1)
        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 0, 0, 1, 1)
        self.gridLayout.addWidget(self.frame, 0, 0, 1, 1)
        EditTags_Window.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=EditTags_Window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 790, 22))
        self.menubar.setObjectName("menubar")
        EditTags_Window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=EditTags_Window)
        self.statusbar.setObjectName("statusbar")
        EditTags_Window.setStatusBar(self.statusbar)

        self.retranslateUi(EditTags_Window)
        QtCore.QMetaObject.connectSlotsByName(EditTags_Window)
        self.Button_Clean.clicked.connect(self.clean_boxes)
        self.Button_Query.clicked.connect(self.query_tags)
        self.toolDeleteFilter.clicked.connect(self.delete_allFilters)
        self.toolShow.clicked.connect(self.show_columns)
        self.toolMatOrder.clicked.connect(lambda: self.materialorder(self.variable))
        self.toolFabOrder.clicked.connect(self.faborder)
        self.toolInspection.clicked.connect(self.setinspection)
        self.toolExpExcel.clicked.connect(self.exporttoexcel)
        self.Numorder_EditTags.returnPressed.connect(self.query_tags)
        self.model.dataChanged.connect(self.saveChanges)
        self.createContextMenu()

        commands_comboboxes_flow = [
            "SELECT item_type FROM validation_data.flow_item_type",
            "SELECT line_size FROM validation_data.flow_line_size",
            "SELECT rating FROM validation_data.flow_rating",
            "SELECT facing FROM validation_data.flow_facing",
            "SELECT schedule FROM validation_data.flow_schedule",
            "SELECT flange_material FROM validation_data.flow_flange_material",
            "SELECT flange_type FROM validation_data.flow_flange_type",
            "SELECT element_material FROM validation_data.flow_element_material",
            "SELECT tapping FROM validation_data.flow_tapping",
            "SELECT element_material FROM validation_data.flow_element_material",
            "SELECT plate_type FROM validation_data.flow_plate_type",
            "SELECT plate_thk FROM validation_data.flow_plate_thk",
            "SELECT plate_std FROM validation_data.flow_plate_std",
            "SELECT gasket_material FROM validation_data.flow_gasket_material",
            "SELECT bolts_nuts_material FROM validation_data.flow_bolts_nuts_material",
            "SELECT nace FROM validation_data.flow_nace"
            ]

        commands_comboboxes_temp = [
            "SELECT item_type FROM validation_data.temp_item_type",
            "SELECT tw_type FROM validation_data.temp_tw_type",
            "SELECT flange_size FROM validation_data.temp_flange_size",
            "SELECT flange_rating FROM validation_data.temp_flange_rating",
            "SELECT flange_facing FROM validation_data.temp_flange_facing",
            "SELECT tw_material FROM validation_data.temp_tw_material",
            "SELECT root_diam FROM validation_data.temp_root_diam",
            "SELECT tip_diam FROM validation_data.temp_tip_diam",
            "SELECT sensor_element FROM validation_data.temp_sensor_element",
            "SELECT sheath_stem_material FROM validation_data.temp_sheath_stem_material",
            "SELECT sheath_stem_diam FROM validation_data.temp_sheath_stem_diam",
            "SELECT insulation FROM validation_data.temp_insulation",
            "SELECT temp_inf FROM validation_data.temp_temp_inf",
            "SELECT temp_sup FROM validation_data.temp_temp_sup",
            "SELECT nipple_ext_material FROM validation_data.temp_nipple_ext_material",
            "SELECT nipple_ext_length FROM validation_data.temp_nipple_ext_length",
            "SELECT head_case_material FROM validation_data.temp_head_case_material",
            "SELECT head_conn_case_diam FROM validation_data.temp_head_conn_case_diam",
            "SELECT tttb FROM validation_data.temp_tttb",
            "SELECT flange_material_lapjoint FROM validation_data.temp_flange_material_lapjoint",
            "SELECT gasket_material FROM validation_data.temp_gasket_material",
            "SELECT puntal FROM validation_data.temp_puntal",
            "SELECT tube_t FROM validation_data.temp_tube_t",
            "SELECT nace FROM validation_data.temp_nace",
            "SELECT plug FROM validation_data.temp_plug"
            ]

        commands_comboboxes_level = [
            "SELECT item_type FROM validation_data.level_item_type",
            "SELECT model_num FROM validation_data.level_model_num",
            "SELECT body_mat FROM validation_data.level_body_mat",
            "SELECT proc_conn_type FROM validation_data.level_proc_conn_type",
            "SELECT proc_conn_size FROM validation_data.level_proc_conn_size",
            "SELECT proc_conn_rating FROM validation_data.level_proc_conn_rating",
            "SELECT proc_conn_facing FROM validation_data.level_proc_conn_facing",
            "SELECT conn_type FROM validation_data.level_conn_type",
            "SELECT valve_type FROM validation_data.level_valve_type",
            "SELECT dv_conn FROM validation_data.level_dv_conn",
            "SELECT dv_size FROM validation_data.level_dv_size",
            "SELECT dv_rating FROM validation_data.level_dv_rating",
            "SELECT dv_facing FROM validation_data.level_dv_facing",
            "SELECT gasket FROM validation_data.level_gasket",
            "SELECT stud_nuts FROM validation_data.level_stud_nuts",
            "SELECT illuminator FROM validation_data.level_illuminator",
            "SELECT float_mat FROM validation_data.level_float_mat",
            "SELECT case_cover_mat FROM validation_data.level_case_cover_mat",
            "SELECT scale_type FROM validation_data.level_scale",
            "SELECT flags_color_mat FROM validation_data.level_flags_color_mat",
            "SELECT ip_code FROM validation_data.level_ip_code",
            "SELECT flange_type FROM validation_data.level_flange_type",
            "SELECT nipple FROM validation_data.level_nipple",
            "SELECT nipple FROM validation_data.level_nipple",
            "SELECT antifrost FROM validation_data.level_antifrost",
            "SELECT nace FROM validation_data.level_nace",
            ]

        self.all_results_flow = []
        self.all_results_temp = []
        self.all_results_level = []

        conn = None
        try:
        # read the connection parameters
            params = config()
        # connect to the PostgreSQL server
            conn = psycopg2.connect(**params)
            cur = conn.cursor()
        # execution of commands
            for query in commands_comboboxes_flow:
                cur.execute(query)
                results_flow=cur.fetchall()
                self.all_results_flow.append(results_flow)
            for query in commands_comboboxes_temp:
                cur.execute(query)
                results_temp=cur.fetchall()
                self.all_results_temp.append(results_temp)
            for query in commands_comboboxes_level:
                cur.execute(query)
                results_level=cur.fetchall()
                self.all_results_level.append(results_level)
        # close communication with the PostgreSQL database server
            cur.close()
        # commit the changes
            conn.commit()
        except (Exception, psycopg2.DatabaseError) as error:
            print(error)
        finally:
            if conn is not None:
                conn.close()

    def retranslateUi(self, EditTags_Window):
        _translate = QtCore.QCoreApplication.translate
        EditTags_Window.setWindowTitle(_translate("EditTags_Window", "Editar Tags"))
        self.tableEditTags.setSortingEnabled(True)
        self.Button_Query.setText(_translate("EditTags_Window", "Buscar"))
        self.label_NumOrder.setText(_translate("EditTags_Window", "Nº Pedido:"))
        self.Button_Clean.setText(_translate("EditTags_Window", "Vaciar Cuadros"))

# Function to clear the text boxes
    def clean_boxes(self):
        self.Numorder_EditTags.setText("")

# Function to delete all filters when tool button is clicked
    def delete_allFilters(self):
        columns_number=self.model.columnCount()
        for index in range(columns_number):
            if index in self.proxy.filters:
                del self.proxy.filters[index]
            self.model.setIconColumnHeader(index, '')

        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.checkbox_filters = {}

        self.proxy.invalidateFilter()
        self.tableEditTags.setModel(None)
        self.tableEditTags.setModel(self.proxy)

        # Getting the unique values for each column of the model
        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            if column not in self.checkbox_states:
                self.checkbox_states[column] = {}
                self.checkbox_states[column]['Seleccionar todo'] = True
                for row in range(self.model.rowCount()):
                    value = self.model.record(row).value(column)
                    if value not in list_valuesUnique:
                        if isinstance(value, QtCore.QDate):
                            value=value.toString("dd/MM/yyyy")
                        list_valuesUnique.append(str(value))
                        self.checkbox_states[column][value] = True
                self.dict_valuesuniques[column] = list_valuesUnique

        self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditTags.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditTags.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function to save changes into database
    def saveChanges(self, topLeft, bottomRight, roles):
        row = topLeft.row()
        column = topLeft.column()

        actual_date=date.today()
        actual_date= actual_date.strftime("%d/%m/%Y")


        if (column == 34 and self.variable == 'Caudal') or \
            ((column == 45 and self.variable == 'Temperatura') or \
            (column == 42 and self.variable == 'Nivel')):

            commands_queryorder = ("""
                            SELECT orders."num_order",offers."responsible"
                            FROM offers
                            INNER JOIN orders ON (offers."num_offer"=orders."num_offer")
                            WHERE UPPER(orders."num_order") LIKE UPPER('%%'||%s||'%%')
                            ORDER BY orders."num_order"
                            """)
            commands_check_notif = ("""
                        SELECT *
                        FROM notifications.notifications_change_tags
                        WHERE ("username" = %s
                        AND "message" = 'Cambios en pedido: ' || UPPER(%s)
                        AND "state" = 'Pendiente')
                        """)
            commands_notification_changes = ("""INSERT INTO notifications.notifications_change_tags (
                                                "username","message","state","date_creation"
                                                )
                                                VALUES (%s,%s,%s,%s)
                                                """)
            commands_usernames = ("""SELECT username FROM users_data.registration
                        WHERE profile = 'Taller'
                        """)
            conn = None
            try:
            # read the connection parameters
                params = config()
            # connect to the PostgreSQL server
                conn = psycopg2.connect(**params)
                cur = conn.cursor()
            # execution of commands one by one
                data = (self.numorder,)
                cur.execute(commands_queryorder, data)
                results_queryorder=cur.fetchall()

                cur.execute(commands_check_notif,(results_queryorder[0][1], self.numorder,))
                results_order = cur.fetchall()
            # close communication with the PostgreSQL database server
                cur.close()
            # commit the changes
                conn.commit()
            except (Exception, psycopg2.DatabaseError) as error:
                print(error)
            finally:
                if conn is not None:
                    conn.close()

            if not len(results_order)>0:
                conn = None
                try:
                # read the connection parameters
                    params = config()
                # connect to the PostgreSQL server
                    conn = psycopg2.connect(**params)
                    cur = conn.cursor()
                # execution of commands
                    data = (results_queryorder[0][1], 'Cambios en pedido: ' + self.numorder, 'Pendiente',actual_date,)
                    cur.execute(commands_notification_changes, data)

                    cur.execute(commands_usernames)
                    results_usernames=cur.fetchall()
                    for user_data in results_usernames:
                        data = (user_data[0], "Nuevo pedido: " + self.numorder, "Pendiente", actual_date)
                        cur.execute(commands_notification_changes, data)

                # close communication with the PostgreSQL database server
                    cur.close()
                # commit the changes
                    conn.commit()
                except (Exception, psycopg2.DatabaseError) as error:
                    print(error)
                finally:
                    if conn is not None:
                        conn.close()

            # new_value = self.model.data(topLeft)
            # print(f"Nuevo valor: {new_value}")

            # # Obtener el valor de la columna 1 de la misma fila
            # value_column_1 = self.model.data(self.model.index(row, 1))
            # print(f"Valor de la columna 1: {value_column_1}")




        self.model.submitAll()

        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            for row in range(self.model.rowCount()):
                value = self.model.record(row).value(column)
                if value not in list_valuesUnique:
                    if isinstance(value, QtCore.QDate):
                        value=value.toString("dd/MM/yyyy")
                    list_valuesUnique.append(str(value))
                    if value not in self.checkbox_states[column]:
                        self.checkbox_states[column][value] = True
            self.dict_valuesuniques[column] = list_valuesUnique

# Function to load table and setting in the window
    def query_tags(self):
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []

        self.model.dataChanged.disconnect(self.saveChanges)
        self.numorder = self.Numorder_EditTags.text()

        if self.numorder=="":
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("Rellena alguno de los campos")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg.exec()
            del dlg, new_icon
            self.model.dataChanged.connect(self.saveChanges)

        else:
            if not re.match(r'^(P|PA)-\d{2}/\d{3}.*$', self.numorder):
                dlg = QtWidgets.QMessageBox()
                new_icon = QtGui.QIcon()
                new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                dlg.setWindowIcon(new_icon)
                dlg.setWindowTitle("ERP EIPSA")
                dlg.setText("El número de pedido debe tener formato P-XX/YYY o PA-XX/YYY")
                dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                dlg.exec()
                del dlg, new_icon
                self.model.dataChanged.connect(self.saveChanges)

            else:
                query = ('''
                        SELECT num_order, product_type."variable"
                        FROM orders
                        INNER JOIN offers ON (offers."num_offer" = orders."num_offer")
                        INNER JOIN product_type ON (product_type."material" = offers."material")
                        WHERE
                        UPPER (orders."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')
                conn = None
                try:
                # read the connection parameters
                    params = config()
                # connect to the PostgreSQL server
                    conn = psycopg2.connect(**params)
                    cur = conn.cursor()
                # execution of commands
                    cur.execute(query,(self.numorder,))
                    results_variable=cur.fetchone()
                    self.variable = results_variable[1] if results_variable != None else ''
                # close communication with the PostgreSQL database server
                    cur.close()
                # commit the changes
                    conn.commit()
                except (Exception, psycopg2.DatabaseError) as error:
                    print(error)
                finally:
                    if conn is not None:
                        conn.close()

                if results_variable == None:
                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("ERP EIPSA")
                    dlg.setText("EL número de pedido no existe")
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                    dlg.exec()
                    del dlg, new_icon
                    self.model.dataChanged.connect(self.saveChanges)

                else:
                    if self.variable == 'Caudal':
                        self.model.setTable("tags_data.tags_flow")
                        self.initial_column = 28
                    elif self.variable == 'Temperatura':
                        self.model.setTable("tags_data.tags_temp")
                        self.initial_column = 35
                    elif self.variable == 'Nivel':
                        self.model.setTable("tags_data.tags_level")
                        self.initial_column = 36
                    self.model.setFilter(f"num_order <>'' AND UPPER(num_order) LIKE '%{self.numorder.upper()}%'")

        if self.variable != '':
            self.tableEditTags.setModel(None)
            self.tableEditTags.setModel(self.proxy)
            self.model.select()

            self.proxy.setSourceModel(self.model)
            self.tableEditTags.setModel(self.proxy)

            columns_number=self.model.columnCount()
            for column in range(columns_number):
                self.tableEditTags.setItemDelegateForColumn(column, None)
            self.model.column_range = range(self.initial_column,self.initial_column + 4)

            if self.variable == 'Caudal':
                for i in range(66,columns_number):
                    self.tableEditTags.hideColumn(i)
            elif self.variable == 'Temperatura':
                for i in range(73,columns_number):
                    self.tableEditTags.hideColumn(i)
            elif self.variable == 'Nivel':
                for i in range(56,columns_number):
                    self.tableEditTags.hideColumn(i)

            if self.name != 'Jesús Martínez':
                if self.variable == 'Caudal':
                    self.tableEditTags.hideColumn(28)
                elif self.variable == 'Temperatura':
                    self.tableEditTags.hideColumn(35)
                elif self.variable == 'Nivel':
                    self.tableEditTags.hideColumn(36)

            # self.tableEditTags.verticalHeader().hide()
            self.tableEditTags.setItemDelegate(AlignDelegate(self.tableEditTags))
            self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditTags.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditTags.horizontalHeader().setSectionResizeMode(columns_number-1,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditTags.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")
            self.tableEditTags.setObjectName("tableEditTags")
            self.gridLayout_2.addWidget(self.tableEditTags, 3, 0, 1, 1)
            self.tableEditTags.setSortingEnabled(False)
            self.tableEditTags.horizontalHeader().sectionDoubleClicked.connect(self.on_view_horizontalHeader_sectionClicked)
            self.tableEditTags.horizontalHeader().customContextMenuRequested.connect(self.showColumnContextMenu)
            self.tableEditTags.horizontalHeader().setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)

        # Change all column names
            headers_flow = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido", "PO", "Posición", "Subposición",
                        "Tipo", "Tamaño Línea", "Rating", "Facing", "Schedule", "Material Brida", "Tipo Brida",
                        "Material Tubo", "Tamaño Tomas (Nº)", "Material Elemento", "Tipo Placa", "Espesor Placa",
                        "Estándar Placa", "Material Junta", "Material Tornillería", "Nº Saltos", "Pipe Spec.",
                        "Peso Aprox. (kg)", "Long. Aprox. (mm)", "NACE", "Precio (€)", "Notas Oferta",
                        "Cambios Comercial", "Fecha Contractual", "Ø Orif. (mm)", "Ø D/V (mm)", "Cambios Técnicos",
                        "Notas Técnicas", "Nº Doc. EIPSA Cálculo", "Estado Cálculo", "Fecha Estado Cálculo", "Nº Doc. EIPSA Plano",
                        "Estado Plano", "Fecha Estado Plano", "Orden de Compra", "Fecha Orden Compra", "Notas Orden Compra",
                        "Fecha OF Placa", "Plano OF Placa", "Colada Placa", "Fecha OF Brida", "Plano OF Brida",
                        "Colada Brida", "Nº Tapones", "Tamaño Tomas", "Nº Tomas", "RTJ Porta Material",
                        "RTJ Espesor", "RTJ Dim", "Ø Ext. Placa (mm)", "Mango", "Tamaño Espárragos",
                        "Cantidad Espárragos", "Tamaño Extractor", "Cantidad Extractor", "Estado Fabricación", "Inspección",
                        "Envío RN"]

            headers_temp = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido", "PO", "Posición", "Subposición",
                        "Tipo", "Tipo TW", "Tamaño Brida", "Rating Brida", "Facing Brida", "Standard TW",
                        "Material TW", "Long. STD (mm)", "Long. Ins. (mm)", "Ø Raíz (mm)", "Ø Punta (mm)",
                        "Sensor", "Material Sheath/Stem", "Ø Sheath/Stem (mm)", "Insulation", "Temp Inf (ºC)",
                        "Temp Sup ºC", "Material Nipple Ext.", "Long. Nipple Ext. (mm)", "Material Head/Case", "Con. Elec./Diam. Case",
                        "TT/Terminal Insulation", "Material Brida LapJoint", "Material Junta", "Puntal", "Tubo",
                        "NACE", "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual",
                        "Stress", "Geometría", "Long. Cónica (mm)", "Long. Recta (mm)", "Ø Picaje (mm)",
                        "Notas Cálculo", "Cambios Técnicos", "Notas Técnicas", "Nº Doc. EIPSA Cálculo", "Estado Cálculo",
                        "Fecha Estado Cálculo", "Nº Doc. EIPSA Plano", "Estado Plano", "Fecha Estado Plano", "Notas Planos",
                        "Orden de Compra", "Fecha Orden Compra", "Notas Orden Compra", "Fecha OF Sensor", "Plano OF Sensor", 
                        "Notas Sensor", "Estado Fabricación Sensor", "Fecha OF TW", "Plano OF TW", "Notas TW",
                        "Estado Fabricación TW", "Long. Corte TW (mm)", "Cota A Sensor (mm)", "Cota B Sensor (mm)", "Cota L Sensor (mm)",
                        "Tapón", "Estado Fabricación", "Inspección", "Envío RN"]

            headers_level = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                            "PO", "Posición", "Subposición", "Tipo", "Modelo",
                            "Material Cuerpo", "Tipo Conex. Proc.", "Tamaño Conex. Proc.", "Rating Conex. Proc.", "Facing Conex. Proc.",
                            "Tipo Conex.", "Visibilidad (mm)", "Long. C-C (mm)", "Tipo Válv.", "Tipo Conex. Ext.",
                            "Tamaño Conex. Ext.", "Rating Conex. Ext.", "Facing Conex. Ext.", "Junta", "Tornillería",
                            "Iluminador", "Mat. Flotador", "Mat. Cubierta", "Escala", "Banderas",
                            "Cod. IP", "Tipo Brida", "Niplo Hex.", "Niplo Tubo", "Antifrost",
                            "NACE", "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual",
                            "Dim. Flotador", "Junta Bridas", "Cambios Técnicos", "Notas Técnicas", "Nº Doc. EIPSA Plano",
                            "Estado Plano", "Fecha Estado Plano", "Notas Plano", "Fecha OF", "Plano OF",
                            "Orden de Compra", "Fecha Orden Compra", "Notas Orden Compra", "Estado Fabricación", "Inspección", "Envío RN"]

            if self.variable == 'Caudal':
                self.model.setAllColumnHeaders(headers_flow)
            elif self.variable == 'Temperatura':
                self.model.setAllColumnHeaders(headers_temp)
            elif self.variable == 'Nivel':
                self.model.setAllColumnHeaders(headers_level)

        # Getting the unique values for each column of the model
            for column in range(self.model.columnCount()):
                list_valuesUnique = []
                if column not in self.checkbox_states:
                    self.checkbox_states[column] = {}
                    self.checkbox_states[column]['Seleccionar todo'] = True
                    for row in range(self.model.rowCount()):
                        value = self.model.record(row).value(column)
                        if value not in list_valuesUnique:
                            if isinstance(value, QtCore.QDate):
                                value=value.toString("dd/MM/yyyy")
                            list_valuesUnique.append(str(value))
                            self.checkbox_states[column][value] = True
                    self.dict_valuesuniques[column] = list_valuesUnique

        # Setting cells with comboboxes
            list_fab_state = ['','PTE.APROBACIÓN','EN FABRICACIÓN','INSPECCIÓN','ENVIADO']
            if self.variable == 'Caudal':
                for i in range(16):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_flow[i]]))
                    self.tableEditTags.setItemDelegateForColumn(i+8, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, list_fab_state)
                self.tableEditTags.setItemDelegateForColumn(63, self.combo_itemtype)
            elif self.variable == 'Temperatura':
                for i in range(5):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_temp[i]]))
                    self.tableEditTags.setItemDelegateForColumn(i+8, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_temp[5]]))
                self.tableEditTags.setItemDelegateForColumn(14, self.combo_itemtype)
                for i in range(6,24):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_temp[i]]))
                    self.tableEditTags.setItemDelegateForColumn(i+11, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, list_fab_state)
                self.tableEditTags.setItemDelegateForColumn(60, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, list_fab_state)
                self.tableEditTags.setItemDelegateForColumn(64, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_temp[24]]))
                self.tableEditTags.setItemDelegateForColumn(69, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, list_fab_state)
                self.tableEditTags.setItemDelegateForColumn(70, self.combo_itemtype)
            elif self.variable == 'Nivel':
                for i in range(8):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_level[i]]))
                    self.tableEditTags.setItemDelegateForColumn(i+8, self.combo_itemtype)
                for i in range(18):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_level[i+8]]))
                    self.tableEditTags.setItemDelegateForColumn(i+18, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, list_fab_state)
                self.tableEditTags.setItemDelegateForColumn(53, self.combo_itemtype)

            self.model.dataChanged.connect(self.saveChanges)
            self.selection_model = self.tableEditTags.selectionModel()
            self.selection_model.selectionChanged.connect(self.countSelectedCells)

# Function when header is clicked
    def on_view_horizontalHeader_sectionClicked(self, logicalIndex):
        self.logicalIndex = logicalIndex
        self.menuValues = QtWidgets.QMenu(self)
        self.signalMapper = QtCore.QSignalMapper(self.tableEditTags)

        valuesUnique_view = []
        for row in range(self.tableEditTags.model().rowCount()):
            index = self.tableEditTags.model().index(row, self.logicalIndex)
            value = index.data(Qt.ItemDataRole.DisplayRole)
            if value not in valuesUnique_view:
                if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
                valuesUnique_view.append(value)

        actionSortAscending = QtGui.QAction("Ordenar Ascendente", self.tableEditTags)
        actionSortAscending.triggered.connect(self.on_actionSortAscending_triggered)
        self.menuValues.addAction(actionSortAscending)
        actionSortDescending = QtGui.QAction("Ordenar Descendente", self.tableEditTags)
        actionSortDescending.triggered.connect(self.on_actionSortDescending_triggered)
        self.menuValues.addAction(actionSortDescending)
        self.menuValues.addSeparator()

        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro", self.tableEditTags)
        actionDeleteFilterColumn.triggered.connect(self.on_actionDeleteFilterColumn_triggered)
        self.menuValues.addAction(actionDeleteFilterColumn)
        self.menuValues.addSeparator()

        actionTextFilter = QtGui.QAction("Buscar...", self.tableEditTags)
        actionTextFilter.triggered.connect(self.on_actionTextFilter_triggered)
        self.menuValues.addAction(actionTextFilter)
        self.menuValues.addSeparator()

        scroll_menu = QtWidgets.QScrollArea()
        scroll_menu.setStyleSheet("background-color: rgb(255, 255, 255)")
        scroll_menu.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget(scroll_menu)
        scroll_menu.setWidget(scroll_widget)
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        checkbox_all_widget = QtWidgets.QCheckBox('Seleccionar todo')

        if not self.checkbox_states[self.logicalIndex]['Seleccionar todo'] == True:
            checkbox_all_widget.setChecked(False)
        else:
            checkbox_all_widget.setChecked(True)
        
        checkbox_all_widget.toggled.connect(lambda checked, name='Seleccionar todo': self.on_select_all_toggled(checked, name))

        scroll_layout.addWidget(checkbox_all_widget)
        self.action_checkbox_map['Seleccionar todo'] = checkbox_all_widget

        if len(self.dict_ordersort) != 0 and self.logicalIndex in self.dict_ordersort:
            list_uniquevalues = sorted(list(set(self.dict_valuesuniques[self.logicalIndex])))
        else:
            list_uniquevalues = sorted(list(set(valuesUnique_view)))

        for actionName in list_uniquevalues:
            checkbox_widget = QtWidgets.QCheckBox(actionName)

            if self.logicalIndex not in self.checkbox_filters:
                checkbox_widget.setChecked(True)
            elif actionName not in self.checkbox_filters[self.logicalIndex]:
                checkbox_widget.setChecked(False)
            else:
                checkbox_widget.setChecked(True)

            checkbox_widget.toggled.connect(lambda checked, name=actionName: self.on_checkbox_toggled(checked, name))

            scroll_layout.addWidget(checkbox_widget)
            self.action_checkbox_map[actionName] = checkbox_widget

        action_scroll_menu = QtWidgets.QWidgetAction(self.menuValues)
        action_scroll_menu.setDefaultWidget(scroll_menu)
        self.menuValues.addAction(action_scroll_menu)

        self.menuValues.addSeparator()

        accept_button = QtGui.QAction("ACEPTAR", self.tableEditTags)
        accept_button.triggered.connect(self.menu_acceptbutton_triggered)

        cancel_button = QtGui.QAction("CANCELAR", self.tableEditTags)
        cancel_button.triggered.connect(self.menu_cancelbutton_triggered)

        self.menuValues.addAction(accept_button)
        self.menuValues.addAction(cancel_button)

        self.menuValues.setStyleSheet("QMenu { color: black; }"
                                        "QMenu { background-color: rgb(255, 255, 255); }"
                                        "QMenu::item:selected { background-color: #33bdef; }"
                                        "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

        headerPos = self.tableEditTags.mapToGlobal(self.tableEditTags.horizontalHeader().pos())        

        posY = headerPos.y() + self.tableEditTags.horizontalHeader().height()
        scrollX = self.tableEditTags.horizontalScrollBar().value()
        xInView = self.tableEditTags.horizontalHeader().sectionViewportPosition(logicalIndex)
        posX = headerPos.x() + xInView - scrollX

        self.menuValues.exec(QtCore.QPoint(posX, posY))

# Function when cancel button of menu is clicked
    def menu_cancelbutton_triggered(self):
        self.menuValues.hide()

# Function when accept button of menu is clicked
    def menu_acceptbutton_triggered(self):
        for column, filters in self.checkbox_filters.items():
            if filters:
                self.proxy.setFilter(filters, column)
            else:
                self.proxy.setFilter(None, column)

        self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditTags.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditTags.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function when select all checkbox is clicked
    def on_select_all_toggled(self, checked, action_name):
        filterColumn = self.logicalIndex
        imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
                checkbox_widget.setChecked(checked)
                self.checkbox_states[self.logicalIndex][checkbox_name] = checked

            if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
                self.model.setIconColumnHeader(filterColumn, icono)
            else:
                self.model.setIconColumnHeader(filterColumn, '')
        
        else:
            for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
                checkbox_widget.setChecked(checked)
                self.checkbox_states[self.logicalIndex][checkbox_widget.text()] = checked

# Function when checkbox of header menu is clicked
    def on_checkbox_toggled(self, checked, action_name):
        filterColumn = self.logicalIndex
        imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            if filterColumn not in self.checkbox_filters:
                self.checkbox_filters[filterColumn] = [action_name]
            else:
                if action_name not in self.checkbox_filters[filterColumn]:
                    self.checkbox_filters[filterColumn].append(action_name)
        else:
            if filterColumn in self.checkbox_filters and action_name in self.checkbox_filters[filterColumn]:
                self.checkbox_filters[filterColumn].remove(action_name)

        if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
            self.model.setIconColumnHeader(filterColumn, '')
        else:
            self.model.setIconColumnHeader(filterColumn, icono)

# Function to delete individual column filter
    def on_actionDeleteFilterColumn_triggered(self):
        filterColumn = self.logicalIndex
        if filterColumn in self.proxy.filters:
            del self.proxy.filters[filterColumn]
        self.model.setIconColumnHeader(filterColumn, '')
        self.proxy.invalidateFilter()

        self.tableEditTags.setModel(None)
        self.tableEditTags.setModel(self.proxy)

        if filterColumn in self.checkbox_filters:
            del self.checkbox_filters[filterColumn]

        self.checkbox_states[self.logicalIndex].clear()
        self.checkbox_states[self.logicalIndex]['Seleccionar todo'] = True
        for row in range(self.tableEditTags.model().rowCount()):
            value = self.model.record(row).value(filterColumn)
            if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
            self.checkbox_states[self.logicalIndex][str(value)] = True

        self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditTags.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditTags.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function to order column ascending
    def on_actionSortAscending_triggered(self):
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.AscendingOrder
        self.tableEditTags.sortByColumn(sortColumn, sortOrder)

# Function to order column descending
    def on_actionSortDescending_triggered(self):
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.DescendingOrder
        self.tableEditTags.sortByColumn(sortColumn, sortOrder)

# Function when text is searched
    def on_actionTextFilter_triggered(self):
        filterColumn = self.logicalIndex
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle('Buscar')
        clickedButton=dlg.exec()

        if clickedButton == 1:
            stringAction = dlg.textValue()
            if re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', stringAction):
                stringAction=QtCore.QDate.fromString(stringAction,"dd/MM/yyyy")
                stringAction=stringAction.toString("yyyy-MM-dd")

            filterString = QtCore.QRegularExpression(stringAction, QtCore.QRegularExpression.PatternOption(0))
            # del self.proxy.filters[filterColumn]
            self.proxy.setFilter([stringAction], filterColumn)

            imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
            icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
            self.model.setIconColumnHeader(filterColumn, icono)

# Function to hide column when action clicked
    def hide_column(self):
        filterColumn = self.logicalIndex 
        self.tableEditTags.setColumnHidden(filterColumn, True)
        self.hiddencolumns.append(filterColumn)

# Function to show all hidden columns
    def show_columns(self):
        for column in self.hiddencolumns:
            self.tableEditTags.setColumnHidden(column, False)
        self.hiddencolumns.clear()

# Function to create material order for flow elements
    def materialorder_flow(self):
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle('Pedido Materiales')
        dlg.setLabelText('Introduce el pedido:')
        clickedButton=dlg.exec()

        if clickedButton == 1:
            numorder_pedmat = dlg.textValue()
            flow_matorder(self.proxy, self.model, self.numorder, numorder_pedmat, self.variable)

# Function to create material order for temperature elements
    def materialorder_temp(self):
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle('Pedido Materiales')
        dlg.setLabelText('Introduce el pedido:')
        clickedButton=dlg.exec()

        if clickedButton == 1:
            numorder_pedmat = dlg.textValue()
            temp_matorder(self.proxy, self.model, self.numorder, numorder_pedmat, self.variable)

# Function to create material order for level elements
    def materialorder_level(self):
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle('Pedido Materiales')
        dlg.setLabelText('Introduce el pedido:')
        clickedButton=dlg.exec()

        if clickedButton == 1:
            numorder_pedmat = dlg.textValue()
            level_matorder(self.proxy, self.model, self.numorder, numorder_pedmat, self.variable)

# Function to create fabrication order
    def faborder(self):
        if self.proxy.rowCount() == 0:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("Orden Fabricación")
            dlg.setText("No hay datos cargados")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg.exec()
            del dlg,new_icon
        else:
            self.createfaborder_window=QtWidgets.QMainWindow()
            self.ui=Ui_CreateFabOrder_Window(self.variable, self.proxy, self.model)
            self.ui.setupUi(self.createfaborder_window)
            self.createfaborder_window.showMaximized()

# Function to set inspection number
    def setinspection(self):
        if self.proxy.rowCount() == 0:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("Inspección")
            dlg.setText("No hay datos cargados")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg.exec()
            del dlg,new_icon
        else:
            inspection(self.proxy, self.model, self.variable)

# Function to export data to excel
    def exporttoexcel(self):
        if self.proxy.rowCount() == 0:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("Exportar")
            dlg.setText("No hay datos cargados")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg.exec()
            del dlg,new_icon
        else:
            final_data = []

            visible_columns = [col for col in range(self.model.columnCount()) if not self.tableEditTags.isColumnHidden(col)]
            visible_headers = self.model.getColumnHeaders(visible_columns)
            for row in range(self.proxy.rowCount()):
                tag_data = []
                for column in visible_columns:
                    value = self.proxy.data(self.proxy.index(row, column))
                    if isinstance(value, QDate):
                        value = value.toString("dd/MM/yyyy")
                    tag_data.append(value)
                final_data.append(tag_data)

            final_data.insert(0, visible_headers)
            df = pd.DataFrame(final_data)
            df.columns = df.iloc[0]
            df = df[1:]

            output_path = asksaveasfilename(defaultextension=".xlsx", filetypes=[("Archivos de Excel", "*.xlsx")], title="Guardar archivo de Excel")
            if output_path:
                df.to_excel(output_path, index=False, header=True)

# Function to enable copy and paste cells
    def keyPressEvent(self, event):
        if event.matches(QKeySequence.StandardKey.Copy):
            selected_indexes = self.tableEditTags.selectionModel().selectedIndexes()
            if selected_indexes:
                clipboard = QApplication.clipboard()
                text = self.get_selected_text(selected_indexes)
                clipboard.setText(text)

        elif event.matches(QKeySequence.StandardKey.Paste):
            selected_indexes = self.tableEditTags.selectionModel().selectedIndexes()
            if selected_indexes:
                clipboard = QApplication.clipboard()
                text = clipboard.text()
                for index in selected_indexes:
                    current_row = index.row()
                    current_column = index.column()
                    first_column_value = self.proxy.data(self.proxy.index(current_row, 0))
                    target_row = None
                    for row in range(self.model.rowCount()):
                        if self.model.data(self.model.index(row, 0)) == first_column_value:
                            target_row = row
                            break
                    if target_row is not None:
                        target_index = self.model.index(target_row, current_column)
                        self.model.setData(target_index, text, Qt.ItemDataRole.EditRole)  # Pegar el valor en todas las celdas seleccionadas
                self.model.submitAll()

        super().keyPressEvent(event)

# Function to get the text of the selected cells
    def get_selected_text(self, indexes):
        if len(indexes) == 1:  # Si solo hay una celda seleccionada
            index = indexes[0]
            cell_data = index.data(Qt.ItemDataRole.DisplayRole)
            return cell_data
        else:
            rows = set()
            cols = set()
            for index in indexes:
                rows.add(index.row())
                cols.add(index.column())

            text_doc = QTextDocument()
            cursor = QTextCursor(text_doc)

            for row in sorted(rows):
                for col in sorted(cols):
                    index = self.model.index(row, col)  # Obtener el índice correspondiente
                    cell_data = index.data(Qt.ItemDataRole.DisplayRole)
                    cursor.insertText(str(cell_data))
                    cursor.insertText('\t')  # Tab separador de columnas
                cursor.insertText('\n')  # Salto de línea al final de la fila

            return text_doc.toPlainText()

# Function to count selected cells and sum its values
    def countSelectedCells(self):
        if len(self.tableEditTags.selectedIndexes()) > 1:
            locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

            sum_value = sum([self.euro_string_to_float(str(ix.data())) if re.match(r'^[\d.,]+\sÇ$', str(ix.data())) else float(str(ix.data()).replace(',', '.')) if str(ix.data()).replace(',', '.').replace('.', '', 1).isdigit() else 0 for ix in self.tableEditTags.selectedIndexes()])

            count_value = len([ix for ix in self.tableEditTags.selectedIndexes() if ix.data() != ""])
            if sum_value > 0:
                self.label_SumItems.setText("Suma:")
                self.label_SumValue.setText(locale.format_string("%.2f", sum_value, grouping=True))
            if count_value > 0:
                self.label_CountItems.setText("Recuento:")
                self.label_CountValue.setText(str(count_value))
        else:
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

# Function to format money string values
    def euro_string_to_float(self, euro_str):
        match = re.match(r'^([\d.,]+)\s€$', euro_str)
        if match:
            number_str = match.group(1)
            number_str = number_str.replace('.', '').replace(',', '.')
            return float(number_str)
        else:
            return 0.0

# Function to select which material order has to be created
    def materialorder(self, variable):
        if self.proxy.rowCount() == 0:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("Pedido Materiales")
            dlg.setText("No hay datos cargados")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg.exec()
            del dlg,new_icon
        else:
            if self.variable == 'Caudal':
                self.materialorder_flow()
            elif self.variable == 'Temperatura':
                self.materialorder_temp()
            elif self.variable == 'Nivel':
                self.materialorder_level()

    def createContextMenu(self):
        self.context_menu = QtWidgets.QMenu(self)
        hide_columns_action = self.context_menu.addAction("Ocultar Columnas")
        hide_columns_action.triggered.connect(self.hideSelectedColumns)

    def showColumnContextMenu(self, pos):
        header = self.tableEditTags.horizontalHeader()
        column = header.logicalIndexAt(pos)
        self.context_menu.exec(self.tableEditTags.mapToGlobal(pos))

    def hideSelectedColumns(self):
        selected_columns = set()
        header = self.tableEditTags.horizontalHeader()
        for index in header.selectionModel().selectedColumns():
            selected_columns.add(index.column())

        for column in selected_columns:
            self.tableEditTags.setColumnHidden(column, True)
            self.hiddencolumns.append(column)

        self.context_menu.close()


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    config_obj = configparser.ConfigParser()
    config_obj.read(r"C:\Program Files\ERP EIPSA\database.ini")
    dbparam = config_obj["postgresql"]
    # set your parameters for the database connection URI using the keys from the configfile.ini
    user_database = dbparam["user"]
    password_database = dbparam["password"]

    db = createConnection(user_database, password_database)
    if not db:
        sys.exit()

    EditTags_Window = Ui_EditTags_Technical_Window('Jesús Martínez',db)
    EditTags_Window.show()
    sys.exit(app.exec())