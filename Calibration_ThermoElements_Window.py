# Form implementation generated from reading ui file 'EditTags_Commercial_Window.ui'
#
# Created by: PyQt6 UI code generator 6.4.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6 import QtSql
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import Qt, QDate, QMimeData
from PyQt6.QtGui import QKeySequence, QTextDocument, QTextCursor
import re
from config import config
import psycopg2
import locale
import os
from datetime import *
import pandas as pd
from tkinter.filedialog import asksaveasfilename
from tkinter import filedialog
import shutil

basedir = r"\\nas01\DATOS\Comunes\EIPSA-ERP"


def imagen_to_base64(imagen):
    buffer = QtCore.QBuffer()
    buffer.open(QtCore.QIODevice.OpenModeFlag.WriteOnly)
    imagen.save(buffer, ".png")
    base64_data = buffer.data().toBase64().data().decode()
    return base64_data

class CheckboxWidget(QtWidgets.QWidget):
    def __init__(self, text):
        super().__init__()
        layout = QtWidgets.QHBoxLayout(self)
        self.checkbox = QtWidgets.QCheckBox(text)
        layout.addWidget(self.checkbox)

class AlignDelegate(QtWidgets.QStyledItemDelegate):
    def initStyleOption(self, option, index):
        super(AlignDelegate, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

    def paint(self, painter, option, index):
        super().paint(painter, option, index)
        textRect = painter.boundingRect(option.rect.adjusted(0, 0, 0, -option.rect.height() // 2), QtCore.Qt.TextFlag.TextDontClip | QtCore.Qt.AlignmentFlag.AlignCenter, str(index.data()),)
        verticalPosition = int(option.rect.adjusted(0, 0, 0, -option.rect.height() // 2).y() + (option.rect.adjusted(0, 0, 0, -option.rect.height() // 2).height() + textRect.height() + 8) / 2)
        horizontalPosition = int(option.rect.adjusted(0, 0, 0, -option.rect.height() // 2).x() + (option.rect.adjusted(0, 0, 0, -option.rect.height() // 2).width() - textRect.width()) / 2)
        

        if index.column() == 19:  # Column to paint
            tolerance_index = index.sibling(index.row(), 20)  # Index for column to check text
            error_value = float(str(index.data()).replace(',','.'))  # Text of cell to be painted
            tolerance_value = float(str(tolerance_index.data()).replace(',','.'))   # Text for checking
            painter.fillRect(option.rect, QtGui.QColor(18, 18, 18))

            if abs(error_value) > tolerance_value:
                text_color = QtGui.QColor(255, 0, 0)
            else:
                text_color = QtGui.QColor(255, 255, 255)

            painter.setPen(QtGui.QPen(text_color))
            painter.drawText(horizontalPosition, verticalPosition, str(index.data()).replace('.',',')) if index.data() != 0.0 else painter.drawText(horizontalPosition, verticalPosition, '')

        if index.column() == 23:  # Column to paint
            tolerance_index = index.sibling(index.row(), 24)  # Index for column to check text
            error_value = float(str(index.data()).replace(',','.'))  # Text of cell to be painted
            tolerance_value = float(str(tolerance_index.data()).replace(',','.'))   # Text for checking
            painter.fillRect(option.rect, QtGui.QColor(18, 18, 18))

            if abs(error_value) > tolerance_value:
                text_color = QtGui.QColor(255, 0, 0)
            else:
                text_color = QtGui.QColor(255, 255, 255)

            painter.setPen(QtGui.QPen(text_color))
            painter.drawText(horizontalPosition, verticalPosition, str(index.data()).replace('.',',')) if index.data() != 0.0 else painter.drawText(horizontalPosition, verticalPosition, '')

        if index.column() == 27:  # Column to paint
            tolerance_index = index.sibling(index.row(), 28)  # Index for column to check text
            error_value = float(str(index.data()).replace(',','.'))  # Text of cell to be painted
            tolerance_value = float(str(tolerance_index.data()).replace(',','.'))   # Text for checking
            painter.fillRect(option.rect, QtGui.QColor(18, 18, 18))

            if abs(error_value) > tolerance_value:
                text_color = QtGui.QColor(255, 0, 0)
            else:
                text_color = QtGui.QColor(255, 255, 255)

            painter.setPen(QtGui.QPen(text_color))
            painter.drawText(horizontalPosition, verticalPosition, str(index.data()).replace('.',',')) if index.data() != 0.0 else painter.drawText(horizontalPosition, verticalPosition, '')

        if index.column() == 31:  # Column to paint
            tolerance_index = index.sibling(index.row(), 32)  # Index for column to check text
            error_value = float(str(index.data()).replace(',','.'))  # Text of cell to be painted
            tolerance_value = float(str(tolerance_index.data()).replace(',','.'))   # Text for checking
            painter.fillRect(option.rect, QtGui.QColor(18, 18, 18))

            if abs(error_value) > tolerance_value:
                text_color = QtGui.QColor(255, 0, 0)
            else:
                text_color = QtGui.QColor(255, 255, 255)

            painter.setPen(QtGui.QPen(text_color))
            painter.drawText(horizontalPosition, verticalPosition, str(index.data()).replace('.',',')) if index.data() != 0.0 else painter.drawText(horizontalPosition, verticalPosition, '')

class EditableComboBoxDelegate(QtWidgets.QStyledItemDelegate):
    def __init__(self, parent=None, options=None):
        super().__init__(parent)
        self.options = options

    def createEditor(self, parent, option, index):
        editor = QtWidgets.QComboBox(parent)
        editor.setEditable(True)
        return editor

    def setEditorData(self, editor, index):
        text = index.data(Qt.ItemDataRole.DisplayRole)
        editor.addItems(self.options)
        editor.setEditText(text)

    def setModelData(self, editor, model, index):
        model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)

class CustomProxyModel(QtCore.QSortFilterProxyModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._filters = dict()
        self.header_names = {}

    @property
    def filters(self):
        return self._filters

    def setFilter(self, expresion, column, action_name=None):
        if expresion or expresion == '':
            if column in self.filters:
                if action_name or action_name == '':
                    self.filters[column].remove(expresion)
                else:
                    self.filters[column].append(expresion)
            else:
                self.filters[column] = [expresion]
        elif column in self.filters:
            if action_name or action_name == '':
                self.filters[column].remove(expresion)
                if not self.filters[column]:
                    del self.filters[column]
            else:
                del self.filters[column]
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        for column, expresions in self.filters.items():
            text = self.sourceModel().index(source_row, column, source_parent).data()

            if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
                text = text.toString("yyyy-MM-dd")

            for expresion in expresions[0]:
                if expresion == '':  # If expression is empty, match empty cells
                    if text == '':
                        break

                elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', expresion):
                    expresion = QtCore.QDate.fromString(expresion, "dd/MM/yyyy")
                    expresion = expresion.toString("yyyy-MM-dd")
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        break

                else:
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        break
            else:
                return False
        return True

class EditableTableModel(QtSql.QSqlTableModel):
    updateFailed = QtCore.pyqtSignal(str)

    def __init__(self, parent=None, column_range=None):
        super().__init__(parent)
        self.column_range = column_range

    def setAllColumnHeaders(self, headers):
        for column, header in enumerate(headers):
            self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIndividualColumnHeader(self, column, header):
        self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIconColumnHeader(self, column, icon):
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return super().headerData(section, orientation, role)
        return super().headerData(section, orientation, role)

    def flags(self, index):
        flags = super().flags(index)
        if index.column() == 0:
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        else:
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable

    def getColumnHeaders(self, visible_columns):
        column_headers = [self.headerData(col, Qt.Orientation.Horizontal) for col in visible_columns]
        return column_headers

class Ui_Calibration_ThermoElements_Window(QtWidgets.QMainWindow):
    def __init__(self, db, username):
        super().__init__()
        self.model = EditableTableModel()
        self.proxy = CustomProxyModel()
        self.db = db
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []
        self.variable = ''
        self.action_checkbox_map = {}
        self.checkbox_filters = {}
        self.username = username
        self.setupUi(self)

    def closeEvent(self, event):
    # Closing database connection
        if self.model:
            self.model.clear()
        self.closeConnection()

    def closeConnection(self):
    # Closing database connection
        self.tableEditCalibration.setModel(None)
        del self.model
        if self.db:
            self.db.close()
            del self.db
            if QtSql.QSqlDatabase.contains("qt_sql_default_connection"):
                QtSql.QSqlDatabase.removeDatabase("qt_sql_default_connection")

    def setupUi(self, CalibrationThermoElements_Window):
        CalibrationThermoElements_Window.setObjectName("CalibrationThermoElements_Window")
        CalibrationThermoElements_Window.resize(790, 595)
        CalibrationThermoElements_Window.setMinimumSize(QtCore.QSize(790, 595))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        CalibrationThermoElements_Window.setWindowIcon(icon)
        if self.username == 'm.gil':
            CalibrationThermoElements_Window.setStyleSheet(
            ".QFrame {border: 2px solid white;\n"
            "}\n"
            "QMenu::item:selected {background-color: rgb(3, 174, 236);}")
        else:
            CalibrationThermoElements_Window.setStyleSheet(
            ".QFrame {border: 2px solid black;\n"
            "}\n"
            "QMenu::item:selected {background-color: rgb(3, 174, 236);}")
        self.centralwidget = QtWidgets.QWidget(parent=CalibrationThermoElements_Window)
        if self.username == 'm.gil':
            self.centralwidget.setStyleSheet("background-color: #121212; color: rgb(255, 255, 255);")
        else:
            self.centralwidget.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_2.setVerticalSpacing(10)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.hcab=QtWidgets.QHBoxLayout()
        self.hcab.setObjectName("hcab")
        self.toolSaveChanges = QtWidgets.QToolButton(self.frame)
        self.toolSaveChanges.setObjectName("SaveChanges_Button")
        self.toolSaveChanges.setToolTip("Guardar")
        if self.username == 'm.gil':
            self.toolSaveChanges.setStyleSheet("border: 1px solid white;")
        self.toolSaveChanges.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolSaveChanges)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Save.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolSaveChanges.setIcon(icon)
        self.hcabspacer0=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer0)
        self.toolDeleteFilter = QtWidgets.QToolButton(self.frame)
        self.toolDeleteFilter.setObjectName("DeleteFilter_Button")
        self.toolDeleteFilter.setToolTip("Borrar filtros")
        if self.username == 'm.gil':
            self.toolDeleteFilter.setStyleSheet("border: 1px solid white;")
        self.toolDeleteFilter.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolDeleteFilter)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Delete.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolDeleteFilter.setIcon(icon)
        self.hcabspacer1=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer1)
        self.toolShow = QtWidgets.QToolButton(self.frame)
        self.toolShow.setObjectName("Show_Button")
        self.toolShow.setToolTip("Mostrar columnas")
        if self.username == 'm.gil':
            self.toolShow.setStyleSheet("border: 1px solid white;")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Eye.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolShow.setIcon(icon)
        self.toolShow.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolShow)
        self.hcabspacer5=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer5)
        self.toolExpExcel = QtWidgets.QToolButton(self.frame)
        self.toolExpExcel.setObjectName("ExpExcel_Button")
        self.toolExpExcel.setToolTip("Exportar a Excel")
        if self.username == 'm.gil':
            self.toolExpExcel.setStyleSheet("border: 1px solid white;")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Excel.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolExpExcel.setIcon(icon)
        self.toolExpExcel.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolExpExcel)

        self.hcabspacer2=QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer2)
        self.gridLayout_2.addLayout(self.hcab, 0, 0, 1, 1)
        self.hLayout1 = QtWidgets.QHBoxLayout()
        self.hLayout1.setObjectName("hLayout1")
        self.Button_Import = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Import.setMinimumSize(QtCore.QSize(150, 35))
        self.Button_Import.setMaximumSize(QtCore.QSize(150, 35))
        self.Button_Import.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.Button_Import.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 8px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:focus {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255)\n"
"}\n"
"\n"
"QPushButton:focus:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        self.Button_Import.setObjectName("Button_Import")
        self.hLayout1.addWidget(self.Button_Import)
        self.Button_Print = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Print.setMinimumSize(QtCore.QSize(150, 35))
        self.Button_Print.setMaximumSize(QtCore.QSize(150, 35))
        self.Button_Print.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.Button_Print.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 8px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:focus {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255)\n"
"}\n"
"\n"
"QPushButton:focus:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        self.Button_Print.setObjectName("Button_Print")
        self.hLayout1.addWidget(self.Button_Print)
        self.gridLayout_2.addLayout(self.hLayout1, 1, 0, 1, 1)
        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 2, 0, 1, 1)
        self.tableEditCalibration=QtWidgets.QTableView(parent=self.frame)
        self.model = EditableTableModel()
        self.tableEditCalibration.setObjectName("tableEditCalibration")
        self.gridLayout_2.addWidget(self.tableEditCalibration, 3, 0, 1, 1)
        self.hLayout3 = QtWidgets.QHBoxLayout()
        self.hLayout3.setObjectName("hLayout3")
        spacerItem2 = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hLayout3.addItem(spacerItem2)
        self.label_SumItems = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setText("")
        self.label_SumItems.setObjectName("label_SumItems")
        self.hLayout3.addWidget(self.label_SumItems)
        self.label_SumValue = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setText("")
        self.label_SumValue.setObjectName("label_SumValue")
        self.hLayout3.addWidget(self.label_SumValue)
        self.label_CountItems = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setText("")
        self.label_CountItems.setObjectName("label_CountItems")
        self.hLayout3.addWidget(self.label_CountItems)
        self.label_CountValue = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setText("")
        self.label_CountValue.setObjectName("label_CountValue")
        self.hLayout3.addWidget(self.label_CountValue)
        self.gridLayout_2.addLayout(self.hLayout3, 4, 0, 1, 1)
        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 0, 0, 1, 1)
        self.gridLayout.addWidget(self.frame, 0, 0, 1, 1)
        CalibrationThermoElements_Window.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=CalibrationThermoElements_Window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 790, 22))
        self.menubar.setObjectName("menubar")
        CalibrationThermoElements_Window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=CalibrationThermoElements_Window)
        self.statusbar.setObjectName("statusbar")
        CalibrationThermoElements_Window.setStatusBar(self.statusbar)

        delete_action = QtGui.QAction("Eliminar Fila", self)
        delete_action.triggered.connect(self.delete_register)

        self.context_menu_row = QtWidgets.QMenu(self)
        self.context_menu_row.addAction(delete_action)

        self.tableEditCalibration.setContextMenuPolicy(Qt.ContextMenuPolicy.ActionsContextMenu)
        self.tableEditCalibration.addActions([delete_action])

        self.retranslateUi(CalibrationThermoElements_Window)
        QtCore.QMetaObject.connectSlotsByName(CalibrationThermoElements_Window)
        self.Button_Import.clicked.connect(self.import_data)
        self.Button_Print.clicked.connect(self.print_certificate)
        self.toolSaveChanges.clicked.connect(self.saveChanges)
        self.toolDeleteFilter.clicked.connect(self.delete_allFilters)
        self.toolShow.clicked.connect(self.show_columns)
        self.toolExpExcel.clicked.connect(self.exporttoexcel)
        self.createContextMenu()
        self.query_calibration()


    def retranslateUi(self, CalibrationThermoElements_Window):
        _translate = QtCore.QCoreApplication.translate
        CalibrationThermoElements_Window.setWindowTitle(_translate("CalibrationThermoElements_Window", "Calibración Termoelementos"))
        self.tableEditCalibration.setSortingEnabled(True)
        self.Button_Print.setText(_translate("CalibrationThermoElements_Window", "Imprimir"))
        self.Button_Import.setText(_translate("CalibrationThermoElements_Window", "Importar Datos"))


# Function to import data to database
    def import_data(self):
        folder_path = "E:/Fluke/1586A/42280006/data/scan" # //nas01/DATOS/Comunes/MARIO GIL/VERIFICACION/CARPETAS IMPORTACIONES CALIBRACION"

        if folder_path:
            for subfolder in os.listdir(folder_path):
                subfolder_path = os.path.join(folder_path, subfolder)

                try:
                    conn = None
                # read the connection parameters
                    params = config()
                # connect to the PostgreSQL server
                    conn = psycopg2.connect(**params)
                    cur = conn.cursor()

                    if os.path.isdir(subfolder_path):
                        for csv_file in os.listdir(subfolder_path):
                            if csv_file.endswith('setup.csv'):
                                df_date = pd.read_csv(os.path.join(subfolder_path, csv_file), nrows=3)
                                user = 'Jose Alberto Sanz' if df_date.iloc[1, 1] in ['USER1', 'GUEST'] else('Emilio Munez' if df_date.iloc[1, 1] == 'USER2' else 'Alberto Segura')
                                fecha_str = df_date.iloc[0, 1].split()[0]
                                import_date = pd.to_datetime(fecha_str).date()

                                df_setup = pd.read_csv(os.path.join(subfolder_path, csv_file), skiprows=11, index_col=False)
                                df_setup.drop(columns=['Function', 'Channel Delay', 'Rate of Change', 'Range' ,'Probe ID', 'Open Detect', 'Cold Junction',
                                'Fixed', 'Display As', 'C0', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'Scaling', 'Gain', 'Offset', 'Unit', 'Alarm1 Type',
                                'Alarm1 Limit', 'Alarm1 Output', 'Alarm2 Type', 'Alarm2 Limit', 'Alarm2 Output'], inplace=True)
                                index_test_setup = df_setup.index[df_setup['Channel'] == 'Test Setup'].tolist()
                                df_setup = df_setup.iloc[:index_test_setup[0]] # Selecting rows between "Analog Channels" and "Test Setup"
                                df_setup.rename(columns={"Label": "label", "Wire": "wire", "Sensor Type": "sensor"}, inplace=True)
                                df_setup.set_index('Channel', inplace=True)

                            if csv_file.endswith('dat00001.csv'):
                                df_dat = pd.read_csv(os.path.join(subfolder_path, csv_file))
                                df_dat.drop(columns=['Record #', 'Time', 'Alarm Output', 'Signature'], inplace=True)
                                df_dat.columns = map(lambda col: col.replace(' (C)', ''), df_dat.columns)
                                df_dat.columns = map(lambda col: col.replace(' ', ''), df_dat.columns)
                                df_dat = df_dat.T
                                df_dat.columns = df_dat.columns.astype(str)
                                df_dat.rename(columns={"0": "element_1"}, inplace=True)
                                if '1' in df_dat.columns.to_list():
                                    df_dat.rename(columns={"1": "element_2"}, inplace=True)
                                if '2' in df_dat.columns.to_list():
                                    df_dat.rename(columns={"2": "element_3"}, inplace=True)
                                if '3' in df_dat.columns.to_list():
                                    df_dat.rename(columns={"3": "element_4"}, inplace=True)
                                df_dat.index.name = 'Channel'

                        df_final = pd.concat([df_setup, df_dat], axis=1)
                        df_master = pd.DataFrame([df_final.iloc[0]])

                        dict_master = {'20':'EIPSA-020', '24': 'EIPSA-024',
                                        '35': 'EIPSA-035', '01': 'EIPSA-TE-01', '02': 'EIPSA-TE-02'}

                        df_master.rename(columns={"element_1": "master_1"}, inplace=True)
                        if 'element_2' in df_master.columns.to_list():
                            df_master.rename(columns={"element_2": "master_2"}, inplace=True)
                        if 'element_3' in df_master.columns.to_list():
                            df_master.rename(columns={"element_3": "master_3"}, inplace=True)
                        if 'element_4' in df_master.columns.to_list():
                            df_master.rename(columns={"element_4": "master_4"}, inplace=True)

                        master = dict_master[df_master['label'][0]]
                        if 'master_1' in df_master.columns.to_list():
                            master_1 = df_master['master_1'][0]
                        else:
                            master_1 = None
                        if 'master_2' in df_master.columns.to_list():
                            master_2 = df_master['master_2'][0]
                        else:
                            master_2 = None
                        if 'master_3' in df_master.columns.to_list():
                            master_3 = df_master['master_3'][0]
                        else:
                            master_3 = None
                        if 'master_4' in df_master.columns.to_list():
                            master_4 = df_master['master_4'][0]
                        else:
                            master_4 = None

                        df_elements = df_final.iloc[1:].copy()

                        df_elements.loc[:,'master'] = master
                        df_elements.loc[:,'test_date'] = import_date
                        df_elements.loc[:,'user_test'] = user
                        df_elements.loc[:,'master_1'] = master_1
                        df_elements.loc[:,'master_2'] = master_2
                        df_elements.loc[:,'master_3'] = master_3
                        df_elements.loc[:,'master_4'] = master_4

                        df_elements['sensor'] = df_elements['sensor'].replace('A385', 'PT100')
                        df_elements['num_order'] = df_elements['label'].apply(lambda x: 'P-' + x[1:3] + '/' + x[3:6] if x[0] == 'P' else ('PA-' + x[1:3] + '/' + x[3:6] if x[0] == 'A' else 'NO PEDIDO'))
                        df_elements['tag'] = df_elements.index
                        df_elements['folder_data'] = subfolder

                        list_folders = df_elements['folder_data'].unique().tolist()

                    #Reading each row and inserting data in table
                        for name_folder in list_folders:
                            sql_check = f"SELECT * FROM verification.calibration_thermoelements WHERE folder_data = '{name_folder}'"
                            cur.execute(sql_check)
                            results = cur.fetchall()

                            if len(results) == 0:
                                df_filtrado = df_elements.loc[df_elements['folder_data'] == name_folder]
                            # Creating SQL sentence
                                for index, row in df_filtrado.iterrows():
                                    name_folder = row['folder_data']
                                    columns_values = [(column, row[column]) for column in df_filtrado.columns if not pd.isnull(row[column])]

                                # Creating string for columns names and values
                                    columns = ', '.join([column for column, _ in columns_values])
                                    values = ', '.join([f"'{values}'" if column in ['master_1','master_2','master_3','master_4','element_1','element_2','element_3','element_4'] and values is not None else f"'{values}'" for column, values in columns_values])

                                # Creating insertion query and executing it
                                    sql_insertion = f"INSERT INTO verification.calibration_thermoelements ({columns}) VALUES ({values})"
                                    cur.execute(sql_insertion)

                # close communication with the PostgreSQL database server
                    cur.close()
                # commit the changes
                    conn.commit()

                    shutil.rmtree(subfolder_path)

                except (Exception, psycopg2.DatabaseError) as error:
                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("ERP EIPSA")
                    dlg.setText("Ha ocurrido el siguiente error en la carpeta " + subfolder + ":\n"
                                + str(error))
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                    dlg.exec()
                    del dlg, new_icon
                finally:
                    if conn is not None:
                        conn.close()

            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("Importar Calibraciones")
            dlg.setText("Importación completada")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Information)
            dlg.exec()
            del dlg, new_icon

            self.query_calibration()

# Function to delete all filters when tool button is clicked
    def delete_allFilters(self):
        columns_number=self.model.columnCount()
        for index in range(columns_number):
            if index in self.proxy.filters:
                del self.proxy.filters[index]
            self.model.setIconColumnHeader(index, '')

        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.checkbox_filters = {}

        self.proxy.invalidateFilter()
        self.tableEditCalibration.setModel(None)
        self.tableEditCalibration.setModel(self.proxy)

        # Getting the unique values for each column of the model
        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            if column not in self.checkbox_states:
                self.checkbox_states[column] = {}
                self.checkbox_states[column]['Seleccionar todo'] = True
                for row in range(self.model.rowCount()):
                    value = self.model.record(row).value(column)
                    if value not in list_valuesUnique:
                        if isinstance(value, QtCore.QDate):
                            value=value.toString("dd/MM/yyyy")
                        list_valuesUnique.append(str(value))
                        self.checkbox_states[column][value] = True
                self.dict_valuesuniques[column] = list_valuesUnique

        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function to save changes into database
    def saveChanges(self):
        self.model.submitAll()

        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            for row in range(self.model.rowCount()):
                value = self.model.record(row).value(column)
                if value not in list_valuesUnique:
                    if isinstance(value, QtCore.QDate):
                        value=value.toString("dd/MM/yyyy")
                    list_valuesUnique.append(str(value))
                    if value not in self.checkbox_states[column]:
                        self.checkbox_states[column][value] = True
            self.dict_valuesuniques[column] = list_valuesUnique

# Function to load table and setting in the window
    def query_calibration(self):
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []

        self.model.setTable("verification.calibration_thermoelements")

        self.tableEditCalibration.setModel(None)
        self.tableEditCalibration.setModel(self.proxy)
        self.model.select()

        self.proxy.setSourceModel(self.model)
        self.tableEditCalibration.setModel(self.proxy)

        columns_number=self.model.columnCount()
        for column in range(columns_number):
            self.tableEditCalibration.setItemDelegateForColumn(column, None)

        self.tableEditCalibration.setItemDelegate(AlignDelegate(self.tableEditCalibration))
        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(columns_number-1,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        if self.username == 'm.gil':
            self.tableEditCalibration.setStyleSheet("gridline-color: rgb(128, 128, 128);")
            self.tableEditCalibration.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid white;}")
            self.tableEditCalibration.verticalHeader().setStyleSheet("::section{font: 10pt; background-color: #121212; border: 0.5px solid white;}")
        else:
            self.tableEditCalibration.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")
        self.tableEditCalibration.setObjectName("tableEditCalibration")
        self.gridLayout_2.addWidget(self.tableEditCalibration, 3, 0, 1, 1)
        self.tableEditCalibration.setSortingEnabled(False)
        self.tableEditCalibration.horizontalHeader().sectionDoubleClicked.connect(self.on_view_horizontalHeader_sectionClicked)
        self.tableEditCalibration.horizontalHeader().customContextMenuRequested.connect(self.showColumnContextMenu)
        self.tableEditCalibration.horizontalHeader().setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.tableEditCalibration.sortByColumn(0, Qt.SortOrder.AscendingOrder)

    # Change all column names
        headers_names = ["ID", "Pedido", "Tag", "Label", "Sensor", "Wire", "Patrón", "Fecha",
                    "User", "Clase", "N.C. Bobina", "N.C. Bulbo", "CA", "Aisl. Caliente", "Cant. Prueba",
                    "Cant. Pedido", "Notas", "Patrón 1", "Elemento 1", "Error 1", "Tolerancia 1", "Patrón 2",
                    "Elemento 2", "Error 2", "Tolerancia 2", "Patrón 3", "Elemento 3", "Error 3", "Tolerancia 3", 
                    "Patrón 4", "Elemento 4", "Error 4", "Tolerancia 4", "Carpeta"]

        self.model.setAllColumnHeaders(headers_names)

    # Getting the unique values for each column of the model
        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            if column not in self.checkbox_states:
                self.checkbox_states[column] = {}
                self.checkbox_states[column]['Seleccionar todo'] = True
                for row in range(self.model.rowCount()):
                    value = self.model.record(row).value(column)
                    if value not in list_valuesUnique:
                        if isinstance(value, QtCore.QDate):
                            value=value.toString("dd/MM/yyyy")
                        list_valuesUnique.append(str(value))
                        self.checkbox_states[column][value] = True
                self.dict_valuesuniques[column] = list_valuesUnique

        self.selection_model = self.tableEditCalibration.selectionModel()
        self.selection_model.selectionChanged.connect(self.countSelectedCells)

        self.tableEditCalibration.sortByColumn(7, Qt.SortOrder.DescendingOrder)

# Function when header is clicked
    def on_view_horizontalHeader_sectionClicked(self, logicalIndex):
        self.logicalIndex = logicalIndex
        self.menuValues = QtWidgets.QMenu(self)
        self.signalMapper = QtCore.QSignalMapper(self.tableEditCalibration)

        valuesUnique_view = []
        for row in range(self.tableEditCalibration.model().rowCount()):
            index = self.tableEditCalibration.model().index(row, self.logicalIndex)
            value = index.data(Qt.ItemDataRole.DisplayRole)
            if value not in valuesUnique_view:
                if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
                valuesUnique_view.append(value)

        actionSortAscending = QtGui.QAction("Ordenar Ascendente", self.tableEditCalibration)
        actionSortAscending.triggered.connect(self.on_actionSortAscending_triggered)
        self.menuValues.addAction(actionSortAscending)
        actionSortDescending = QtGui.QAction("Ordenar Descendente", self.tableEditCalibration)
        actionSortDescending.triggered.connect(self.on_actionSortDescending_triggered)
        self.menuValues.addAction(actionSortDescending)
        self.menuValues.addSeparator()

        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro", self.tableEditCalibration)
        actionDeleteFilterColumn.triggered.connect(self.on_actionDeleteFilterColumn_triggered)
        self.menuValues.addAction(actionDeleteFilterColumn)
        self.menuValues.addSeparator()

        actionTextFilter = QtGui.QAction("Buscar...", self.tableEditCalibration)
        actionTextFilter.triggered.connect(self.on_actionTextFilter_triggered)
        self.menuValues.addAction(actionTextFilter)
        self.menuValues.addSeparator()

        scroll_menu = QtWidgets.QScrollArea()
        if self.username == 'm.gil':
            scroll_menu.setStyleSheet("background-color: #121212; color: rgb(255, 255, 255)")
        else:
            scroll_menu.setStyleSheet("background-color: rgb(255, 255, 255)")
        scroll_menu.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget(scroll_menu)
        scroll_menu.setWidget(scroll_widget)
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        checkbox_all_widget = QtWidgets.QCheckBox('Seleccionar todo')

        if not self.checkbox_states[self.logicalIndex]['Seleccionar todo'] == True:
            checkbox_all_widget.setChecked(False)
        else:
            checkbox_all_widget.setChecked(True)
        
        checkbox_all_widget.toggled.connect(lambda checked, name='Seleccionar todo': self.on_select_all_toggled(checked, name))

        scroll_layout.addWidget(checkbox_all_widget)
        self.action_checkbox_map['Seleccionar todo'] = checkbox_all_widget

        if len(self.dict_ordersort) != 0 and self.logicalIndex in self.dict_ordersort:
            list_uniquevalues = sorted(list(set(self.dict_valuesuniques[self.logicalIndex])))
        else:
            list_uniquevalues = sorted(list(set(valuesUnique_view)))

        for actionName in list_uniquevalues:
            checkbox_widget = QtWidgets.QCheckBox(str(actionName))

            if self.logicalIndex not in self.checkbox_filters:
                checkbox_widget.setChecked(True)
            elif actionName not in self.checkbox_filters[self.logicalIndex]:
                checkbox_widget.setChecked(False)
            else:
                checkbox_widget.setChecked(True)

            checkbox_widget.toggled.connect(lambda checked, name=actionName: self.on_checkbox_toggled(checked, str(name)))

            scroll_layout.addWidget(checkbox_widget)
            self.action_checkbox_map[actionName] = checkbox_widget

        action_scroll_menu = QtWidgets.QWidgetAction(self.menuValues)
        action_scroll_menu.setDefaultWidget(scroll_menu)
        self.menuValues.addAction(action_scroll_menu)

        self.menuValues.addSeparator()

        accept_button = QtGui.QAction("ACEPTAR", self.tableEditCalibration)
        accept_button.triggered.connect(self.menu_acceptbutton_triggered)

        cancel_button = QtGui.QAction("CANCELAR", self.tableEditCalibration)
        cancel_button.triggered.connect(self.menu_cancelbutton_triggered)

        self.menuValues.addAction(accept_button)
        self.menuValues.addAction(cancel_button)

        if self.username == 'm.gil':
            self.menuValues.setStyleSheet("QMenu { color: white; }"
                                            "QMenu { background-color: #121212; }"
                                            "QMenu::item:selected { background-color: #33bdef; }"
                                            "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")
        else:
            self.menuValues.setStyleSheet("QMenu { color: black; }"
                                            "QMenu { background-color: rgb(255, 255, 255); }"
                                            "QMenu::item:selected { background-color: #33bdef; }"
                                            "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

        headerPos = self.tableEditCalibration.mapToGlobal(self.tableEditCalibration.horizontalHeader().pos())        

        posY = headerPos.y() + self.tableEditCalibration.horizontalHeader().height()
        scrollX = self.tableEditCalibration.horizontalScrollBar().value()
        xInView = self.tableEditCalibration.horizontalHeader().sectionViewportPosition(logicalIndex)
        posX = headerPos.x() + xInView - scrollX

        self.menuValues.exec(QtCore.QPoint(posX, posY))

# Function when cancel button of menu is clicked
    def menu_cancelbutton_triggered(self):
        self.menuValues.hide()

# Function when accept button of menu is clicked
    def menu_acceptbutton_triggered(self):
        for column, filters in self.checkbox_filters.items():
            if filters:
                self.proxy.setFilter(filters, column)
            else:
                self.proxy.setFilter(None, column)

        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function when select all checkbox is clicked
    def on_select_all_toggled(self, checked, action_name):
        filterColumn = self.logicalIndex
        imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
                checkbox_widget.setChecked(checked)
                self.checkbox_states[self.logicalIndex][checkbox_name] = checked

            if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
                self.model.setIconColumnHeader(filterColumn, icono)
            else:
                self.model.setIconColumnHeader(filterColumn, '')
        
        else:
            for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
                checkbox_widget.setChecked(checked)
                self.checkbox_states[self.logicalIndex][checkbox_widget.text()] = checked

# Function when checkbox of header menu is clicked
    def on_checkbox_toggled(self, checked, action_name):
        filterColumn = self.logicalIndex
        imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            if filterColumn not in self.checkbox_filters:
                self.checkbox_filters[filterColumn] = [action_name]
            else:
                if action_name not in self.checkbox_filters[filterColumn]:
                    self.checkbox_filters[filterColumn].append(action_name)
        else:
            if filterColumn in self.checkbox_filters and action_name in self.checkbox_filters[filterColumn]:
                self.checkbox_filters[filterColumn].remove(action_name)

        if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
            self.model.setIconColumnHeader(filterColumn, '')
        else:
            self.model.setIconColumnHeader(filterColumn, icono)

# Function to delete individual column filter
    def on_actionDeleteFilterColumn_triggered(self):
        filterColumn = self.logicalIndex
        if filterColumn in self.proxy.filters:
                del self.proxy.filters[filterColumn]
        self.model.setIconColumnHeader(filterColumn, '')
        self.proxy.invalidateFilter()

        self.tableEditCalibration.setModel(None)
        self.tableEditCalibration.setModel(self.proxy)

        if filterColumn in self.checkbox_filters:
            del self.checkbox_filters[filterColumn]

        self.checkbox_states[self.logicalIndex].clear()
        self.checkbox_states[self.logicalIndex]['Seleccionar todo'] = True
        for row in range(self.tableEditCalibration.model().rowCount()):
            value = self.model.record(row).value(filterColumn)
            if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
            self.checkbox_states[self.logicalIndex][str(value)] = True

        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditCalibration.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function to order column ascending
    def on_actionSortAscending_triggered(self):
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.AscendingOrder
        self.tableEditCalibration.sortByColumn(sortColumn, sortOrder)

# Function to order column descending
    def on_actionSortDescending_triggered(self):
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.DescendingOrder
        self.tableEditCalibration.sortByColumn(sortColumn, sortOrder)

# Function when text is searched
    def on_actionTextFilter_triggered(self):
        filterColumn = self.logicalIndex
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle('Buscar')
        clickedButton=dlg.exec()

        if clickedButton == 1:
            stringAction = dlg.textValue()
            if re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', stringAction):
                stringAction=QtCore.QDate.fromString(stringAction,"dd/MM/yyyy")
                stringAction=stringAction.toString("yyyy-MM-dd")

            filterString = QtCore.QRegularExpression(stringAction, QtCore.QRegularExpression.PatternOption(0))
            # del self.proxy.filters[filterColumn]
            self.proxy.setFilter([stringAction], filterColumn)

            imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
            icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
            self.model.setIconColumnHeader(filterColumn, icono)

# Function to hide column when action clicked
    def hide_column(self):
        filterColumn = self.logicalIndex
        self.tableEditCalibration.setColumnHidden(filterColumn, True)
        self.hiddencolumns.append(filterColumn)

# Function to hide selected columns
    def hideSelectedColumns(self):
        selected_columns = set()
        header = self.tableEditCalibration.horizontalHeader()
        for index in header.selectionModel().selectedColumns():
            selected_columns.add(index.column())

        for column in selected_columns:
            self.tableEditCalibration.setColumnHidden(column, True)
            self.hiddencolumns.append(column)

        self.context_menu.close()

# Function to show all hidden columns
    def show_columns(self):
        for column in self.hiddencolumns:
            self.tableEditCalibration.setColumnHidden(column, False)
        self.hiddencolumns.clear()

# Function to export data to excel
    def exporttoexcel(self):
        if self.proxy.rowCount() == 0:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("Exportar")
            dlg.setText("No hay datos cargados")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg.exec()
            del dlg,new_icon
        else:
            final_data = []

            visible_columns = [col for col in range(self.model.columnCount()) if not self.tableEditCalibration.isColumnHidden(col)]
            visible_headers = self.model.getColumnHeaders(visible_columns)
            for row in range(self.proxy.rowCount()):
                tag_data = []
                for column in visible_columns:
                    value = self.proxy.data(self.proxy.index(row, column))
                    if isinstance(value, QDate):
                        value = value.toString("dd/MM/yyyy")
                    tag_data.append(value)
                final_data.append(tag_data)

            final_data.insert(0, visible_headers)
            df = pd.DataFrame(final_data)
            df.columns = df.iloc[0]
            df = df[1:]

            output_path = asksaveasfilename(defaultextension=".xlsx", filetypes=[("Archivos de Excel", "*.xlsx")], title="Guardar archivo de Excel")
            if output_path:
                df.to_excel(output_path, index=False, header=True)

# Function to enable copy and paste cells
    def keyPressEvent(self, event):
        if event.key() == QtCore.Qt.Key.Key_Delete:
            selected_indexes = self.tableEditCalibration.selectionModel().selectedIndexes()
            if not selected_indexes:
                return
            
            model = self.tableEditCalibration.model()
            model_indexes = [model.mapToSource(index) for index in selected_indexes]

            for index in model_indexes:
                self.model.setData(index, None)

        elif event.matches(QKeySequence.StandardKey.Copy):
            selected_indexes = self.tableEditCalibration.selectionModel().selectedIndexes()
            if not selected_indexes:
                return
            
            model = self.tableEditCalibration.model()
            model_indexes = [model.mapToSource(index) for index in selected_indexes]

            mime_data = QMimeData()
            data = bytearray()

            for index in model_indexes:
                data += str(self.model.data(index)).encode('utf-8') + b'\t'

            mime_data.setData("text/plain", data)

            clipboard = QApplication.clipboard()
            clipboard.setMimeData(mime_data)

        elif event.matches(QKeySequence.StandardKey.Paste):
            if self.tableEditCalibration.selectionModel() != None:

                clipboard = QApplication.clipboard()
                mime_data = clipboard.mimeData()

                if not mime_data.hasFormat("text/plain"):
                    return

                data = mime_data.data("text/plain").data()
                values = data.split(b'\t')

                selected_indexes = self.tableEditCalibration.selectionModel().selectedIndexes()
                if not selected_indexes:
                    return
                
                model = self.tableEditCalibration.model()
                model_indexes = [model.mapToSource(index) for index in selected_indexes]

                if len(values) == 2:
                    for index in model_indexes:
                        self.model.setData(index, values[0].decode('utf-8'))
                else:
                    for index, value in zip(model_indexes, values):
                        self.model.setData(index, value.decode('utf-8'))

            self.saveChanges()

        super().keyPressEvent(event)

# Function to get the text of the selected cells
    def get_selected_text(self, indexes):
        if len(indexes) == 1:  # For only one cell selected
            index = indexes[0]
            cell_data = index.data(Qt.ItemDataRole.DisplayRole)
            return cell_data
        else:
            rows = set()
            cols = set()
            for index in indexes:
                rows.add(index.row())
                cols.add(index.column())

            text_doc = QTextDocument()
            cursor = QTextCursor(text_doc)

            for row in sorted(rows):
                for col in sorted(cols):
                    index = self.model.index(row, col)  
                    cell_data = index.data(Qt.ItemDataRole.DisplayRole)
                    cursor.insertText(str(cell_data))
                    cursor.insertText('\t')
                cursor.insertText('\n')

            return text_doc.toPlainText()

# Function to count selected cells and sum its values
    def countSelectedCells(self):
        if len(self.tableEditCalibration.selectedIndexes()) > 1:
            locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

            sum_value = sum([self.euro_string_to_float(str(ix.data())) if re.match(r'^[\d.,]+\sÇ$', str(ix.data())) else float(str(ix.data()).replace(',', '.')) if str(ix.data()).replace(',', '.').replace('.', '', 1).isdigit() else 0 for ix in self.tableEditCalibration.selectedIndexes()])
            count_value = len([ix for ix in self.tableEditCalibration.selectedIndexes() if ix.data() != ""])
            if sum_value > 0:
                self.label_SumItems.setText("Suma:")
                self.label_SumValue.setText(locale.format_string("%.2f", sum_value, grouping=True))
            if count_value > 0:
                self.label_CountItems.setText("Recuento:")
                self.label_CountValue.setText(str(count_value))
        else:
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

# Function to format money string values
    def euro_string_to_float(self, euro_str):
        match = re.match(r'^([\d.,]+)\s€$', euro_str)
        if match:
            number_str = match.group(1)
            number_str = number_str.replace('.', '').replace(',', '.')
            return float(number_str)
        else:
            return 0.0

# Function for creating context menu for hiding columns
    def createContextMenu(self):
        self.context_menu = QtWidgets.QMenu(self)
        hide_columns_action = self.context_menu.addAction("Ocultar Columnas")
        hide_columns_action.triggered.connect(self.hideSelectedColumns)
        if self.username == 'm.gil':
            self.context_menu.setStyleSheet("QMenu { color: white; }"
                                            "QMenu { background-color: #121212; }"
                                            "QMenu::item:selected { background-color: #33bdef; }"
                                            "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")
        else:
            self.context_menu.setStyleSheet("QMenu { color: black; }"
                                            "QMenu { background-color: rgb(255, 255, 255); }"
                                            "QMenu::item:selected { background-color: #33bdef; }"
                                            "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

# Function to show context menu when right-click for hiding columns
    def showColumnContextMenu(self, pos):
        header = self.tableEditCalibration.horizontalHeader()
        column = header.logicalIndexAt(pos)
        self.context_menu.exec(self.tableEditCalibration.mapToGlobal(pos))

# Function to delete register of database
    def delete_register(self):
        selection_model = self.tableEditCalibration.selectionModel()

        if not selection_model.hasSelection():
            return

        model = self.tableEditCalibration.model()

        id_values = []
        selected_indexes = selection_model.selectedRows()
        for index in selected_indexes:
            # Obtaining first columns values
            item_index = model.index(index.row(), 0)
            if item_index.isValid():
                value = model.data(item_index)
                id_values.append(value)

        if len(id_values) != 0:
            dlg_yes_no = QtWidgets.QMessageBox()
            new_icon_yes_no = QtGui.QIcon()
            new_icon_yes_no.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg_yes_no.setWindowIcon(new_icon_yes_no)
            dlg_yes_no.setWindowTitle("ERP EIPSA")
            dlg_yes_no.setText("¿Estás seguro de que deseas eliminar los registros?\n")
            dlg_yes_no.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg_yes_no.setStandardButtons(QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No)
            result = dlg_yes_no.exec()
            if result == QtWidgets.QMessageBox.StandardButton.Yes:
                conn = None
                try:
                # read the connection parameters
                    params = config()
                # connect to the PostgreSQL server
                    conn = psycopg2.connect(**params)
                    cur = conn.cursor()
                # execution of commands
                    commands_delete = ("""DELETE FROM verification.calibration_thermoelements
                                        WHERE id = %s""")
                    for id_value in id_values:
                        data = (id_value,)
                        cur.execute(commands_delete, data)

                # close communication with the PostgreSQL database server
                    cur.close()
                # commit the changes
                    conn.commit()

                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("Caibraciones")
                    dlg.setText("Registros eliminados con éxito")
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Information)
                    dlg.exec()
                    del dlg,new_icon

                    self.query_calibration()

                except (Exception, psycopg2.DatabaseError) as error:
                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("ERP EIPSA")
                    dlg.setText("Ha ocurrido el siguiente error:\n"
                                + str(error))
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                    dlg.exec()
                    del dlg, new_icon
                finally:
                    if conn is not None:
                        conn.close()

            del dlg_yes_no, new_icon_yes_no

# Function to print certificate
    def print_certificate(self):
        self.model.submitAll()
        self.saveChanges()
        from CalibrationPrintCertificate_Window import Ui_CalibrationPrintCertificate_Window
        self.CalibrationPrintCertificate_Window=QtWidgets.QMainWindow()
        self.ui=Ui_CalibrationPrintCertificate_Window(self.username)
        self.ui.setupUi(self.CalibrationPrintCertificate_Window)
        self.CalibrationPrintCertificate_Window.show()




# if __name__ == "__main__":
#     import sys
#     app = QtWidgets.QApplication(sys.argv)
#     config_obj = configparser.ConfigParser()
#     config_obj.read(r"C:\Program Files\ERP EIPSA\database.ini")
#     dbparam = config_obj["postgresql"]
#     # set your parameters for the database connection URI using the keys from the configfile.ini
#     user_database = dbparam["user"]
#     password_database = dbparam["password"]

#     db = createConnection(user_database, password_database)
#     if not db:
#         sys.exit()

#     CalibrationThermoElements_Window = Ui_Calibration_ThermoElements_Window(db, 'm.gil')
#     CalibrationThermoElements_Window.show()
#     sys.exit(app.exec())