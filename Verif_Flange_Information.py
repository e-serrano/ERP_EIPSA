# Form implementation generated from reading ui file 'EditTags_Commercial_Window.ui'
#
# Created by: PyQt6 UI code generator 6.4.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6 import QtSql
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import Qt, QDate, QUrl
from PyQt6.QtGui import QKeySequence, QTextDocument, QTextCursor
import re
import configparser
from Database_Connection import createConnection
from config import config
import psycopg2
import locale
import os
from datetime import *
import pandas as pd
from tkinter.filedialog import asksaveasfilename
from fpdf import FPDF
from PDF_Viewer import PDF_Viewer
from tkinter.filedialog import *
from PIL import Image, ExifTags

basedir = r"\\nas01\DATOS\Comunes\EIPSA-ERP"


def imagen_to_base64(imagen):
    """
    Converts an image in PNG format to a base64 encoded string.

    Args:
        imagen: An instance of QImage or QPixmap to be converted.
    Return: 
        A base64 encoded string representing the image in PNG format.
    """
    buffer = QtCore.QBuffer()
    buffer.open(QtCore.QIODevice.OpenModeFlag.WriteOnly)
    imagen.save(buffer, ".png")
    base64_data = buffer.data().toBase64().data().decode()
    return base64_data



class AlignDelegate(QtWidgets.QStyledItemDelegate):
    """
    A custom item delegate for aligning cell content in a QTableView or QTableWidget to the center.

    Inherits from:
        QtWidgets.QStyledItemDelegate: Provides custom rendering and editing for table items.

    """
    def initStyleOption(self, option, index):
        """
        Initializes the style option for the item, setting its display alignment to center.

        Args:
            option (QtWidgets.QStyleOptionViewItem): The style option to initialize.
            index (QtCore.QModelIndex): The model index of the item.
        """
        super(AlignDelegate, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

class CustomTableWidget(QtWidgets.QTableWidget):
    """
    Custom QTableWidget that supports filtering and sorting features.

    Attributes:
        list_filters (list): Stores filters applied to the table.
        column_filters (dict): Maps column indices to sets of applied filters.
        column_actions (dict): Maps column indices to actions related to columns.
        checkbox_states (dict): Stores the state of checkboxes for filtering.
        rows_hidden (dict): Maps column indices to sets of hidden row indices.
        general_rows_to_hide (set): Set of row indices that are hidden across the table.
    """
    def __init__(self, parent=None):
        """
        Initializes the CustomTableWidget.

        Sets up the initial state of the widget, including filters, checkbox states, 
        and hidden rows.

        Args:
            parent (QWidget, optional): The parent widget of this table. Defaults to None.
        """
        super().__init__(parent)
        self.list_filters=[]
        self.column_filters = {}
        self.column_actions = {}
        self.checkbox_states = {}
        self.rows_hidden = {}
        self.general_rows_to_hide = set()

# Function to show the menu
    def show_unique_values_menu(self, column_index, header_pos, header_height):
        """
        Displays a context menu for unique values in a specified column.

        The menu includes options to remove filters, sort the column, and filter by text. 
        It also allows the user to select/unselect unique values via checkboxes.

        Args:
            column_index (int): The index of the column for which the menu is displayed.
            header_pos (QPoint): The position of the header in the viewport.
            header_height (int): The height of the header.
        """
        menu = QtWidgets.QMenu(self)
        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro")
        actionDeleteFilterColumn.triggered.connect(lambda: self.delete_filter(column_index))
        menu.addAction(actionDeleteFilterColumn)
        menu.addSeparator()
        actionOrderAsc = menu.addAction("Ordenar Ascendente")
        actionOrderAsc.triggered.connect(lambda: self.sortByColumn(column_index, QtCore.Qt.SortOrder.AscendingOrder))
        actionOrderDesc = menu.addAction("Ordenar Descendente")
        actionOrderDesc.triggered.connect(lambda: self.sortByColumn(column_index, QtCore.Qt.SortOrder.DescendingOrder))
        menu.addSeparator()
        actionFilterByText = menu.addAction("Buscar Texto")
        actionFilterByText.triggered.connect(lambda: self.filter_by_text(column_index))
        menu.addSeparator()

        menu.setStyleSheet("QMenu::item:selected { background-color: #33bdef; }"
                        "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

        if column_index not in self.column_filters:
            self.column_filters[column_index] = set()

        scroll_menu = QtWidgets.QScrollArea()
        scroll_menu.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget(scroll_menu)
        scroll_menu.setWidget(scroll_widget)
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        checkboxes = []

        select_all_checkbox = QtWidgets.QCheckBox("Seleccionar todo")
        if column_index in self.checkbox_states:
            select_all_checkbox.setCheckState(QtCore.Qt.CheckState(self.checkbox_states[column_index].get("Seleccionar todo", QtCore.Qt.CheckState(2))))
        else:
            select_all_checkbox.setCheckState(QtCore.Qt.CheckState(2))
        scroll_layout.addWidget(select_all_checkbox)
        checkboxes.append(select_all_checkbox)

        unique_values = self.get_unique_values(column_index)
        filtered_values = self.get_filtered_values()

        for value in sorted(unique_values):
            checkbox = QtWidgets.QCheckBox(value)
            if select_all_checkbox.isChecked(): 
                checkbox.setCheckState(QtCore.Qt.CheckState(2))
            else:
                if column_index in self.checkbox_states and value in self.checkbox_states[column_index]:
                    checkbox.setCheckState(QtCore.Qt.CheckState(self.checkbox_states[column_index][value]))
                elif filtered_values is None or value in filtered_values[column_index]:
                    checkbox.setCheckState(QtCore.Qt.CheckState(2))
                else:
                    checkbox.setCheckState(QtCore.Qt.CheckState(0))
            scroll_layout.addWidget(checkbox)
            checkboxes.append(checkbox)

        select_all_checkbox.stateChanged.connect(lambda state: self.set_all_checkboxes_state(checkboxes, state, column_index))

        for value, checkbox in zip(sorted(unique_values), checkboxes[1:]):
            checkbox.stateChanged.connect(lambda checked, value=value, checkbox=checkbox: self.apply_filter(column_index, value, checked))

    # Action for drop down menu and adding scroll area as widget
        action_scroll_menu = QtWidgets.QWidgetAction(menu)
        action_scroll_menu.setDefaultWidget(scroll_menu)
        menu.addAction(action_scroll_menu)

        menu.exec(header_pos - QtCore.QPoint(0, header_height))

# Function to delete filter on selected column
    def delete_filter(self,column_index):
        """
        Removes the filter applied to the specified column.

        Unhides previously hidden rows and resets the checkbox state for the column.

        Args:
            column_index (int): The index of the column from which to delete the filter.
        """
        if column_index in self.column_filters:
            del self.column_filters[column_index]
        if column_index in self.checkbox_states:
            del self.checkbox_states[column_index]
        if column_index in self.rows_hidden:
            for item in self.rows_hidden[column_index]:
                self.setRowHidden(item, False)
                if item in self.general_rows_to_hide:
                    self.general_rows_to_hide.remove(item)
            del self.rows_hidden[column_index]
        header_item = self.horizontalHeaderItem(column_index)
        header_item.setIcon(QtGui.QIcon())

# Function to set all checkboxes state
    def set_all_checkboxes_state(self, checkboxes, state, column_index):
        """
        Sets the state of all checkboxes in the filter menu for a specific column.

        Args:
            checkboxes (list): List of checkboxes to update.
            state (Qt.CheckState): The desired state for the checkboxes.
            column_index (int): The index of the column for which the checkboxes are set.
        """
        if column_index not in self.checkbox_states:
            self.checkbox_states[column_index] = {}

        for checkbox in checkboxes:
            checkbox.setCheckState(QtCore.Qt.CheckState(state))

        self.checkbox_states[column_index]["Seleccionar todo"] = state

# Function to apply filters to table
    def apply_filter(self, column_index, value, checked, text_filter=None, filter_dialog=None):
        """
        Applies a filter to the specified column based on the checkbox state and optional text filter.

        Args:
            column_index (int): The index of the column to filter.
            value (str): The value to filter by.
            checked (bool): Indicates if the filter should be applied (True) or removed (False).
            text_filter (str, optional): Additional text filter for filtering items. Defaults to None.
            filter_dialog (QDialog, optional): The dialog used for the text filter. Defaults to None.
        """
        if column_index not in self.column_filters:
            self.column_filters[column_index] = set()

        if text_filter is None:
            if value is None:
                self.column_filters[column_index] = set()
            elif checked:
                self.column_filters[column_index].add(value)
            elif value in self.column_filters[column_index]:
                self.column_filters[column_index].remove(value)

        rows_to_hide = set()
        for row in range(self.rowCount()):
            show_row = True

            # Check filters for all columns
            for col, filters in self.column_filters.items():
                item = self.item(row, col)
                if item:
                    item_value = item.text()
                    if text_filter is None:
                        if filters and item_value not in filters:
                            show_row = False
                            break

        # Filtering by text
            if text_filter is not None:
                filter_dialog.accept()
                item = self.item(row, column_index)
                if item:
                    if text_filter.upper() in item.text().upper():
                        self.column_filters[column_index].add(item.text())
                    else:
                        show_row = False

            if not show_row:
                if row not in self.general_rows_to_hide:
                    self.general_rows_to_hide.add(row)
                    rows_to_hide.add(row)
            else:
                if row in self.general_rows_to_hide:
                    self.general_rows_to_hide.remove(row)

        # Update hidden rows for this column depending on checkboxes
        if checked and text_filter is None:
            if column_index not in self.rows_hidden:
                self.rows_hidden[column_index] = set(rows_to_hide)
            else:
                self.rows_hidden[column_index].update(rows_to_hide)

        # Update hidden rows for this column depending on filtered text
        if text_filter is not None and value is None:
            if column_index not in self.rows_hidden:
                self.rows_hidden[column_index] = set(rows_to_hide)
            else:
                self.rows_hidden[column_index].update(rows_to_hide)

        # Iterate over all rows to hide them as necessary
        for row in range(self.rowCount()):
            self.setRowHidden(row, row in self.general_rows_to_hide)

        header_item = self.horizontalHeaderItem(column_index)
        if len(self.general_rows_to_hide) > 0:
            header_item.setIcon(QtGui.QIcon(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))))
        else:
            header_item.setIcon(QtGui.QIcon())

# Function to apply filters to table based on a desired text
    def filter_by_text(self, column_index):
        """
        Opens a dialog for filtering the specified column by text input.

        Args:
            column_index (int): The index of the column to filter.
        """
        filter_dialog = QtWidgets.QDialog(self)
        filter_dialog.setWindowTitle("Filtrar por texto")
        
        label = QtWidgets.QLabel("Texto a filtrar:")
        text_input = QtWidgets.QLineEdit()
        
        filter_button = QtWidgets.QPushButton("Filtrar")
        filter_button.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 2px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        filter_button.clicked.connect(lambda: self.apply_filter(column_index, None, False, text_input.text(), filter_dialog))

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(label)
        layout.addWidget(text_input)
        layout.addWidget(filter_button)

        filter_dialog.setLayout(layout)
        filter_dialog.exec()

# Function to obtain the unique matching applied filters 
    def get_unique_values(self, column_index):
        """
        Retrieves unique values from the specified column, taking into account any active filters on other columns.

        Args:
            column_index (int): The index of the column from which to retrieve unique values.

        Returns:
            set: A set of unique values from the specified column that are visible based on the current filters.
        """
        unique_values = set()
        for row in range(self.rowCount()):
            show_row = True
            for col, filters in self.column_filters.items():
                if col != column_index:
                    item = self.item(row, col)
                    if item:
                        item_value = item.text()
                        if filters and item_value not in filters:
                            show_row = False
                            break
            if show_row:
                item = self.item(row, column_index)
                if item:
                    unique_values.add(item.text())
        return unique_values

# Function to get values filtered by all columns
    def get_filtered_values(self):
        """
        Gets the current filter values for all columns.

        Returns:
            dict: A dictionary where each key is a column index and the value is a set of filters applied to that column.
        """
        filtered_values = {}
        for col, filters in self.column_filters.items():
            filtered_values[col] = filters
        return filtered_values

# Function to sort column based on special datatypes
    def custom_sort(self, column, order):
        """
        Custom sorting method for date columns. Sorts the specified column based on date values.

        Args:
            column (int): The index of the column to sort.
            order (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        row_count = self.rowCount()

        indexes = list(range(row_count))
        indexes.sort(key=lambda i: QtCore.QDateTime.fromString(self.item(i, column).text(), "dd-MM-yyyy"))

        if order == QtCore.Qt.SortOrder.DescendingOrder:
            indexes.reverse()

        hidden_rows = [row for row in range(row_count) if self.isRowHidden(row)]

        rows = self.rowCount()
        for i in range(rows):
            self.insertRow(i)

        for new_row, old_row in enumerate(indexes):
            for col in range(self.columnCount()):
                item = self.takeItem(old_row + rows, col)
                self.setItem(new_row, col, item)

        for i in range(rows):
            self.removeRow(rows)

        for row in hidden_rows:
            self.setRowHidden(row, True)

# Function with the menu configuration
    def contextMenuEvent(self, event):
        """
        Handles the context menu event for the table. Shows a menu for filtering unique values when the header is right-clicked.

        Args:
            event (QEvent): The event triggered by the context menu action.
        """
        if self.horizontalHeader().visualIndexAt(event.pos().x()) >= 0:
            logical_index = self.horizontalHeader().logicalIndexAt(event.pos().x())
            header_pos = self.mapToGlobal(self.horizontalHeader().pos())
            header_height = self.horizontalHeader().height()
            self.show_unique_values_menu(logical_index, header_pos, header_height)
        else:
            super().contextMenuEvent(event)

class CustomPDF(FPDF):
    """
    Custom PDF class extending FPDF for advanced text handling.

    This class provides additional functionalities for creating PDF documents,
    specifically for managing multi-line text with fixed height.

    Methods:
        fixed_height_multicell(w, total_h, txt, align_mc, border='LR', fill=False):
            Outputs text in a multi-cell format with a fixed total height.
    """
    def fixed_height_multicell(self, w, total_h, txt, align_mc, border='LRB', fill=False):
        """
        Creates a multi-line cell with a fixed total height, dividing text into lines.

        Parameters:
            w (float): The width of the cell.
            total_h (float): The total height of the cell.
            txt (str): The text to be placed in the cell.
            align_mc (str): The alignment of the text.
            border (str, optional): Border settings for the cell. Defaults to ''.
            fill (bool, optional): Whether to fill the cell with color. Defaults to False.
        """
        words = txt.split() # Divide text in words
        lines = []
        line = ''
        for word in words:
            if self.get_string_width(line + word + ' ') > w - 0.5:
                lines.append(line) # Add line to line list and starts a new one
                line = word + ' '
            else:
                line += word + ' ' # Add word to actual line
        lines.append(line) # Add last line to line list
        
        line_height = total_h / len(lines) # Calculate height of each line to get a total height = total_h

        x, y = self.get_x(), self.get_y() # Save actual position

        for line in lines:
            # Print each line with the calculated height
            self.multi_cell(w, line_height, line, border, align_mc, fill)
            self.set_x(x)

        self.set_xy(x, y + total_h)

class Ui_Verif_Flange_Information_Window(QtWidgets.QMainWindow):
    """
    Main window class for managing workshop flange reviews, including data filtering, sorting,
    and handling flange-related operations.

    Attributes:
        model: The table model used to handle data for the flange revisions.
        proxy: A custom proxy model for filtering and sorting the data.
        db: The database connection object.
        flange_id: The ID of the flange being reviewed or modified.
        checkbox_states: Dictionary storing the states of checkboxes for filtering purposes.
        dict_valuesuniques: Dictionary holding unique values for each column in the table.
        dict_ordersort: Dictionary managing the sorting order of columns.
        hiddencolumns: List of columns that are hidden in the table view.
        variable: Holds the current variable being used for filtering or sorting.
        action_checkbox_map: Dictionary mapping actions to checkboxes for filtering.
        checkbox_filters: Dictionary of active filters applied through checkboxes.
        username: The username of the current user.
        pdf_viewer: An instance of a PDF viewer for displaying relevant documents.
    """
    def __init__(self, username):
        """
        Initializes the flange information window.

        Args:
            username: Username of the current user.
        """
        super().__init__()
        self.username = username
        self.image_path = None
        self.pdf_viewer = PDF_Viewer()
        self.setupUi(self)

    def setupUi(self, Verif_Flange_Information_Window):
        """
        Sets up the user interface for the Verif_Flange_Information_Window.

        Args:
            Verif_Flange_Information_Window (QtWidgets.QMainWindow): The main window for the UI setup.
        """
        Verif_Flange_Information_Window.setObjectName("Verif_Flange_Information_Window")
        Verif_Flange_Information_Window.resize(790, 595)
        Verif_Flange_Information_Window.setMinimumSize(QtCore.QSize(790, 595))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        Verif_Flange_Information_Window.setWindowIcon(icon)
        if self.username == 'm.gil':
            Verif_Flange_Information_Window.setStyleSheet("QWidget {\n"
    "background-color: #121212; color: rgb(255, 255, 255);\n"
    "}\n"
    "\n"
    ".QFrame {\n"
    "    border: 2px solid white;\n"
    "}\n"
    "\n"
    "QComboBox {\n"
    "border: 1px solid white;\n"
    "border-radius: 3px;\n"
    "}\n"
    "QPushButton {\n"
    "background-color: #33bdef;\n"
    "  border: 1px solid transparent;\n"
    "  border-radius: 3px;\n"
    "  color: #fff;\n"
    "  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
    "  font-size: 15px;\n"
    "  font-weight: 800;\n"
    "  line-height: 1.15385;\n"
    "  margin: 0;\n"
    "  outline: none;\n"
    "  padding: 2px .8em;\n"
    "  text-align: center;\n"
    "  text-decoration: none;\n"
    "  vertical-align: baseline;\n"
    "  white-space: nowrap;\n"
    "}\n"
    "\n"
    "QPushButton:hover {\n"
    "    background-color: #019ad2;\n"
    "    border-color: rgb(0, 0, 0);\n"
    "}\n"
    "\n"
    "QPushButton:pressed {\n"
    "    background-color: rgb(1, 140, 190);\n"
    "    border-color: rgb(255, 255, 255);\n"
    "}")
        else:
            Verif_Flange_Information_Window.setStyleSheet("QWidget {\n"
    "background-color: rgb(255, 255, 255);\n"
    "}\n"
    "\n"
    ".QFrame {\n"
    "    border: 2px solid black;\n"
    "}\n"
    "\n"
    "QPushButton {\n"
    "background-color: #33bdef;\n"
    "  border: 1px solid transparent;\n"
    "  border-radius: 3px;\n"
    "  color: #fff;\n"
    "  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
    "  font-size: 15px;\n"
    "  font-weight: 800;\n"
    "  line-height: 1.15385;\n"
    "  margin: 0;\n"
    "  outline: none;\n"
    "  padding: 2px .8em;\n"
    "  text-align: center;\n"
    "  text-decoration: none;\n"
    "  vertical-align: baseline;\n"
    "  white-space: nowrap;\n"
    "}\n"
    "\n"
    "QPushButton:hover {\n"
    "    background-color: #019ad2;\n"
    "    border-color: rgb(0, 0, 0);\n"
    "}\n"
    "\n"
    "QPushButton:pressed {\n"
    "    background-color: rgb(1, 140, 190);\n"
    "    border-color: rgb(255, 255, 255);\n"
    "}")
        self.centralwidget = QtWidgets.QWidget(parent=Verif_Flange_Information_Window)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_2.setVerticalSpacing(10)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.hcab=QtWidgets.QHBoxLayout()
        self.hcab.setObjectName("hcab")
        self.toolPDF = QtWidgets.QToolButton(self.frame)
        self.toolPDF.setObjectName("PDF_Button")
        self.toolPDF.setToolTip("Imprimir PDF")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Adobe_PDF.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolPDF.setIcon(icon)
        self.toolPDF.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolPDF)

        if self.username == 'm.gil':
            self.toolPDF.setStyleSheet("border: 1px solid white;")

        self.hcabspacer6=QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer6)
        self.gridLayout_2.addLayout(self.hcab, 0, 0, 1, 1)

        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 1, 0, 1, 1)
        self.label_standard = QtWidgets.QLabel(parent=self.frame)
        self.label_standard.setMinimumSize(QtCore.QSize(40, 50))
        self.label_standard.setObjectName("label_standard")
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        self.label_standard.setFont(font)
        self.label_standard.setText('Norma:')
        self.gridLayout_2.addWidget(self.label_standard, 2, 0, 1, 1)
        self.label_size = QtWidgets.QLabel(parent=self.frame)
        self.label_size.setMinimumSize(QtCore.QSize(40, 50))
        self.label_size.setObjectName("label_size")
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        self.label_size.setFont(font)
        self.label_size.setText('Tamaño:')
        self.gridLayout_2.addWidget(self.label_size, 2, 1, 1, 1)
        self.label_rating = QtWidgets.QLabel(parent=self.frame)
        self.label_rating.setMinimumSize(QtCore.QSize(40, 50))
        self.label_rating.setObjectName("label_rating")
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        self.label_rating.setFont(font)
        self.label_rating.setText('Rating:')
        self.gridLayout_2.addWidget(self.label_rating, 2, 2, 1, 1)
        self.label_facing = QtWidgets.QLabel(parent=self.frame)
        self.label_facing.setMinimumSize(QtCore.QSize(40, 50))
        self.label_facing.setObjectName("label_facing")
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        self.label_facing.setFont(font)
        self.label_facing.setText('Facing:')
        self.gridLayout_2.addWidget(self.label_facing, 2, 3, 1, 1)
        self.label_schedule = QtWidgets.QLabel(parent=self.frame)
        self.label_schedule.setMinimumSize(QtCore.QSize(40, 50))
        self.label_schedule.setObjectName("label_schedule")
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        self.label_schedule.setFont(font)
        self.label_schedule.setText('Schedule:')
        self.gridLayout_2.addWidget(self.label_schedule, 2, 4, 1, 1)
        self.label_plate_thk = QtWidgets.QLabel(parent=self.frame)
        self.label_plate_thk.setMinimumSize(QtCore.QSize(40, 40))
        self.label_plate_thk.setText("CARACTERÍSTICAS:")
        self.label_plate_thk.setObjectName("label_plate_thk")
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        self.label_plate_thk.setFont(font)
        self.label_plate_thk.setText('Espesor Placa:')
        self.gridLayout_2.addWidget(self.label_plate_thk, 2, 5, 1, 1)
        self.Standard_Flange = QtWidgets.QComboBox(parent=self.frame)
        self.Standard_Flange.setMinimumSize(QtCore.QSize(40, 30))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.Standard_Flange.setFont(font)
        self.Standard_Flange.setObjectName("Standard_Flange")
        self.gridLayout_2.addWidget(self.Standard_Flange, 3, 0, 1, 1)
        self.Size_Flange = QtWidgets.QLineEdit(parent=self.frame)
        self.Size_Flange.setMinimumSize(QtCore.QSize(100, 30))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.Size_Flange.setFont(font)
        self.Size_Flange.setObjectName("Size_Flange")
        self.gridLayout_2.addWidget(self.Size_Flange, 3, 1, 1, 1)
        self.Rating_Flange = QtWidgets.QLineEdit(parent=self.frame)
        self.Rating_Flange.setMinimumSize(QtCore.QSize(100, 30))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.Rating_Flange.setFont(font)
        self.Rating_Flange.setObjectName("Rating_Flange")
        self.gridLayout_2.addWidget(self.Rating_Flange, 3, 2, 1, 1)
        self.Facing_Flange = QtWidgets.QLineEdit(parent=self.frame)
        self.Facing_Flange.setMinimumSize(QtCore.QSize(100, 30))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.Facing_Flange.setFont(font)
        self.Facing_Flange.setObjectName("Facing_Flange")
        self.gridLayout_2.addWidget(self.Facing_Flange, 3, 3, 1, 1)
        self.Schedule_Flange = QtWidgets.QLineEdit(parent=self.frame)
        self.Schedule_Flange.setMinimumSize(QtCore.QSize(100, 30))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.Schedule_Flange.setFont(font)
        self.Schedule_Flange.setObjectName("Schedule_Flange")
        self.gridLayout_2.addWidget(self.Schedule_Flange, 3, 4, 1, 1)
        self.PlateThk_Flange = QtWidgets.QLineEdit(parent=self.frame)
        self.PlateThk_Flange.setMinimumSize(QtCore.QSize(100, 30))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.PlateThk_Flange.setFont(font)
        self.PlateThk_Flange.setObjectName("PlateThk_Flange")
        self.gridLayout_2.addWidget(self.PlateThk_Flange, 3, 5, 1, 1)
        self.Button_Load = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Load.setMaximumSize(QtCore.QSize(250, 30))
        self.Button_Load.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.Button_Load.setAutoDefault(True)
        self.Button_Load.setObjectName("Button_Load")
        self.Button_Load.setText('Cargar')
        self.gridLayout_2.addWidget(self.Button_Load, 3, 6, 1, 1)

        self.hspacer2=QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.gridLayout_2.addItem(self.hspacer2, 4, 0, 1, 1)

        self.flange_image = QtWidgets.QLabel(parent=self.frame)
        self.flange_image.setText("")
        self.flange_image.setObjectName("flange_image")
        self.gridLayout_2.addWidget(self.flange_image, 5, 0, 1, 5)

        self.tableInformation=CustomTableWidget()
        self.tableInformation.setObjectName("tableInformation")
        self.tableInformation.setMinimumSize(QtCore.QSize(250, 16777215))
        self.tableInformation.setColumnCount(2)
        for i in range(self.tableInformation.columnCount()):
            item = QtWidgets.QTableWidgetItem()
            font = QtGui.QFont()
            font.setPointSize(12)
            font.setBold(True)
            item.setFont(font)
            self.tableInformation.setHorizontalHeaderItem(i, item)
        if self.username == 'm.gil':
            self.tableInformation.setStyleSheet("gridline-color: rgb(128, 128, 128);")
            self.tableInformation.horizontalHeader().setStyleSheet("QHeaderView::section {background-color: #33bdef; border: 1px solid white; font-weight: bold; font-size: 10pt;}")
        else:
            self.tableInformation.horizontalHeader().setStyleSheet("QHeaderView::section {background-color: #33bdef; border: 1px solid black; font-weight: bold; font-size: 10pt;}")
        self.tableInformation.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
        self.gridLayout_2.addWidget(self.tableInformation, 5, 5, 1, 3)

        self.hLayout3 = QtWidgets.QHBoxLayout()
        self.hLayout3.setObjectName("hLayout3")
        spacerItem2 = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hLayout3.addItem(spacerItem2)
        self.label_SumItems = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setText("")
        self.label_SumItems.setObjectName("label_SumItems")
        self.hLayout3.addWidget(self.label_SumItems)
        self.label_SumValue = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setText("")
        self.label_SumValue.setObjectName("label_SumValue")
        self.hLayout3.addWidget(self.label_SumValue)
        self.label_CountItems = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setText("")
        self.label_CountItems.setObjectName("label_CountItems")
        self.hLayout3.addWidget(self.label_CountItems)
        self.label_CountValue = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setText("")
        self.label_CountValue.setObjectName("label_CountValue")
        self.hLayout3.addWidget(self.label_CountValue)
        self.gridLayout_2.addLayout(self.hLayout3, 6, 5, 1, 2)
        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 0, 0, 1, 1)
        self.gridLayout.addWidget(self.frame, 0, 0, 1, 1)
        Verif_Flange_Information_Window.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=Verif_Flange_Information_Window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 790, 22))
        self.menubar.setObjectName("menubar")
        Verif_Flange_Information_Window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=Verif_Flange_Information_Window)
        self.statusbar.setObjectName("statusbar")
        Verif_Flange_Information_Window.setStatusBar(self.statusbar)

        self.retranslateUi(Verif_Flange_Information_Window)
        QtCore.QMetaObject.connectSlotsByName(Verif_Flange_Information_Window)

        self.toolPDF.clicked.connect(self.datasheet_pdf)

        self.Button_Load.clicked.connect(self.query_information)
        self.load_data()
        

# Function to translate and updates the text of various UI elements
    def retranslateUi(self, Verif_Flange_Information_Window):
        """
        Translates and updates the text of various UI elements.
        """
        _translate = QtCore.QCoreApplication.translate
        Verif_Flange_Information_Window.setWindowTitle(_translate("Verif_Flange_Information_Window", "Información Bridas"))
        item = self.tableInformation.horizontalHeaderItem(0)
        item.setText(_translate("Verif_Flange_Information_Window", ""))
        item = self.tableInformation.horizontalHeaderItem(1)
        item.setText(_translate("Verif_Flange_Information_Window", "Dimensión (mm)"))
        self.tableInformation.setSortingEnabled(True)

# Function to load table and setting in the window
    def query_information(self):
        """
        Queries the database for flanges, configures and populates tables with the query results, 
        and updates the UI accordingly. Handles potential database errors and updates the UI with appropriate messages.
        """
        self.tableInformation.setRowCount(0)

        code_flange = self.Standard_Flange.currentText() + "-" + self.Size_Flange.text() + "-" + self.Rating_Flange.text()
        query_flange_rf_data = ("""SELECT dim_o, dim_tf, dim_w, dim_lrf, num_tal, dim_h, dim_rf, dim_ah, dim_x,
                                REPLACE(TO_CHAR(
                                (REPLACE(dim_h, ',', '.')::numeric + REPLACE(dim_y, ',', '.')::numeric), 
                                'FM999999999.00'), '.', ',') AS dim_j
                                FROM verification.flanges_verification WHERE code_flange = %s""")
        query_flange_rtj_data = ("""SELECT dim_o, dim_tf, dim_w, dim_lrtj, num_tal, dim_p, dim_e, dim_f, dim_kmin, dim_ah, dim_x,
                                REPLACE(TO_CHAR(
                                (REPLACE(dim_e, ',', '.')::numeric + REPLACE(dim_y, ',', '.')::numeric), 
                                'FM999999999.00'), '.', ',') AS dim_j
                                FROM verification.flanges_verification WHERE code_flange = %s""")
        query_pipe_diam = ("""SELECT REPLACE(TO_CHAR(in_diam, 'FM999999999.00'), '.', ',') AS pipe_int_diam FROM validation_data.pipe_diam WHERE line_size = %s and sch = %s""")
        query_bolts = ("""SELECT dim_torn FROM validation_data.flow_torn WHERE code_torn = %s""")

        conn = None
        try:
        # read the connection parameters
            params = config()
        # connect to the PostgreSQL server
            conn = psycopg2.connect(**params)
            cur = conn.cursor()
        # execution of commands
            if self.Facing_Flange.text() == 'RF':
                cur.execute(query_flange_rf_data, (code_flange,))
                results_flange=cur.fetchall()
                columns = ["ØInt","ØO", "Tf", "ØW", "ØL", "Nº Tal", "H", "ØRF", "ØAh", "ØX", "J", "Torn."]
            elif self.Facing_Flange.text() == 'RTJ':
                cur.execute(query_flange_rtj_data, (code_flange,))
                results_flange=cur.fetchall()
                columns = ["ØInt","ØO", "Tf", "ØW", "ØL", "Nº Tal", "ØP", "E", "F", "Økmin", "ØRF", "ØAh", "ØX", "J", "Torn."]
            else:
                results_flange = None

            cur.execute(query_pipe_diam, (self.Size_Flange.text(), self.Schedule_Flange.text(),))
            results_pipe_diam=cur.fetchall()

            cur.execute(query_bolts, (self.Size_Flange.text() + " " + self.Rating_Flange.text() + " " + self.Facing_Flange.text() + " " + self.PlateThk_Flange.text() + " SQE",))
            results_torn=cur.fetchall()

            if len(results_flange) != 0 and results_flange is not None:
                self.tableInformation.setRowCount(len(results_flange[0]) + 2)

                it = QtWidgets.QTableWidgetItem(columns[0])
                it.setFlags(it.flags() & ~QtCore.Qt.ItemFlag.ItemIsEditable)
                self.tableInformation.setItem(0, 0, it)

                it = QtWidgets.QTableWidgetItem(str(results_pipe_diam[0][0]) if len(results_pipe_diam) > 0 else '')
                it.setFlags(it.flags() & ~QtCore.Qt.ItemFlag.ItemIsEditable)
                self.tableInformation.setItem(0, 1, it)

                tablerow=1

            # fill the Qt Table with the query results
                for column, row in enumerate(results_flange):
                    for row_index in range(len(row)):
                        value = row[row_index]
                        if value is None:
                            value = ''
                        
                        it = QtWidgets.QTableWidgetItem(str(columns[tablerow]))
                        it.setFlags(it.flags() & ~QtCore.Qt.ItemFlag.ItemIsEditable)
                        self.tableInformation.setItem(tablerow, column, it)
                        
                        it = QtWidgets.QTableWidgetItem(str(value))
                        it.setFlags(it.flags() & ~QtCore.Qt.ItemFlag.ItemIsEditable)
                        self.tableInformation.setItem(tablerow, column+1, it)

                        tablerow+=1

                it = QtWidgets.QTableWidgetItem(str(columns[-1]))
                it.setFlags(it.flags() & ~QtCore.Qt.ItemFlag.ItemIsEditable)
                self.tableInformation.setItem(tablerow, 0, it)

                it = QtWidgets.QTableWidgetItem(str(results_torn[0][0]) if len(results_torn) > 0 else '')
                it.setFlags(it.flags() & ~QtCore.Qt.ItemFlag.ItemIsEditable)
                self.tableInformation.setItem(tablerow, column+1, it)

                self.tableInformation.verticalHeader().hide()
                self.tableInformation.setItemDelegate(AlignDelegate(self.tableInformation))

                self.tableInformation.setSortingEnabled(False)
                self.adjust_table()

                if self.Facing_Flange.text() == 'RF':
                    self.image_path = r'\\nas01\DATOS\Comunes\EIPSA-ERP\Resources\Plantillas planos\BRIDA RF VERIFICACION.png'
                elif self.Facing_Flange.text() == 'RTJ':
                    self.image_path = r'\\nas01\DATOS\Comunes\EIPSA-ERP\Resources\Plantillas planos\BRIDA RTJ VERIFICACION.png'
                else:
                    self.image_path = None

                if self.image_path is not None:
                    corrected_image = self.correct_image_orientation(self.image_path)

                    from io import BytesIO
                    image_bytes = BytesIO()
                    corrected_image.save(image_bytes, format='PNG')
                    image_bytes.seek(0)

                    pixmap = QtGui.QPixmap()
                    pixmap.loadFromData(image_bytes.read())

                    self.flange_image.setPixmap(pixmap)
                    self.flange_image.setScaledContents(True)

                else:
                    self.flange_image.setPixmap(QtGui.QPixmap())

                # close communication with the PostgreSQL database server
                    cur.close()
                # commit the changes
                    conn.commit()

        except (Exception, psycopg2.DatabaseError) as error:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("Ha ocurrido el siguiente error:\n"
                        + str(error))
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
            dlg.exec()
            del dlg, new_icon
        finally:
            if conn is not None:
                conn.close()

# Function to count selected cells and sum its values
    def countSelectedCells(self):
        """
        Counts the number of selected cells and sums their values. Updates the UI labels with the count and sum.
        """
        if len(self.tableInformation.selectedIndexes()) > 1:
            locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

            sum_value = sum([self.euro_string_to_float(str(ix.data())) if re.match(r'^[\d.,]+\sÇ$', str(ix.data())) else float(str(ix.data()).replace(',', '.')) if str(ix.data()).replace(',', '.').replace('.', '', 1).isdigit() else 0 for ix in self.tableInformation.selectedIndexes()])
            count_value = len([ix for ix in self.tableInformation.selectedIndexes() if ix.data() != ""])
            if sum_value > 0:
                self.label_SumItems.setText("Suma:")
                self.label_SumValue.setText(locale.format_string("%.2f", sum_value, grouping=True))
            if count_value > 0:
                self.label_CountItems.setText("Recuento:")
                self.label_CountValue.setText(str(count_value))
        else:
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

# Function to adjust table size
    def adjust_table(self):
        """
        Adjusts column visibility and resize behavior in the tableInformation widget.
        """
        self.tableInformation.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
        self.tableInformation.verticalHeader().hide()

# Function to load data
    def load_data(self):
        """
        Loads flange data from the database and updates the UI components.
        Displays the data in relevant UI elements and adjusts the image if available.
        """
        query_size_data = ("""SELECT line_size FROM validation_data.flow_line_size ORDER BY line_size ASC""")
        query_rating_data = ("SELECT rating FROM validation_data.flow_rating ORDER BY rating ASC")
        query_facing_data = ("SELECT facing FROM validation_data.flow_facing ORDER BY facing ASC")
        query_schedule_data = ("SELECT schedule FROM validation_data.flow_schedule ORDER BY schedule ASC")
        query_thk_data = ("SELECT plate_thk FROM validation_data.flow_plate_thk ORDER BY plate_thk ASC")

        conn = None
        try:
        # read the connection parameters
            params = config()
        # connect to the PostgreSQL server
            conn = psycopg2.connect(**params)
            cur = conn.cursor()
        # execution of commands
            cur.execute(query_size_data)
            results_size=cur.fetchall()

            cur.execute(query_rating_data)
            results_rating=cur.fetchall()

            cur.execute(query_facing_data)
            results_facing=cur.fetchall()

            cur.execute(query_schedule_data)
            results_schedule=cur.fetchall()

            cur.execute(query_thk_data)
            results_thk=cur.fetchall()

        except (Exception, psycopg2.DatabaseError) as error:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("Ha ocurrido el siguiente error:\n"
                        + str(error))
            print(error)
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
            dlg.exec()
            del dlg, new_icon
        finally:
            if conn is not None:
                conn.close()

        self.Standard_Flange.addItems(['', 'B16.36','B16.47 SeriesA','B16.47 SeriesB','B16.5'])
        # self.Size_Flange.addItems([""] + [x[0] for x in results_size])
        # self.Rating_Flange.addItems([""] + [x[0] for x in results_rating])
        # self.Facing_Flange.addItems([""] + [x[0] for x in results_facing])
        # self.Schedule_Flange.addItems([""] + [x[0] for x in results_schedule])
        # self.PlateThk_Flange.addItems([""] + [x[0] for x in results_thk])

# Function to correct image orientation
    def correct_image_orientation(self,image_path):
        """
        Corrects image orientation using EXIF data, rotating if necessary.
        Returns the corrected image.
        """
        image = Image.open(image_path)
        
        try:
            for orientation in ExifTags.TAGS.keys():
                if ExifTags.TAGS[orientation] == 'Orientation':
                    break
            
            exif = image._getexif()

            if exif is not None:
                orientation = exif.get(orientation, 1)

                if orientation == 3:
                    image = image.rotate(180, expand=True)
                elif orientation == 6:
                    image = image.rotate(270, expand=True)
                elif orientation == 8:
                    image = image.rotate(90, expand=True)
        except (AttributeError, KeyError, IndexError):
            # No EXIF data, no need to correct orientation
            pass

        return image

# Function to print pdf
    def datasheet_pdf(self):
        """
        Generates a PDF datasheet for the flange with details and revisions.
        Opens the generated PDF in the viewer.
        """
        code_flange = self.Standard_Flange.currentText() + "-" + self.Size_Flange.text() + "-" + self.Rating_Flange.text()
        query_flange_rf_data = ("""SELECT dim_o, dim_tf, dim_w, dim_lrf, num_tal, dim_h, dim_rf, dim_ah, dim_x,
                                REPLACE(TO_CHAR(
                                (REPLACE(dim_h, ',', '.')::numeric + REPLACE(dim_y, ',', '.')::numeric), 
                                'FM999999999.00'), '.', ',') AS dim_j
                                FROM verification.flanges_verification WHERE code_flange = %s""")
        query_flange_rtj_data = ("""SELECT dim_o, dim_tf, dim_w, dim_lrtj, num_tal, dim_p, dim_e, dim_f, dim_kmin, dim_ah, dim_x,
                                REPLACE(TO_CHAR(
                                (REPLACE(dim_e, ',', '.')::numeric + REPLACE(dim_y, ',', '.')::numeric), 
                                'FM999999999.00'), '.', ',') AS dim_j
                                FROM verification.flanges_verification WHERE code_flange = %s""")
        query_pipe_diam = ("""SELECT REPLACE(TO_CHAR(in_diam, 'FM999999999.00'), '.', ',') AS pipe_int_diam FROM validation_data.pipe_diam WHERE line_size = %s and sch = %s""")

        conn = None
        try:
        # read the connection parameters
            params = config()
        # connect to the PostgreSQL server
            conn = psycopg2.connect(**params)
            cur = conn.cursor()
        # execution of commands
            if self.Facing_Flange.text() == 'RF':
                cur.execute(query_flange_rf_data, (code_flange,))
                results_flange=cur.fetchall()
            elif self.Facing_Flange.text() == 'RTJ':
                cur.execute(query_flange_rtj_data, (code_flange,))
                results_flange=cur.fetchall()
            
            cur.execute(query_pipe_diam, (self.Size_Flange.text(), self.Schedule_Flange.text(),))
            results_pipe_diam=cur.fetchall()

            # cur.execute(query_flange_revision, (self.flange_id,))
            # results_revisions=cur.fetchall()
        except (Exception, psycopg2.DatabaseError) as error:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("Ha ocurrido el siguiente error:\n"
                        + str(error))
            print(error)
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
            dlg.exec()
            del dlg, new_icon
        finally:
            if conn is not None:
                conn.close()

        if len(results_flange) != 0:
            pdf = CustomPDF('P', 'cm', 'A4')

            pdf.add_font('DejaVuSansCondensed', '', os.path.abspath(os.path.join(basedir, "Resources/Iconos/DejaVuSansCondensed.ttf")))
            pdf.add_font('DejaVuSansCondensed-Bold', '', os.path.abspath(os.path.join(basedir, "Resources/Iconos/DejaVuSansCondensed-Bold.ttf")))

            pdf.set_auto_page_break(auto=True)
            pdf.set_margins(1.5, 1.5)

            pdf.add_page()

            pdf.image(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Logo_email.png")), 1, 0.5, 3.5, 1)
            pdf.image(self.image_path, 1.5, 1.5, 18, 9.5)
            pdf.ln(9.5)
            pdf.set_fill_color(191, 191, 191)

            pdf.set_font('Helvetica', '', 9)
            pdf.cell(4.5, 0.5, "CANTIDAD", border='LT', align='L')
            pdf.cell(5, 0.5, "MATERIAL", border='LT', align='L')
            pdf.cell(5.5, 0.5, "COLADA", border='LT', align='L')
            pdf.cell(3, 0.5, "NORMA", border='LTR', align='L')
            pdf.ln()

            pdf.set_font('Helvetica', 'B', 11)
            pdf.cell(4.5, 1, "", border='LB')
            pdf.cell(5, 1, "", border='LB')
            pdf.cell(5.5, 1, "", border='LB')
            pdf.cell(3, 1, self.Standard_Flange.currentText(), border='LBR')
            pdf.ln()

            pdf.set_font('Helvetica', '', 9)
            pdf.cell(4.5, 0.5, "TAMAÑO", border='LT', align='L')
            pdf.cell(3.5, 0.5, "RATING", border='LT', align='L')
            pdf.cell(1.5, 0.5, "", border='LT', align='L')
            pdf.cell(2.5, 0.5, "", border='LT', align='L')
            pdf.cell(3, 0.5, "SCH", border='LT', align='L')
            pdf.cell(3, 0.5, "", border='LTR', align='L')
            pdf.ln()

            pdf.set_font('Helvetica', 'B', 16)
            pdf.cell(4.5, 1, self.Size_Flange.text(), border='LB', align='C')
            pdf.cell(3.5, 1, str(self.Rating_Flange.text()) + "#", border='LB', align='C')
            pdf.cell(1.5, 1, self.Facing_Flange.text(), border='LB', align='C')
            pdf.cell(2.5, 1, "WN", border='LB', align='C')
            pdf.cell(3, 1, self.Schedule_Flange.text(), border='LB', align='C')
            pdf.cell(3, 1, "", border='LBR', align='C')
            pdf.ln()

            if self.Facing_Flange.text() == 'RF':
                pdf.set_font('Helvetica', 'B', 9)
                pdf.cell(1.7, 0.5, "ØInt", border=1, align='C', fill=True)
                pdf.cell(1.63, 0.5, "ØO", border=1, align='C', fill=True)
                pdf.cell(1.63, 0.5, "Tf", border=1, align='C', fill=True)
                pdf.cell(1.63, 0.5, "ØW", border=1, align='C', fill=True)
                pdf.cell(1.63, 0.5, "ØL", border=1, align='C', fill=True)
                pdf.cell(1.63, 0.5, "Nº Tal", border=1, align='C', fill=True)
                pdf.cell(1.63, 0.5, "H", border=1, align='C', fill=True)
                pdf.cell(1.63, 0.5, "ØRF", border=1, align='C', fill=True)
                pdf.cell(1.63, 0.5, "ØAh", border=1, align='C', fill=True)
                pdf.cell(1.63, 0.5, "ØX", border=1, align='C', fill=True)
                pdf.cell(1.63, 0.5, "J", border=1, align='C', fill=True)
                pdf.ln()

                pdf.set_font('Helvetica', '', 9)
                pdf.cell(1.7, 0.5, str(results_pipe_diam[0][0]) if len(results_pipe_diam) > 0 else '', border=1, align='C')
                pdf.cell(1.63, 0.5, str(results_flange[0][0]), border=1, align='C')
                pdf.cell(1.63, 0.5, str(results_flange[0][1]), border=1, align='C')
                pdf.cell(1.63, 0.5, str(results_flange[0][2]), border=1, align='C')
                pdf.cell(1.63, 0.5, str(results_flange[0][3]), border=1, align='C')
                pdf.cell(1.63, 0.5, str(results_flange[0][4]), border=1, align='C')
                pdf.cell(1.63, 0.5, str(results_flange[0][5]), border=1, align='C')
                pdf.cell(1.63, 0.5, str(results_flange[0][6]), border=1, align='C')
                pdf.cell(1.63, 0.5, str(results_flange[0][7]), border=1, align='C')
                pdf.cell(1.63, 0.5, str(results_flange[0][8]), border=1, align='C')
                pdf.cell(1.63, 0.5, str(results_flange[0][9]), border=1, align='C')
                pdf.ln(1)

                for i in range(13):
                    pdf.cell(1.7, 0.75, "", border=1)
                    pdf.cell(1.63, 0.75, "", border=1)
                    pdf.cell(1.63, 0.75, "", border=1)
                    pdf.cell(1.63, 0.75, "", border=1)
                    pdf.cell(1.63, 0.75, "", border=1)
                    pdf.cell(1.63, 0.75, "", border=1)
                    pdf.cell(1.63, 0.75, "", border=1)
                    pdf.cell(1.63, 0.75, "", border=1)
                    pdf.cell(1.63, 0.75, "", border=1)
                    pdf.cell(1.63, 0.75, "", border=1)
                    pdf.cell(1.63, 0.75, "", border=1)
                    pdf.ln()

            elif self.Facing_Flange.text() == 'RTJ':
                pdf.set_font('Helvetica', 'B', 9)
                pdf.cell(1.44, 0.5, "ØInt", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "ØO", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "Tf", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "ØW", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "ØL", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "Nº Tal", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "ØP", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "E", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "F", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "Økmin", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "ØAh", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "ØX", border=1, align='C', fill=True)
                pdf.cell(1.38, 0.5, "J1", border=1, align='C', fill=True)
                pdf.ln()

                pdf.set_font('Helvetica', '', 9)
                pdf.cell(1.44, 0.5, str(results_pipe_diam[0][0]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][0]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][1]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][2]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][3]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][4]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][5]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][6]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][7]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][8]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][9]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][10]), border=1, align='C')
                pdf.cell(1.38, 0.5, str(results_flange[0][11]), border=1, align='C')
                pdf.ln(1)

                for i in range(13):
                    pdf.cell(1.44, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.cell(1.38, 0.75, "", border=1)
                    pdf.ln()

            # pdf.image(os.path.abspath(os.path.join(basedir, "Resources/Iconos/QualityControlStamp.png")), 14, 26, 5, 3)

            pdf_buffer = pdf.output()

            temp_file_path = os.path.abspath(os.path.join(os.path.abspath(os.path.join(basedir, "Resources/pdfviewer/temp", "flange.pdf"))))

            with open(temp_file_path, "wb") as temp_file:
                temp_file.write(pdf_buffer)

            self.pdf_viewer.open(QUrl.fromLocalFile(temp_file_path))  # Open PDF on viewer
            self.pdf_viewer.showMaximized()
        else:
            dlg_error = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg_error.setWindowIcon(new_icon)
            dlg_error.setWindowTitle("Bridas")
            dlg_error.setText("Faltan campos por rellenar o no hay datos para esa brida")
            dlg_error.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg_error.exec()
            del dlg_error,new_icon




if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    config_obj = configparser.ConfigParser()
    config_obj.read(r"C:\Program Files\ERP EIPSA\database.ini")
    dbparam = config_obj["postgresql"]
    # set your parameters for the database connection URI using the keys from the configfile.ini
    user_database = dbparam["user"]
    password_database = dbparam["password"]

    db = createConnection(user_database, password_database)
    if not db:
        sys.exit()

    Verif_Flange_Information_Window = Ui_Verif_Flange_Information_Window('m.gil')
    Verif_Flange_Information_Window.showMaximized()
    sys.exit(app.exec())