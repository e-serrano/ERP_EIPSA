# Form implementation generated from reading ui file 'EditTags_Commercial_Window.ui'
#
# Created by: PySide6 UI code generator 6.4.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PySide6 import QtCore, QtGui, QtWidgets
from PySide6 import QtSql
from PySide6.QtWidgets import QApplication
from PySide6.QtCore import Qt, QDate, QUrl
from PySide6.QtGui import QKeySequence, QTextDocument, QTextCursor
import re
from utils.Database_Manager import Create_DBconnection, Database_Connection
from config.config_functions import config_database
import psycopg2
import locale
import os
from datetime import *
import pandas as pd
from fpdf import FPDF
from windows.PDF_Viewer import PDF_Viewer
from PIL import Image, ExifTags
from utils.Show_Message import MessageHelper

basedir = r"\\ERP-EIPSA-DATOS\Comunes\EIPSA-ERP"


def imagen_to_base64(imagen):
    """
    Converts an image in PNG format to a base64 encoded string.

    Args:
        imagen: An instance of QImage or QPixmap to be converted.
    Return: 
        A base64 encoded string representing the image in PNG format.
    """
    buffer = QtCore.QBuffer()
    buffer.open(QtCore.QIODevice.OpenModeFlag.WriteOnly)
    imagen.save(buffer, ".png")
    base64_data = buffer.data().toBase64().data().decode()
    return base64_data

class AlignDelegate(QtWidgets.QStyledItemDelegate):
    """
    A custom item delegate for aligning cell content in a QTableView or QTableWidget to the center.

    Inherits from:
        QtWidgets.QStyledItemDelegate: Provides custom rendering and editing for table items.

    """
    def initStyleOption(self, option, index):
        """
        Initializes the style option for the item, setting its display alignment to center.

        Args:
            option (QtWidgets.QStyleOptionViewItem): The style option to initialize.
            index (QtCore.QModelIndex): The model index of the item.
        """
        super(AlignDelegate, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

class ColorDelegate(QtWidgets.QItemDelegate):
    """
    A custom item delegate for applying background colors to cells in a QTableView or QTableWidget.

    Inherits from:
        QtWidgets.QItemDelegate: Provides custom rendering for table items.
    """
    def __init__(self, parent=None):
        """
        Initializes the ColorDelegate, setting up the color mapping from the database.

        Args:
            parent (QtWidgets.QWidget, optional): The parent widget. Defaults to None.
        """
        super().__init__(parent)

    def paint(self, painter, option, index: QtCore.QModelIndex):
        """
        Paints the background color of the item based on its column and value.

        Args:
            painter (QtGui.QPainter): The painter used for painting.
            option (QtWidgets.QStyleOptionViewItem): The style option for the item.
            index (QtCore.QModelIndex): The model index of the item.
        """
        value = index.model().data(index, role=Qt.ItemDataRole.DisplayRole)
        background_color = QtGui.QColor(255, 255, 255, 0)

        if index.column() == 19:
            if isinstance(value, str):
                if value == 'NO':
                    background_color = QtGui.QColor(223, 47, 47) #Red
                else:
                    background_color = QtGui.QColor(59, 140, 27) #Green

        painter.fillRect(option.rect, background_color)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

        super().paint(painter, option, index)

class CustomProxyModel(QtCore.QSortFilterProxyModel):
    """
    A custom proxy model that filters table rows based on expressions set for specific columns.

    Attributes:
        _filters (dict): A dictionary to store filter expressions for columns.
        header_names (dict): A dictionary to store header names for the table.

    Properties:
        filters: Getter for the current filter dictionary.

    """
    def __init__(self, parent=None):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        super().__init__(parent)
        self._filters = dict()
        self.header_names = {}

    @property
    def filters(self):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        return self._filters

    def setFilter(self, expresion, column, action_name=None, exact_match=False):
        """
        Apply a filter expression to a specific column, or remove it if necessary.

        Args:
            expresion (str): The filter expression.
            column (int): The index of the column to apply the filter to.
            action_name (str, optional): Name of the action, can be empty. Defaults to None.
            exact_match (bool, optional): If True, use exact matching for the filter. Defaults to False.
        """
        if expresion or expresion == '':
            if column in self.filters:
                if action_name or action_name == '':
                    self.filters[column].remove(expresion)
                else:
                    self.filters[column].append((expresion, exact_match))
            else:
                self.filters[column] = [(expresion, exact_match)]
        elif column in self.filters:
            if action_name or action_name == '':
                self.filters[column].remove(expresion)
                if not self.filters[column]:
                    del self.filters[column]
            else:
                del self.filters[column]
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        """
        Check if a row passes the filter criteria based on the column filters.

        Args:
            source_row (int): The row number in the source model.
            source_parent (QModelIndex): The parent index of the row.

        Returns:
            bool: True if the row meets the filter criteria, False otherwise.
        """
        for column, expresions in self.filters.items():
            text = self.sourceModel().index(source_row, column, source_parent).data()

            if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
                text = text.toString("yyyy-MM-dd")

            match_found = False 

            for expresion, exact_match in expresions:
                if expresion == '':  # If expression is empty, match empty cells
                    if text == '':
                        break

                if exact_match:
                    if text in expresion:  # Verificar si `text` está en la lista `expresion`
                        match_found = True
                        break
                
                elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', expresion):
                    expresion = QtCore.QDate.fromString(expresion, "dd/MM/yyyy")
                    expresion = expresion.toString("yyyy-MM-dd")
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

                else:
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

            if not match_found:
                return False
        return True

class EditableTableModel(QtSql.QSqlTableModel):
    """
    A custom SQL table model that supports editable columns, headers, and special flagging behavior based on user permissions.

    Signals:
        updateFailed (str): Signal emitted when an update to the model fails.
    """
    updateFailed = QtCore.Signal(str)

    def __init__(self, parent=None, column_range=None):
        """
        Initialize the model with user permissions and optional database and column range.

        Args:
            username (str): The username for permission-based actions.
            parent (QObject, optional): Parent object for the model. Defaults to None.
            column_range (list, optional): A list specifying the range of columns. Defaults to None.
        """
        super().__init__(parent)
        self.column_range = column_range

    def setAllColumnHeaders(self, headers):
        """
        Set headers for all columns in the model.

        Args:
            headers (list): A list of header names.
        """
        for column, header in enumerate(headers):
            self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIndividualColumnHeader(self, column, header):
        """
        Set the header for a specific column.

        Args:
            column (int): The column index.
            header (str): The header name.
        """
        self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIconColumnHeader(self, column, icon):
        """
        Set an icon in the header for a specific column.

        Args:
            column (int): The column index.
            icon (QIcon): The icon to display in the header.
        """
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        """
        Retrieve the header data for a specific section of the model.

        Args:
            section (int): The section index (column or row).
            orientation (Qt.Orientation): The orientation (horizontal or vertical).
            role (Qt.ItemDataRole, optional): The role for the header data. Defaults to DisplayRole.

        Returns:
            QVariant: The header data for the specified section.
        """
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return super().headerData(section, orientation, role)
        return super().headerData(section, orientation, role)

    def flags(self, index):
        """
        Get the item flags for a given index, controlling editability and selection based on user permissions.

        Args:
            index (QModelIndex): The index of the item.

        Returns:
            Qt.ItemFlags: The flags for the specified item.
        """
        flags = super().flags(index)
        if index.column() in [0,1]:
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        else:
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable

    def getColumnHeaders(self, visible_columns):
        """
        Retrieve the headers for the specified visible columns.

        Args:
            visible_columns (list): List of column indices that are visible.

        Returns:
            list: A list of column headers for the visible columns.
        """
        column_headers = [self.headerData(col, Qt.Orientation.Horizontal) for col in visible_columns]
        return column_headers

class CustomPDF(FPDF):
    """
    Custom PDF class extending FPDF for advanced text handling.

    This class provides additional functionalities for creating PDF documents,
    specifically for managing multi-line text with fixed height.
    """

    def __init__(self, master, certificate):
        super().__init__('P', 'cm', 'A4')
        self.master = master
        self.certificate = certificate

    def fixed_height_multicell(self, w, total_h, txt, align_mc, border='LRB', fill=False):
        """
        Creates a multi-line cell with a fixed total height, dividing text into lines.

        Parameters:
            w (float): The width of the cell.
            total_h (float): The total height of the cell.
            txt (str): The text to be placed in the cell.
            align_mc (str): The alignment of the text.
            border (str, optional): Border settings for the cell. Defaults to ''.
            fill (bool, optional): Whether to fill the cell with color. Defaults to False.
        """
        words = txt.split() # Divide text in words
        lines = []
        line = ''
        for word in words:
            if self.get_string_width(line + word + ' ') > w - 0.5:
                lines.append(line) # Add line to line list and starts a new one
                line = word + ' '
            else:
                line += word + ' ' # Add word to actual line
        lines.append(line) # Add last line to line list
        
        line_height = total_h / len(lines) # Calculate height of each line to get a total height = total_h

        x, y = self.get_x(), self.get_y() # Save actual position

        for line in lines:
            # Print each line with the calculated height
            self.multi_cell(w, line_height, line, border, align_mc, fill)
            self.set_x(x)

        self.set_xy(x, y + total_h)

    def header(self):
        """
        Creates the header
        """
        self.image(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Eipsa Logo Blanco.png")), 0.8, 0.3, 7, 2)
        self.set_font('Helvetica', '', 9)
        self.set_xy(13.5, 1)
        self.multi_cell(6, 0.5, "CALIBRACIÓN INTERNA PARA MEDIDORES DE CAUDAL DE GAS", align='R')
        self.ln()
        self.multi_cell(17, 0.5, 'Rango de Gas verificado por comparación según la instrucción CEM-I-001 E-2 y el patrón "' + self.master + '" con certificado ENAC: ' + self.certificate)
        self.ln(0.5)

    def footer(self):
        """
        Creates the footer
        """
        self.set_xy(1.5,-1.5)
        self.set_font('Helvetica', '', 9)
        self.cell(1.5, 0.5, 'RCG-001')
        self.cell(11.5, 0.5, '')
        self.cell(5, 0.5, 'Fecha: ' + date.today().strftime("%d/%m/%y"), align='R')
        self.ln()
        self.set_font('Helvetica', 'B', 9)
        self.cell(1.5, 0.5, '')
        self.cell(11.5, 0.5, '')
        self.cell(5, 0.5, 'Departamento de Calidad', align='R')

class Ui_Workshop_Gas_Flowmeters_Rev_Window(QtWidgets.QMainWindow):
    """
    Main window class for managing workshop equipment reviews, including data filtering, sorting,
    and handling equipment-related operations.

    Attributes:
        model: The table model used to handle data for the equipment revisions.
        proxy: A custom proxy model for filtering and sorting the data.
        db: The database connection object.
        equipment_id: The ID of the equipment being reviewed or modified.
        checkbox_states: Dictionary storing the states of checkboxes for filtering purposes.
        dict_valuesuniques: Dictionary holding unique values for each column in the table.
        dict_ordersort: Dictionary managing the sorting order of columns.
        hiddencolumns: List of columns that are hidden in the table view.
        variable: Holds the current variable being used for filtering or sorting.
        action_checkbox_map: Dictionary mapping actions to checkboxes for filtering.
        checkbox_filters: Dictionary of active filters applied through checkboxes.
        username: The username of the current user.
        pdf_viewer: An instance of a PDF viewer for displaying relevant documents.
    """
    def __init__(self, db, username, equipment_id):
        """
        Initializes the workshop equipment revision window, setting up data models, filters,
        and UI components for a specific equipment.

        Args:
            db: Database connection object.
            username: Username of the current user.
            equipment_id: ID of the equipment being reviewed or modified.
        """
        super().__init__()
        self.model = EditableTableModel()
        self.proxy = CustomProxyModel()
        self.db = db
        self.equipment_id = equipment_id
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []
        self.variable = ''
        self.action_checkbox_map = {}
        self.checkbox_filters = {}
        self.username = username
        self.pdf_viewer = PDF_Viewer()
        self.setupUi(self)
        self.model.dataChanged.connect(self.saveChanges)

    def closeEvent(self, event):
        """
        Handles the event triggered when the window is closed. Ensures models are cleared and database connections are closed.

        Args:
            event (QCloseEvent): The close event triggered when the window is about to close.
        """
        if self.model:
            self.model.clear()
        self.closeConnection()

    def closeConnection(self):
        """
        Closes the database connection and clears any references to the models.
        Also removes the 'drawing_index' database connection from Qt's connection list if it exists.
        """
        self.tableRevisions.setModel(None)
        del self.model
        if self.db:
            self.db.close()
            del self.db
            if QtSql.QSqlDatabase.contains("equipment"):
                QtSql.QSqlDatabase.removeDatabase("equipment")

    def setupUi(self, Workshop_Gas_Flowmeters_Rev_Window):
        """
        Sets up the user interface for the Workshop_Gas_Flowmeters_Rev_Window.

        Args:
            Workshop_Gas_Flowmeters_Rev_Window (QtWidgets.QMainWindow): The main window for the UI setup.
        """
        Workshop_Gas_Flowmeters_Rev_Window.setObjectName("Workshop_Gas_Flowmeters_Rev_Window")
        Workshop_Gas_Flowmeters_Rev_Window.resize(790, 595)
        Workshop_Gas_Flowmeters_Rev_Window.setMinimumSize(QtCore.QSize(790, 595))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        Workshop_Gas_Flowmeters_Rev_Window.setWindowIcon(icon)
        Workshop_Gas_Flowmeters_Rev_Window.setStyleSheet(
    "QPushButton {\n"
    "background-color: #33bdef;\n"
    "  border: 1px solid transparent;\n"
    "  border-radius: 3px;\n"
    "  color: #fff;\n"
    "  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
    "  font-size: 15px;\n"
    "  font-weight: 800;\n"
    "  line-height: 1.15385;\n"
    "  margin: 0;\n"
    "  outline: none;\n"
    "  padding: 2px .8em;\n"
    "  text-align: center;\n"
    "  text-decoration: none;\n"
    "  vertical-align: baseline;\n"
    "  white-space: nowrap;\n"
    "}\n"
    "\n"
    "QPushButton:hover {\n"
    "    background-color: #019ad2;\n"
    "    border-color: rgb(0, 0, 0);\n"
    "}\n"
    "\n"
    "QPushButton:pressed {\n"
    "    background-color: rgb(1, 140, 190);\n"
    "    border-color: rgb(255, 255, 255);\n"
    "}")
        self.centralwidget = QtWidgets.QWidget(parent=Workshop_Gas_Flowmeters_Rev_Window)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_2.setVerticalSpacing(10)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.hcab=QtWidgets.QHBoxLayout()
        self.hcab.setObjectName("hcab")
        self.toolDeleteFilter = QtWidgets.QToolButton(self.frame)
        self.toolDeleteFilter.setObjectName("DeleteFilter_Button")
        self.toolDeleteFilter.setToolTip("Borrar filtros")
        self.toolDeleteFilter.setIconSize(QtCore.QSize(25, 25))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Delete.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolDeleteFilter.setIcon(icon)
        self.hcab.addWidget(self.toolDeleteFilter)
        self.hcabspacer4=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer4)
        self.toolImages = QtWidgets.QToolButton(self.frame)
        self.toolImages.setObjectName("Image_Button")
        self.toolImages.setToolTip("Añadir Imagen")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Camera.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolImages.setIcon(icon)
        self.toolImages.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolImages)
        self.hcabspacer3=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer3)
        self.toolAdd = QtWidgets.QToolButton(self.frame)
        self.toolAdd.setObjectName("Add_Button")
        self.toolAdd.setToolTip("Crear Nueva")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Add.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolAdd.setIcon(icon)
        self.toolAdd.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolAdd)
        self.hcabspacer4=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer4)
        self.toolPDF = QtWidgets.QToolButton(self.frame)
        self.toolPDF.setObjectName("PDF_Button")
        self.toolPDF.setToolTip("Imprimir PDF")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Adobe_PDF.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolPDF.setIcon(icon)
        self.toolPDF.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolPDF)

        self.hcabspacer6=QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer6)
        self.gridLayout_2.addLayout(self.hcab, 0, 0, 1, 5)

        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 1, 1, 1, 1)

        self.label_number = QtWidgets.QLabel(parent=self.frame)
        self.label_number.setMinimumSize(QtCore.QSize(40, 30))
        self.label_number.setObjectName("label_number")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_number.setFont(font)
        self.gridLayout_2.addWidget(self.label_number, 2, 0, 1, 1)
        self.label_instrument = QtWidgets.QLabel(parent=self.frame)
        self.label_instrument.setMinimumSize(QtCore.QSize(40, 30))
        self.label_instrument.setObjectName("label_instrument")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_instrument.setFont(font)
        self.gridLayout_2.addWidget(self.label_instrument, 2, 1, 1, 1)
        self.label_range = QtWidgets.QLabel(parent=self.frame)
        self.label_range.setMinimumSize(QtCore.QSize(40, 30))
        self.label_range.setObjectName("label_range")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_range.setFont(font)
        self.gridLayout_2.addWidget(self.label_range, 2, 2, 1, 1)
        self.label_last_check = QtWidgets.QLabel(parent=self.frame)
        self.label_last_check.setMinimumSize(QtCore.QSize(40, 30))
        self.label_last_check.setObjectName("label_last_check")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_last_check.setFont(font)
        self.gridLayout_2.addWidget(self.label_last_check, 2, 3, 1, 1)
        self.label_next_check = QtWidgets.QLabel(parent=self.frame)
        self.label_next_check.setMinimumSize(QtCore.QSize(40, 30))
        self.label_next_check.setObjectName("label_next_check")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_next_check.setFont(font)
        self.gridLayout_2.addWidget(self.label_next_check, 2, 4, 1, 1)
        self.label_uncertainty = QtWidgets.QLabel(parent=self.frame)
        self.label_uncertainty.setMinimumSize(QtCore.QSize(40, 30))
        self.label_uncertainty.setObjectName("label_uncertainty")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_uncertainty.setFont(font)
        self.gridLayout_2.addWidget(self.label_uncertainty, 3, 0, 1, 1)

        self.label_precision = QtWidgets.QLabel(parent=self.frame)
        self.label_precision.setMinimumSize(QtCore.QSize(40, 30))
        self.label_precision.setObjectName("label_precision")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_precision.setFont(font)
        self.gridLayout_2.addWidget(self.label_precision, 3, 1, 1, 1)

        self.label_model = QtWidgets.QLabel(parent=self.frame)
        self.label_model.setMinimumSize(QtCore.QSize(40, 30))
        self.label_model.setObjectName("label_model")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_model.setFont(font)
        self.gridLayout_2.addWidget(self.label_model, 3, 2, 1, 1)

        self.label_master = QtWidgets.QLabel(parent=self.frame)
        self.label_master.setMinimumSize(QtCore.QSize(40, 30))
        self.label_master.setObjectName("label_master")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_master.setFont(font)
        self.gridLayout_2.addWidget(self.label_master, 3, 3, 1, 1)

        self.label_reference = QtWidgets.QLabel(parent=self.frame)
        self.label_reference.setMinimumSize(QtCore.QSize(40, 30))
        self.label_reference.setObjectName("label_reference")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_reference.setFont(font)
        self.gridLayout_2.addWidget(self.label_reference, 3, 4, 1, 1)

        self.label_result = QtWidgets.QLabel(parent=self.frame)
        self.label_result.setMinimumSize(QtCore.QSize(40, 30))
        self.label_result.setObjectName("label_result")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_result.setFont(font)
        self.gridLayout_2.addWidget(self.label_result, 4, 0, 1, 2)
        self.label_notes = QtWidgets.QLabel(parent=self.frame)
        self.label_notes.setMinimumSize(QtCore.QSize(40, 30))
        self.label_notes.setObjectName("label_notes")
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        self.label_notes.setFont(font)
        self.label_notes.setWordWrap(True)
        self.gridLayout_2.addWidget(self.label_notes, 4, 1, 1, 3)

        self.Button_Image = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Image.setMinimumSize(QtCore.QSize(100, 35))
        self.Button_Image.setObjectName("Button_Image")
        self.gridLayout_2.addWidget(self.Button_Image, 4, 4, 1, 1)

        self.tableRevisions=QtWidgets.QTableView(parent=self.frame)
        self.model = EditableTableModel()
        self.tableRevisions.setObjectName("tableequipments")
        self.hLayout3 = QtWidgets.QHBoxLayout()
        self.hLayout3.setObjectName("hLayout3")
        spacerItem2 = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hLayout3.addItem(spacerItem2)
        self.label_SumItems = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setText("")
        self.label_SumItems.setObjectName("label_SumItems")
        self.hLayout3.addWidget(self.label_SumItems)
        self.label_SumValue = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setText("")
        self.label_SumValue.setObjectName("label_SumValue")
        self.hLayout3.addWidget(self.label_SumValue)
        self.label_CountItems = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setText("")
        self.label_CountItems.setObjectName("label_CountItems")
        self.hLayout3.addWidget(self.label_CountItems)
        self.label_CountValue = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setText("")
        self.label_CountValue.setObjectName("label_CountValue")
        self.hLayout3.addWidget(self.label_CountValue)
        self.gridLayout_2.addLayout(self.hLayout3, 6, 0, 1, 5)
        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 0, 0, 1, 1)
        self.gridLayout.addWidget(self.frame, 0, 0, 1, 1)
        Workshop_Gas_Flowmeters_Rev_Window.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=Workshop_Gas_Flowmeters_Rev_Window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 790, 22))
        self.menubar.setObjectName("menubar")
        Workshop_Gas_Flowmeters_Rev_Window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=Workshop_Gas_Flowmeters_Rev_Window)
        self.statusbar.setObjectName("statusbar")
        Workshop_Gas_Flowmeters_Rev_Window.setStatusBar(self.statusbar)

        self.retranslateUi(Workshop_Gas_Flowmeters_Rev_Window)
        QtCore.QMetaObject.connectSlotsByName(Workshop_Gas_Flowmeters_Rev_Window)

        self.model.dataChanged.connect(self.saveChanges)
        self.createContextMenu()

        delete_action = QtGui.QAction("Eliminar Fila", self)
        delete_action.triggered.connect(self.delete_register)

        self.context_menu_row = QtWidgets.QMenu(self)
        self.context_menu_row.addAction(delete_action)

        self.tableRevisions.setContextMenuPolicy(Qt.ContextMenuPolicy.ActionsContextMenu)
        self.tableRevisions.addActions([delete_action])

        self.toolAdd.clicked.connect(self.add_new)
        self.toolDeleteFilter.clicked.connect(self.delete_allFilters)
        # self.toolImages.clicked.connect(self.add_images)
        self.toolPDF.clicked.connect(lambda: self.datasheet_pdf(self.equipment_id))
        # self.Button_Image.clicked.connect(self.open_image)

        self.query_revisions()
        # self.load_data()

# Function to translate and updates the text of various UI elements
    def retranslateUi(self, Workshop_Gas_Flowmeters_Rev_Window):
        """
        Translates and updates the text of various UI elements.
        """
        _translate = QtCore.QCoreApplication.translate
        Workshop_Gas_Flowmeters_Rev_Window.setWindowTitle(_translate("Workshop_Gas_Flowmeters_Rev_Window", "Revisiones Medidores Caudal de Gas Taller"))
        self.Button_Image.setText(_translate("Workshop_Gas_Flowmeters_Rev_Window", "Ver Imagen"))

        self.tableRevisions.setSortingEnabled(True)

# Function to delete all filters when tool button is clicked
    def delete_allFilters(self):
        """
        Resets all filters and updates the table model with unique values for each column.
        """
        if self.proxy.rowCount() != 0:
            columns_number=self.model.columnCount()
            for index in range(columns_number):
                if index in self.proxy.filters:
                    del self.proxy.filters[index]
                self.model.setIconColumnHeader(index, '')

            self.checkbox_states = {}
            self.dict_valuesuniques = {}
            self.dict_ordersort = {}
            self.checkbox_filters = {}

            self.proxy.invalidateFilter()
            self.tableRevisions.setModel(None)
            self.tableRevisions.setModel(self.proxy)

            # Getting the unique values for each column of the model
            for column in range(self.model.columnCount()):
                list_valuesUnique = []
                if column not in self.checkbox_states:
                    self.checkbox_states[column] = {}
                    self.checkbox_states[column]['Seleccionar todo'] = True
                    for row in range(self.model.rowCount()):
                        value = self.model.record(row).value(column)
                        if value not in list_valuesUnique:
                            if isinstance(value, QtCore.QDate):
                                value=value.toString("dd/MM/yyyy")
                            list_valuesUnique.append(str(value))
                            self.checkbox_states[column][value] = True
                    self.dict_valuesuniques[column] = list_valuesUnique

            self.adjust_table()

# Function to save changes into database
    def saveChanges(self):
        """
        Saves changes made to the data models and updates unique values for each column.
        """
        self.model.submitAll()

        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            for row in range(self.model.rowCount()):
                value = self.model.record(row).value(column)
                if value not in list_valuesUnique:
                    if isinstance(value, QtCore.QDate):
                        value=value.toString("dd/MM/yyyy")
                    list_valuesUnique.append(str(value))
                    if value not in self.checkbox_states[column]:
                        self.checkbox_states[column][value] = True
            self.dict_valuesuniques[column] = list_valuesUnique

# Function to load table and setting in the window
    def query_revisions(self):
        """
        Queries the database for equipments revisiones, configures and populates tables with the query results, 
        and updates the UI accordingly. Handles potential database errors and updates the UI with appropriate messages.
        """
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []

        self.model.setTable("verification.gas_flowmeters_workshop_revisions")
        self.model.setFilter(f"equipment_id = {self.equipment_id}")

        self.tableRevisions.setModel(None)
        self.tableRevisions.setModel(self.proxy)
        self.model.select()

        self.proxy.setSourceModel(self.model)
        self.tableRevisions.setModel(self.proxy)

        columns_number=self.model.columnCount()

        self.tableRevisions.setItemDelegate(AlignDelegate(self.tableRevisions))
        self.color_delegate = ColorDelegate(self)
        self.tableRevisions.setItemDelegateForColumn(19, self.color_delegate)

        self.tableRevisions.setStyleSheet("gridline-color: rgb(128, 128, 128);")
        self.tableRevisions.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid;}")

        self.tableRevisions.setObjectName("tableequipments")
        self.gridLayout_2.addWidget(self.tableRevisions, 5, 0, 1, 5)
        self.tableRevisions.setMinimumSize(QtCore.QSize(800,16777215))
        self.tableRevisions.setSortingEnabled(False)

    # Change all column names
        headers_names = ["", "", "Lectura Patrón", "Lectura Equipo", "Desviación"]

        self.model.setAllColumnHeaders(headers_names)

    # Getting the unique values for each column of the model
        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            if column not in self.checkbox_states:
                self.checkbox_states[column] = {}
                self.checkbox_states[column]['Seleccionar todo'] = True
                for row in range(self.model.rowCount()):
                    value = self.model.record(row).value(column)
                    if value not in list_valuesUnique:
                        if isinstance(value, QtCore.QDate):
                            value=value.toString("dd/MM/yyyy")
                        list_valuesUnique.append(str(value))
                        self.checkbox_states[column][value] = True
                self.dict_valuesuniques[column] = list_valuesUnique

        self.selection_model = self.tableRevisions.selectionModel()
        # self.selection_model.selectionChanged.connect(self.countSelectedCells)

        self.tableRevisions.horizontalHeader().sectionDoubleClicked.connect(self.on_view_horizontalHeader_sectionClicked)
        self.tableRevisions.horizontalHeader().customContextMenuRequested.connect(self.showColumnContextMenu)
        self.tableRevisions.horizontalHeader().setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)

        self.tableRevisions.sortByColumn(0, Qt.SortOrder.AscendingOrder)

        self.adjust_table()

# Function when header is clicked
    def on_view_horizontalHeader_sectionClicked(self, logicalIndex):
        """
        Displays a menu when a column header is clicked. The menu includes options for sorting, filtering, and managing column visibility.
        
        Args:
            logicalIndex (int): Index of the clicked column.
        """
        self.logicalIndex = logicalIndex
        self.menuValues = QtWidgets.QMenu(self)
        self.signalMapper = QtCore.QSignalMapper(self.tableRevisions)

        valuesUnique_view = []
        for row in range(self.tableRevisions.model().rowCount()):
            index = self.tableRevisions.model().index(row, self.logicalIndex)
            value = index.data(Qt.ItemDataRole.DisplayRole)
            if value not in valuesUnique_view:
                if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
                valuesUnique_view.append(value)

        actionSortAscending = QtGui.QAction("Ordenar Ascendente", self.tableRevisions)
        actionSortAscending.triggered.connect(self.on_actionSortAscending_triggered)
        self.menuValues.addAction(actionSortAscending)
        actionSortDescending = QtGui.QAction("Ordenar Descendente", self.tableRevisions)
        actionSortDescending.triggered.connect(self.on_actionSortDescending_triggered)
        self.menuValues.addAction(actionSortDescending)
        self.menuValues.addSeparator()

        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro", self.tableRevisions)
        actionDeleteFilterColumn.triggered.connect(self.on_actionDeleteFilterColumn_triggered)
        self.menuValues.addAction(actionDeleteFilterColumn)
        self.menuValues.addSeparator()

        actionTextFilter = QtGui.QAction("Buscar...", self.tableRevisions)
        actionTextFilter.triggered.connect(self.on_actionTextFilter_triggered)
        self.menuValues.addAction(actionTextFilter)
        self.menuValues.addSeparator()

        scroll_menu = QtWidgets.QScrollArea()
        scroll_menu.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget(scroll_menu)
        scroll_menu.setWidget(scroll_widget)
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        checkbox_all_widget = QtWidgets.QCheckBox('Seleccionar todo')

        if not self.checkbox_states[self.logicalIndex]['Seleccionar todo'] == True:
            checkbox_all_widget.setChecked(False)
        else:
            checkbox_all_widget.setChecked(True)
        
        checkbox_all_widget.toggled.connect(lambda checked, name='Seleccionar todo': self.on_select_all_toggled(checked, name))

        scroll_layout.addWidget(checkbox_all_widget)
        self.action_checkbox_map['Seleccionar todo'] = checkbox_all_widget

        if len(self.dict_ordersort) != 0 and self.logicalIndex in self.dict_ordersort:
            list_uniquevalues = sorted(list(set(self.dict_valuesuniques[self.logicalIndex])))
        else:
            list_uniquevalues = sorted(list(set(valuesUnique_view)))

        for actionName in list_uniquevalues:
            checkbox_widget = QtWidgets.QCheckBox(str(actionName))

            if self.logicalIndex not in self.checkbox_filters:
                checkbox_widget.setChecked(True)
            elif actionName not in self.checkbox_filters[self.logicalIndex]:
                checkbox_widget.setChecked(False)
            else:
                checkbox_widget.setChecked(True)

            checkbox_widget.toggled.connect(lambda checked, name=actionName: self.on_checkbox_toggled(checked, name))

            scroll_layout.addWidget(checkbox_widget)
            self.action_checkbox_map[actionName] = checkbox_widget

        action_scroll_menu = QtWidgets.QWidgetAction(self.menuValues)
        action_scroll_menu.setDefaultWidget(scroll_menu)
        self.menuValues.addAction(action_scroll_menu)

        self.menuValues.addSeparator()

        accept_button = QtGui.QAction("ACEPTAR", self.tableRevisions)
        accept_button.triggered.connect(self.menu_acceptbutton_triggered)

        cancel_button = QtGui.QAction("CANCELAR", self.tableRevisions)
        cancel_button.triggered.connect(self.menu_cancelbutton_triggered)

        self.menuValues.addAction(accept_button)
        self.menuValues.addAction(cancel_button)

        self.menuValues.setStyleSheet("QMenu::item:selected { background-color: #33bdef; }"
                                        "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

        headerPos = self.tableRevisions.mapToGlobal(self.tableRevisions.horizontalHeader().pos())        

        posY = headerPos.y() + self.tableRevisions.horizontalHeader().height()
        scrollX = self.tableRevisions.horizontalScrollBar().value()
        xInView = self.tableRevisions.horizontalHeader().sectionViewportPosition(logicalIndex)
        posX = headerPos.x() + xInView - scrollX

        self.menuValues.exec(QtCore.QPoint(posX, posY))

# Function when cancel button of menu is clicked
    def menu_cancelbutton_triggered(self):
        """
        Hides the menu when the cancel button is clicked.
        """
        self.menuValues.hide()

# Function when accept button of menu is clicked
    def menu_acceptbutton_triggered(self):
        """
        Applies the selected filters and updates the table model with the new filters.
        """
        for column, filters in self.checkbox_filters.items():
            if filters:
                self.proxy.setFilter(filters, column)
            else:
                self.proxy.setFilter(None, column)

        self.adjust_table()

# Function when select all checkbox is clicked
    def on_select_all_toggled(self, checked, action_name):
        """
        Toggles the state of all checkboxes in the filter menu when the 'Select All' checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the 'Select All' checkbox.
            action_name (str): The name of the action (usually 'Select All').
        """
        filterColumn = self.logicalIndex
        imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
                checkbox_widget.setChecked(checked)
                self.checkbox_states[self.logicalIndex][checkbox_name] = checked

            if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
                self.model.setIconColumnHeader(filterColumn, icono)
            else:
                self.model.setIconColumnHeader(filterColumn, '')
        
        else:
            for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
                checkbox_widget.setChecked(checked)
                self.checkbox_states[self.logicalIndex][checkbox_widget.text()] = checked

# Function when checkbox of header menu is clicked
    def on_checkbox_toggled(self, checked, action_name):
        """
        Updates the filter state when an individual checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the checkbox.
            action_name (str): The name of the checkbox.
        """
        filterColumn = self.logicalIndex
        imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            if filterColumn not in self.checkbox_filters:
                self.checkbox_filters[filterColumn] = [action_name]
            else:
                if action_name not in self.checkbox_filters[filterColumn]:
                    self.checkbox_filters[filterColumn].append(action_name)
        else:
            if filterColumn in self.checkbox_filters and action_name in self.checkbox_filters[filterColumn]:
                self.checkbox_filters[filterColumn].remove(action_name)

        if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
            self.model.setIconColumnHeader(filterColumn, '')
        else:
            self.model.setIconColumnHeader(filterColumn, icono)

# Function to delete individual column filter
    def on_actionDeleteFilterColumn_triggered(self):
        """
        Removes the filter from the selected column and updates the table model.
        """
        filterColumn = self.logicalIndex
        if filterColumn in self.proxy.filters:
                del self.proxy.filters[filterColumn]
        self.model.setIconColumnHeader(filterColumn, '')
        self.proxy.invalidateFilter()

        self.tableRevisions.setModel(None)
        self.tableRevisions.setModel(self.proxy)

        if filterColumn in self.checkbox_filters:
            del self.checkbox_filters[filterColumn]

        self.checkbox_states[self.logicalIndex].clear()
        self.checkbox_states[self.logicalIndex]['Seleccionar todo'] = True
        for row in range(self.tableRevisions.model().rowCount()):
            value = self.model.record(row).value(filterColumn)
            if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
            self.checkbox_states[self.logicalIndex][str(value)] = True

        self.adjust_table()

# Function to order column ascending
    def on_actionSortAscending_triggered(self):
        """
        Sorts the selected column in ascending order.
        """
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.AscendingOrder
        self.proxy.sort(sortColumn, sortOrder)

# Function to order column descending
    def on_actionSortDescending_triggered(self):
        """
        Sorts the selected column in descending order.
        """
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.DescendingOrder
        self.proxy.sort(sortColumn, sortOrder)

# Function when text is searched
    def on_actionTextFilter_triggered(self):
        """
        Opens a dialog to enter a text filter and applies it to the selected column.
        """
        filterColumn = self.logicalIndex
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle('Buscar')
        clickedButton=dlg.exec()

        if clickedButton == 1:
            stringAction = dlg.textValue()
            if re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', stringAction):
                stringAction=QtCore.QDate.fromString(stringAction,"dd/MM/yyyy")
                stringAction=stringAction.toString("yyyy-MM-dd")

            filterString = QtCore.QRegularExpression(stringAction, QtCore.QRegularExpression.PatternOption(0))
            # del self.proxy.filters[filterColumn]
            self.proxy.setFilter([stringAction], filterColumn, None)

            imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
            icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
            self.model.setIconColumnHeader(filterColumn, icono)

# Function to hide column when action clicked
    def hide_column(self):
        """
        Hides the selected column in the table view.
        """
        filterColumn = self.logicalIndex
        self.tableRevisions.setColumnHidden(filterColumn, True)
        self.hiddencolumns.append(filterColumn)

# Function to show all hidden columns
    def show_columns(self):
        """
        Makes all previously hidden columns visible in the table and clears the list of hidden columns.
        """
        for column in self.hiddencolumns:
            self.tableRevisions.setColumnHidden(column, False)
        self.hiddencolumns.clear()

# Function to export data to excel
    def exporttoexcel(self):
        """
        Exports the visible data from the table to an Excel file. If no data is loaded, displays a warning message.

        Shows a message box if there is no data to export and allows the user to save the data to an Excel file.
        """
        if self.proxy.rowCount() == 0:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("Exportar")
            dlg.setText("No hay datos cargados")
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg.exec()
            del dlg,new_icon
        else:
            final_data = []

            visible_columns = [col for col in range(self.model.columnCount()) if not self.tableRevisions.isColumnHidden(col)]
            visible_headers = self.model.getColumnHeaders(visible_columns)
            for row in range(self.proxy.rowCount()):
                tag_data = []
                for column in visible_columns:
                    value = self.proxy.data(self.proxy.index(row, column))
                    if isinstance(value, QDate):
                        value = value.toString("dd/MM/yyyy")
                    tag_data.append(value)
                final_data.append(tag_data)

            final_data.insert(0, visible_headers)
            df = pd.DataFrame(final_data)
            df.columns = df.iloc[0]
            df = df[1:]

            output_path, _ = QtWidgets.QFileDialog.getSaveFileName(None, "Guardar Excel", "", "Archivos de Excel (*.xlsx)")
        if output_path:
            if not output_path.lower().endswith(".xlsx"):
                output_path += ".xlsx"
                df.to_excel(output_path, index=False, header=True)

# Function to enable copy and paste cells
    def keyPressEvent(self, event):
        """
        Handles custom key events for cell operations in the table.

        Args:
            event (QtGui.QKeyEvent): The key event to handle.
        """
        if event.matches(QKeySequence.StandardKey.Copy):
            if self.tableRevisions.selectionModel() != None:
                selected_indexes = self.tableRevisions.selectionModel().selectedIndexes()
                if selected_indexes:
                    clipboard = QApplication.clipboard()
                    text = self.get_selected_text(selected_indexes)
                    if isinstance(text, QtCore.QDate):
                        text=text.toString("dd/MM/yyyy")
                    clipboard.setText(text)

        elif event.matches(QKeySequence.StandardKey.Paste):
            if self.tableRevisions.selectionModel() != None:
                selected_indexes = self.tableRevisions.selectionModel().selectedIndexes()
                if selected_indexes:
                    clipboard = QApplication.clipboard()
                    text = clipboard.text()
                    for index in selected_indexes:
                        current_row = index.row()
                        current_column = index.column()
                        first_column_value = self.proxy.data(self.proxy.index(current_row, 0))
                        target_row = None
                        for row in range(self.model.rowCount()):
                            if self.model.data(self.model.index(row, 0)) == first_column_value:
                                target_row = row
                                break
                        if target_row is not None:
                            target_index = self.model.index(target_row, current_column)
                            self.model.setData(target_index, text, Qt.ItemDataRole.EditRole)
                    self.model.submitAll()

        super().keyPressEvent(event)

# Function to get the text of the selected cells
    def get_selected_text(self, indexes):
        """
        Retrieves the text from the selected cells and returns it as a plain text string.

        Args:
            indexes (list of QModelIndex): A list of QModelIndex objects representing the selected cells.
        
        Returns:
            str: A string containing the text from the selected cells.
        """
        if len(indexes) == 1:  # For only one cell selected
            index = indexes[0]
            cell_data = index.data(Qt.ItemDataRole.DisplayRole)
            return cell_data
        else:
            rows = set()
            cols = set()
            for index in indexes:
                rows.add(index.row())
                cols.add(index.column())

            text_doc = QTextDocument()
            cursor = QTextCursor(text_doc)

            for row in sorted(rows):
                for col in sorted(cols):
                    index = self.model.index(row, col)  
                    cell_data = index.data(Qt.ItemDataRole.DisplayRole)
                    cursor.insertText(str(cell_data))
                    cursor.insertText('\t')
                cursor.insertText('\n')

            return text_doc.toPlainText()

# Function to count selected cells and sum its values
    def countSelectedCells(self):
        """
        Counts the number of selected cells and sums their values. Updates the UI labels with the count and sum.
        """
        if len(self.tableRevisions.selectedIndexes()) > 1:
            locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

            sum_value = sum([self.euro_string_to_float(str(ix.data())) if re.match(r'^[\d.,]+\sÇ$', str(ix.data())) else float(str(ix.data()).replace(',', '.')) if str(ix.data()).replace(',', '.').replace('.', '', 1).isdigit() else 0 for ix in self.tableRevisions.selectedIndexes()])
            count_value = len([ix for ix in self.tableRevisions.selectedIndexes() if ix.data() != ""])
            if sum_value > 0:
                self.label_SumItems.setText("Suma:")
                self.label_SumValue.setText(locale.format_string("%.2f", sum_value, grouping=True))
            if count_value > 0:
                self.label_CountItems.setText("Recuento:")
                self.label_CountValue.setText(str(count_value))
        else:
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

# Function to format money string values
    def euro_string_to_float(self, euro_str):
        """
        Converts a string representing an amount in euros to a float.

        Args:
            euro_str (str): A string representing the amount in euros (e.g., "1.234,56 €").
        
        Returns:
            float: The numeric value of the amount as a float.
        """
        match = re.match(r'^([\d.,]+)\s€$', euro_str)
        if match:
            number_str = match.group(1)
            number_str = number_str.replace('.', '').replace(',', '.')
            return float(number_str)
        else:
            return 0.0

# Function for creating context menu
    def createContextMenu(self):
        """
        Creates a context menu with options for hiding selected columns.
        """
        self.context_menu = QtWidgets.QMenu(self)
        hide_columns_action = self.context_menu.addAction("Ocultar Columnas")
        hide_columns_action.triggered.connect(self.hideSelectedColumns)

# Function to show context menu when right-click
    def showColumnContextMenu(self, pos):
        """
        Displays the context menu at the specified position for column operations.

        Args:
            pos (QPoint): The position at which to display the context menu.
        """
        header = self.tableRevisions.horizontalHeader()
        column = header.logicalIndexAt(pos)
        self.context_menu.exec(self.tableRevisions.mapToGlobal(pos))

# Function to hide selected columns
    def hideSelectedColumns(self):
        """
        Hides the currently selected columns in the table and updates the list of hidden columns.
        """
        selected_columns = set()
        header = self.tableRevisions.horizontalHeader()
        for index in header.selectionModel().selectedColumns():
            selected_columns.add(index.column())

        for column in selected_columns:
            self.tableRevisions.setColumnHidden(column, True)
            self.hiddencolumns.append(column)

        self.context_menu.close()

# Function to add a new line
    def add_new(self):
        """
        Inserts a new empty entry into the gas_flowmeters_workshop_revisions table.
        Commits the changes to the database and handles any errors.
        """
        commands_new=("""
                        INSERT INTO verification.gas_flowmeters_workshop_revisions (equipment_id)
                        VALUES(%s)
                        """)

        try:
            with Database_Connection(config_database()) as conn:
                with conn.cursor() as cur:
                    data=(self.equipment_id,)
                    cur.execute(commands_new, data)

                conn.commit()

        except (Exception, psycopg2.DatabaseError) as error:
            MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "error")

        self.query_revisions()

# Function to adjust table size
    def adjust_table(self):
        """
        Adjusts column visibility and resize behavior in the tableRevisions widget.
        """
        self.tableRevisions.hideColumn(0)
        self.tableRevisions.hideColumn(1)
        self.tableRevisions.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
        # self.tableRevisions.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        # self.tableRevisions.verticalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableRevisions.verticalHeader().hide()

# Function to add images to equipments
    def add_images(self):
        """
        Adds an image to the selected equipment's record in the database.
        Updates the image field for the specified equipment by selecting an image file from the filesystem.
        """
        initialdir="//ERP-EIPSA-DATOS/Comunes/MARIO GIL/Calibracion Equipos de medida mecanica/Fotos Equipos de medida mecanica"

        images_path, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Seleccionar imagen", initialdir, "Archivos JPG (*.jpg)")

        if images_path:
            commands_insert = ("""
                    UPDATE verification."gas_flowmeters_workshop"
                    SET "image" = %s
                    WHERE "id" = %s
                    """)

            conn = None
            try:
            # read the connection parameters
                params = config_database()
            # connect to the PostgreSQL server
                conn = psycopg2.connect(**params)
                cur = conn.cursor()
            # execution of commands
                cur.execute(commands_insert, (images_path, self.equipment_id,))

            # close communication with the PostgreSQL database server
                cur.close()
            # commit the changes
                conn.commit()

            except (Exception, psycopg2.DatabaseError) as error:
                dlg = QtWidgets.QMessageBox()
                new_icon = QtGui.QIcon()
                new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                dlg.setWindowIcon(new_icon)
                dlg.setWindowTitle("Medidores Caudal de Gas Taller")
                dlg.setText("Ha ocurrido el siguiente error:\n"
                            + str(error))
                dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                dlg.exec()
                del dlg, new_icon

            finally:
                if conn is not None:
                    conn.close()

            self.load_data()

# Function to load data
    def load_data(self):
        """
        Loads equipment data from the database and updates the UI components.
        Displays the data in relevant UI elements.
        """
        query_equipment_data = ("""SELECT number, instrument, model, scale, range,
                            precision, uncertainty, master, TO_CHAR(last_revision, 'DD/MM/YYYY'), TO_CHAR(next_revision, 'DD/MM/YYYY'),
                            result, notes FROM verification.gas_flowmeters_workshop WHERE id = %s""")

        conn = None
        try:
        # read the connection parameters
            params = config_database()
        # connect to the PostgreSQL server
            conn = psycopg2.connect(**params)
            cur = conn.cursor()
        # execution of commands
            cur.execute(query_equipment_data, (self.equipment_id,))
            results_equipment=cur.fetchall()

        except (Exception, psycopg2.DatabaseError) as error:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("Ha ocurrido el siguiente error:\n"
                        + str(error))
            print(error)
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
            dlg.exec()
            del dlg, new_icon
        finally:
            if conn is not None:
                conn.close()

        self.label_number.setText("NÚMERO: " + results_equipment[0][0] if results_equipment[0][0] is not None else "")
        self.label_instrument.setText("INSTRUMENTO: " + results_equipment[0][1] if results_equipment[0][1] is not None else "")
        self.label_model.setText("MODELO: " + results_equipment[0][2] if results_equipment[0][2] is not None else "")
        self.label_range.setText("RANGO: " + results_equipment[0][4] + " " + results_equipment[0][3] if results_equipment[0][4] is not None else "")
        self.label_precision.setText("PRECISIÓN: " + results_equipment[0][5] + " " + results_equipment[0][3] if results_equipment[0][5] is not None else "")
        self.label_uncertainty.setText("INCERTIDUMBRE: " + results_equipment[0][6] + " " + results_equipment[0][3] if results_equipment[0][6] is not None else "")
        self.label_master.setText("PATRÓN: " + results_equipment[0][7] if results_equipment[0][7] is not None else "")
        self.label_last_check.setText("ULT. COMP.: " + results_equipment[0][8] if results_equipment[0][8] is not None else "")
        self.label_next_check.setText("PROX. COMP.: " +results_equipment[0][9] if results_equipment[0][9] is not None else "")
        self.label_result.setText("RESULTADO: " + results_equipment[0][10] if results_equipment[0][10] is not None else "")
        self.label_notes.setText("NOTAS: " + results_equipment[0][11] if results_equipment[0][11] is not None else "")

# Function to delete register of database
    def delete_register(self):
        """
        Deletes selected records from the specified table.
        """
        selection_model = self.tableRevisions.selectionModel()

        if not selection_model.hasSelection():
            return

        model = self.tableRevisions.model()

        id_values = []
        selected_indexes = selection_model.selectedRows()
        for index in selected_indexes:
            # Obtaining first columns values
            item_index = model.index(index.row(), 0)
            if item_index.isValid():
                value = model.data(item_index)
                id_values.append(value)

        if len(id_values) != 0:
            dlg_yes_no = QtWidgets.QMessageBox()
            new_icon_yes_no = QtGui.QIcon()
            new_icon_yes_no.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg_yes_no.setWindowIcon(new_icon_yes_no)
            dlg_yes_no.setWindowTitle("ERP EIPSA")
            dlg_yes_no.setText("¿Estás seguro de que deseas eliminar los registros?\n")
            dlg_yes_no.setIcon(QtWidgets.QMessageBox.Icon.Warning)
            dlg_yes_no.setStandardButtons(QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No)
            result = dlg_yes_no.exec()
            if result == QtWidgets.QMessageBox.StandardButton.Yes:
                conn = None
                try:
                # read the connection parameters
                    params = config_database()
                # connect to the PostgreSQL server
                    conn = psycopg2.connect(**params)
                    cur = conn.cursor()
                # execution of commands
                    commands_delete = ("""DELETE FROM verification.equipments_workshop_revisions
                                        WHERE id = %s""")
                    for id_value in id_values:
                        data = (id_value,)
                        cur.execute(commands_delete, data)

                # close communication with the PostgreSQL database server
                    cur.close()
                # commit the changes
                    conn.commit()

                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("Revisiones Medidores Caudal de Gas")
                    dlg.setText("Registros eliminados con éxito")
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Information)
                    dlg.exec()
                    del dlg,new_icon

                    self.query_revisions()

                except (Exception, psycopg2.DatabaseError) as error:
                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("ERP EIPSA")
                    dlg.setText("Ha ocurrido el siguiente error:\n"
                                + str(error))
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                    dlg.exec()
                    del dlg, new_icon
                finally:
                    if conn is not None:
                        conn.close()

            del dlg_yes_no, new_icon_yes_no

# Function to correct image orientation
    def open_image(self):
        """
        Open the image of the equipment.
        """
        query_path_image = ("""SELECT image FROM verification.gas_flowmeters_workshop WHERE id = %s""")
        
        conn = None
        try:
        # read the connection parameters
            params = config_database()
        # connect to the PostgreSQL server
            conn = psycopg2.connect(**params)
            cur = conn.cursor()
        # execution of commands
            cur.execute(query_path_image, (self.equipment_id,))
            results=cur.fetchall()

        # close communication with the PostgreSQL database server
            cur.close()
        # commit the changes
            conn.commit()

            file_path = os.path.normpath(results[0][0])
            os.startfile(file_path)

        except (Exception, psycopg2.DatabaseError) as error:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("Ha ocurrido el siguiente error:\n"
                        + str(error))
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
            dlg.exec()
            del dlg, new_icon
        finally:
            if conn is not None:
                conn.close()

# Function to print pdf
    def datasheet_pdf(self, equipment_id):
        """
        Exports the visible data from the table to an Excel file. If no data is loaded, displays a warning message.

        Shows a message box if there is no data to export and allows the user to save the data to an Excel file.
        """

        commands_item=("""
                        SELECT equipment, master, units, TO_CHAR(last_check_date, 'DD/MM/YYYY'), TO_CHAR(next_check_date, 'DD/MM/YYYY') FROM verification.gas_flowmeters_workshop
                        WHERE id = %s
                        """)

        commands_rev=("""
                        SELECT * FROM verification.gas_flowmeters_workshop_revisions
                        WHERE equipment_id = %s
                        """)

        commands_master=("""
                        SELECT certificate_1 FROM verification.calibrated_masters
                        WHERE number = %s
                        """)

        try:
            with Database_Connection(config_database()) as conn:
                with conn.cursor() as cur:
                    data=(equipment_id,)
                    cur.execute(commands_item, data)
                    results = cur.fetchall()
                    equipment_name = results[0][0]
                    master_name = results[0][1]
                    units = results[0][2]
                    last_check = results [0][3]
                    next_check = results [0][4]

                    cur.execute(commands_rev, data)
                    results_rev = cur.fetchall()
                    dataframe = pd.DataFrame(results_rev)

                    cur.execute(commands_master, (master_name,))
                    results_cert = cur.fetchall()

        except (Exception, psycopg2.DatabaseError) as error:
            MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "error")

        certificate = results_cert[0][0].split("\\")[-1].split(" ")[0]

        pdf = CustomPDF(master_name, certificate)

        pdf.add_font('DejaVuSansCondensed', '', os.path.abspath(os.path.join(basedir, "Resources/Iconos/DejaVuSansCondensed.ttf")))
        pdf.add_font('DejaVuSansCondensed-Bold', '', os.path.abspath(os.path.join(basedir, "Resources/Iconos/DejaVuSansCondensed-Bold.ttf")))

        pdf.set_auto_page_break(auto=True)
        pdf.set_margins(1.5, 1.5)

        pdf.set_fill_color(191,191,191)

        pdf.add_page()

        pdf.set_font('DejaVuSansCondensed-Bold', '', 8)
        pdf.cell(3, 0.5, 'EQUIPO', border=1, align='C',fill=True)
        pdf.cell(3, 0.5, str(equipment_name), border=1, align='C')
        pdf.ln()
        pdf.cell(6, 0.5, 'Patrón (' + str(master_name) + ')', border=1, align='C',fill=True)
        pdf.cell(6, 0.5, 'Lectura Directa', border=1, align='C',fill=True)
        pdf.cell(6, 0.5, 'Desviación', border=1, align='C',fill=True)
        pdf.ln()
        pdf.set_font('DejaVuSansCondensed', '', 8)

        for element in results_rev:
            pdf.cell(3, 0.5, str(element[2]), border=1, align='R')
            pdf.cell(3, 0.5, str(units), border=1, align='L')
            pdf.cell(3, 0.5, str(element[3]), border=1, align='R')
            pdf.cell(3, 0.5, str(units), border=1, align='L')
            pdf.cell(3, 0.5, str(int(element[4])), border=1, align='R')
            pdf.cell(3, 0.5, str(units), border=1, align='L')
            pdf.ln()

        pdf.cell(18, 0.5, '')
        pdf.ln()

        pdf.cell(12, 0.5, "", align='L')
        pdf.cell(3, 0.5, "FECHA DE COMPROBACIÓN: ", align='R')
        pdf.cell(3, 0.5, str(last_check), align='L')
        pdf.ln()

        pdf.cell(12, 0.5, "", align='L')
        pdf.cell(3, 0.5, "PRÓXIMA COMPROBACIÓN: ", align='R')
        pdf.cell(3, 0.5, str(next_check), align='L')
        pdf.ln()



        y_position = pdf.get_y()

        if y_position > 25:
            pdf.add_page()

        pdf_buffer = pdf.output()

        temp_file_path = os.path.abspath(os.path.join(os.path.abspath(os.path.join(basedir, "Resources/pdfviewer/temp", "CERT.pdf"))))

        with open(temp_file_path, "wb") as temp_file:
            temp_file.write(pdf_buffer)

        self.pdf_viewer.open(QUrl.fromLocalFile(temp_file_path))  # Open PDF on viewer
        self.pdf_viewer.showMaximized()

# Function to correct image orientation
    def correct_image_orientation(self,image_path):
        """
        Corrects image orientation using EXIF data, rotating if necessary.
        Returns the corrected image.
        """
        image = Image.open(image_path)
        
        try:
            for orientation in ExifTags.TAGS.keys():
                if ExifTags.TAGS[orientation] == 'Orientation':
                    break
            
            exif = image._getexif()

            if exif is not None:
                orientation = exif.get(orientation, 1)

                if orientation == 3:
                    image = image.rotate(180, expand=True)
                elif orientation == 6:
                    image = image.rotate(270, expand=True)
                elif orientation == 8:
                    image = image.rotate(90, expand=True)
        except (AttributeError, KeyError, IndexError):
            # No EXIF data, no need to correct orientation
            pass

        return image



if __name__ == "__main__":
    import sys
    import os

    ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    if ROOT not in sys.path:
        sys.path.insert(0, ROOT)
    app = QtWidgets.QApplication(sys.argv)
    dbparam = config_database()
    user_database = dbparam["user"]
    password_database = dbparam["password"]

    db = Create_DBconnection(user_database, password_database)
    if not db:
        sys.exit()

    Workshop_Gas_Flowmeters_Rev_Window = Ui_Workshop_Gas_Flowmeters_Rev_Window(db, 'm.gil', '5')
    Workshop_Gas_Flowmeters_Rev_Window.showMaximized()
    sys.exit(app.exec())