# Form implementation generated from reading ui file 'EditTags_Commercial_Window.ui'
#
# Created by: PySide6 UI code generator 6.4.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PySide6 import QtCore, QtGui, QtWidgets
from PySide6 import QtSql
from PySide6.QtWidgets import QApplication
from PySide6.QtCore import Qt, QDate
from PySide6.QtGui import QKeySequence, QTextDocument, QTextCursor
from utils.Database_Manager import Create_DBconnection, Database_Connection
from config.config_functions import config_database, get_path
import psycopg2
import re
import locale
from datetime import *
import pandas as pd
from utils.Show_Message import MessageHelper


def imagen_to_base64(imagen):
    """
    Converts an image in PNG format to a base64 encoded string.

    Args:
        imagen: An instance of QImage or QPixmap to be converted.
    Return: 
        A base64 encoded string representing the image in PNG format.
    """
    buffer = QtCore.QBuffer()
    buffer.open(QtCore.QIODevice.OpenModeFlag.WriteOnly)
    imagen.save(buffer, ".png")
    base64_data = buffer.data().toBase64().data().decode()
    return base64_data


class CheckboxWidget(QtWidgets.QWidget):
    """
    A widget containing a single checkbox with the given text.

    Attributes:
        checkbox (QtWidgets.QCheckBox): The checkbox widget.
    """
    def __init__(self, text):
        """
        Initializes the CheckboxWidget with the specified text.

        Args:
            text (str): The text to display next to the checkbox.
        """
        super().__init__()
        layout = QtWidgets.QHBoxLayout(self)
        self.checkbox = QtWidgets.QCheckBox(text)
        layout.addWidget(self.checkbox)

class AlignDelegate(QtWidgets.QStyledItemDelegate):
    """
    A custom item delegate for aligning cell content in a QTableView or QTableWidget to the center.

    Inherits from:
        QtWidgets.QStyledItemDelegate: Provides custom rendering and editing for table items.

    """
    def initStyleOption(self, option, index):
        """
        Initializes the style option for the item, setting its display alignment to center.

        Args:
            option (QtWidgets.QStyleOptionViewItem): The style option to initialize.
            index (QtCore.QModelIndex): The model index of the item.
        """
        super(AlignDelegate, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

class ColorDelegate_PresentationDate(QtWidgets.QItemDelegate):
    """
    A custom item delegate for applying background colors to cells in a QTableView or QTableWidget.

    Inherits from:
        QtWidgets.QItemDelegate: Provides custom rendering for table items.
    """
    def __init__(self, parent=None):
        """
        Initializes the ColorDelegate, setting up the color mapping from the database.

        Args:
            parent (QtWidgets.QWidget, optional): The parent widget. Defaults to None.
        """
        super().__init__(parent)

    def paint(self, painter, option, index: QtCore.QModelIndex):
        """
        Paints the background color of the item based on its column and value.

        Args:
            painter (QtGui.QPainter): The painter used for painting.
            option (QtWidgets.QStyleOptionViewItem): The style option for the item.
            index (QtCore.QModelIndex): The model index of the item.
        """
        
        background_color = QtGui.QColor(255, 255, 255, 0)

        if index.column() == 9:
            current_date = QDate.currentDate()
            presentation_date = index.data()  # Text of cell to be painted

            if presentation_date < current_date.addDays(-30) and presentation_date != QDate(0, 0, 0):
                background_color = QtGui.QColor(255, 105, 105) # Light Red

        painter.fillRect(option.rect, background_color)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

        super().paint(painter, option, index)

class EditableComboBoxDelegate(QtWidgets.QStyledItemDelegate):
    """
    A delegate for editing combobox items in a view.

    Attributes:
        options (list): List of options to populate the combobox.
    """
    def __init__(self, parent=None, options=None):
        """
        Initializes the EditableComboBoxDelegate with the specified options.

        Args:
            parent (QtWidgets.QWidget, optional): Parent widget.
            options (list, optional): List of options for the combobox.
        """
        super().__init__(parent)
        self.options = options
        self._cleared = False

    def createEditor(self, parent, option, index):
        """
        Creates an editor for the combobox.

        Args:
            parent (QtWidgets.QWidget): Parent widget.
            option (QtWidgets.QStyleOptionViewItem): Style options for the item.
            index (QtCore.QModelIndex): Index of the item in the model.

        Returns:
            QtWidgets.QComboBox: The created combobox editor.
        """
        editor = QtWidgets.QComboBox(parent)
        editor.setEditable(True)
        editor.addItems(self.options)
        line_edit = editor.lineEdit()
        line_edit.clear()
        line_edit.textEdited.connect(self.clear_text_on_first_edit)
        return editor

    def setEditorData(self, editor, index):
        """
        Sets the data for the combobox editor.

        Args:
            editor (QtWidgets.QComboBox): The combobox editor.
            index (QtCore.QModelIndex): Index of the item in the model.
        """
        text = index.data(Qt.ItemDataRole.DisplayRole)
        editor.setEditText(text)

    def setModelData(self, editor, model, index):
        """
        Updates the model with the data from the combobox editor.

        Args:
            editor (QtWidgets.QComboBox): The combobox editor.
            model (QtGui.QAbstractItemModel): The model to update.
            index (QtCore.QModelIndex): Index of the item in the model.
        """
        model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)

    def clear_text_on_first_edit(self, text):
        """
        Clears the text on the first edit and disconnects the signal.

        Args:
            line_edit (QtWidgets.QLineEdit): The line edit within the combobox.
        """
        line_edit = self.sender()
        if line_edit is not None:
            line_edit.blockSignals(True)  # Block signals to prevent recursive calls
            line_edit.clear()  # Clear the line edit's text
            line_edit.blockSignals(False)  # Unblock signals after clearing

            # Disconnect to avoid clearing on subsequent edits
            line_edit.textEdited.disconnect(self.clear_text_on_first_edit)

class CustomProxyModel(QtCore.QSortFilterProxyModel):
    """
    A custom proxy model that filters table rows based on expressions set for specific columns.

    Attributes:
        _filters (dict): A dictionary to store filter expressions for columns.
        header_names (dict): A dictionary to store header names for the table.

    Properties:
        filters: Getter for the current filter dictionary.

    """
    def __init__(self, parent=None):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        super().__init__(parent)
        self._filters = dict()
        self.header_names = {}

    @property
    def filters(self):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        return self._filters

    def setFilter(self, expresion, column, action_name=None, exact_match=False):
        """
        Apply a filter expression to a specific column, or remove it if necessary.

        Args:
            expresion (str): The filter expression.
            column (int): The index of the column to apply the filter to.
            action_name (str, optional): Name of the action, can be empty. Defaults to None.
            exact_match (bool, optional): If True, use exact matching for the filter. Defaults to False.
        """
        if expresion or expresion == '':
            if column in self.filters:
                if action_name or action_name == '':
                    self.filters[column].remove(expresion)
                else:
                    self.filters[column].append((expresion, exact_match))
            else:
                self.filters[column] = [(expresion, exact_match)]
        elif column in self.filters:
            if action_name or action_name == '':
                self.filters[column].remove(expresion)
                if not self.filters[column]:
                    del self.filters[column]
            else:
                del self.filters[column]
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        """
        Check if a row passes the filter criteria based on the column filters.

        Args:
            source_row (int): The row number in the source model.
            source_parent (QModelIndex): The parent index of the row.

        Returns:
            bool: True if the row meets the filter criteria, False otherwise.
        """
        for column, expresions in self.filters.items():
            text = self.sourceModel().index(source_row, column, source_parent).data()

            if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
                text = text.toString("yyyy-MM-dd")

            match_found = False 

            for expresion, exact_match in expresions:
                if expresion == '':  # If expression is empty, match empty cells
                    if text == '':
                        break

                if exact_match:
                    if text in expresion:  # Verificar si `text` está en la lista `expresion`
                        match_found = True
                        break
                
                elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', expresion[0]):
                    expresion = QtCore.QDate.fromString(expresion[0], "dd/MM/yyyy")
                    expresion = expresion.toString("yyyy-MM-dd")
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

                else:
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion[0]))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

            if not match_found:
                return False
        return True

    def lessThan(self, left, right):
        leftData = self.sourceModel().data(left)
        rightData = self.sourceModel().data(right)

        column = left.column()

        # Columns to order as integers
        numeric_columns = [6, 7]

        if column in numeric_columns:
            try:
                return int(leftData) < int(rightData)
            except (ValueError, TypeError):
                pass  # If fail, order as string

        # Order by text (default)
        return str(leftData) < str(rightData)

class EditableTableModel(QtSql.QSqlTableModel):
    """
    A custom SQL table model that supports editable columns, headers, and special flagging behavior based on user permissions.

    Signals:
        updateFailed (str): Signal emitted when an update to the model fails.
    """
    updateFailed = QtCore.Signal(str)

    def __init__(self, username, parent=None, column_range=None, table_check=None):
        """
        Initialize the model with user permissions and optional database and column range.

        Args:
            username (str): The username for permission-based actions.
            parent (QObject, optional): Parent object for the model. Defaults to None.
            column_range (list, optional): A list specifying the range of columns. Defaults to None.
            table_check (str, optional): A text scpecifying the table selected. Defaults to None
        """
        super().__init__(parent)
        self.column_range = column_range
        self.table_check = table_check
        self.username = username

    def setAllColumnHeaders(self, headers):
        """
        Set headers for all columns in the model.

        Args:
            headers (list): A list of header names.
        """
        for column, header in enumerate(headers):
            self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIndividualColumnHeader(self, column, header):
        """
        Set the header for a specific column.

        Args:
            column (int): The column index.
            header (str): The header name.
        """
        self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIconColumnHeader(self, column, icon):
        """
        Set an icon in the header for a specific column.

        Args:
            column (int): The column index.
            icon (QIcon): The icon to display in the header.
        """
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        """
        Retrieve the header data for a specific section of the model.

        Args:
            section (int): The section index (column or row).
            orientation (Qt.Orientation): The orientation (horizontal or vertical).
            role (Qt.ItemDataRole, optional): The role for the header data. Defaults to DisplayRole.

        Returns:
            QVariant: The header data for the specified section.
        """
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return super().headerData(section, orientation, role)
        return super().headerData(section, orientation, role)

    def flags(self, index):
        """
        Get the item flags for a given index, controlling editability and selection based on user permissions.

        Args:
            index (QModelIndex): The index of the item.

        Returns:
            Qt.ItemFlags: The flags for the specified item.
        """
        flags = super().flags(index)

        if index.column() == 0:
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        else:
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable

    def getColumnHeaders(self, visible_columns):
        """
        Retrieve the headers for the specified visible columns.

        Args:
            visible_columns (list): List of column indices that are visible.

        Returns:
            list: A list of column headers for the visible columns.
        """
        column_headers = [self.headerData(col, Qt.Orientation.Horizontal) for col in visible_columns]
        return column_headers

# class EditableComboBoxDelegate2(QtWidgets.QStyledItemDelegate):
#     """
#     A delegate for editing combobox items in a view.

#     Attributes:
#         options (list): List of options to populate the combobox.
#     """
#     def __init__(self, parent=None, options=None):
#         """
#         Initializes the EditableComboBoxDelegate with the specified options.

#         Args:
#             parent (QtWidgets.QWidget, optional): Parent widget.
#             options (list, optional): List of options for the combobox.
#         """
#         super().__init__(parent)
#         self.options = options

#     def createEditor(self, parent, option, index):
#         """
#         Creates an editor for the combobox.

#         Args:
#             parent (QtWidgets.QWidget): Parent widget.
#             option (QtWidgets.QStyleOptionViewItem): Style options for the item.
#             index (QtCore.QModelIndex): Index of the item in the model.

#         Returns:
#             QtWidgets.QComboBox: The created combobox editor.
#         """
#         editor = QtWidgets.QComboBox(parent)
#         editor.setEditable(True)
#         return editor

#     def setEditorData(self, editor, index):
#         """
#         Sets the data for the combobox editor.

#         Args:
#             editor (QtWidgets.QComboBox): The combobox editor.
#             index (QtCore.QModelIndex): Index of the item in the model.
#         """
#         text = index.data(Qt.ItemDataRole.DisplayRole)
#         editor.addItems(self.options)
#         editor.setEditText(text)

#     def setModelData(self, editor, model, index):
#         """
#         Updates the model with the data from the combobox editor.

#         Args:
#             editor (QtWidgets.QComboBox): The combobox editor.
#             model (QtGui.QAbstractItemModel): The model to update.
#             index (QtCore.QModelIndex): Index of the item in the model.
#         """
#         model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)

# class CustomProxyModel2(QtCore.QSortFilterProxyModel):
#     """
#     A custom proxy model that filters table rows based on expressions set for specific columns.

#     Attributes:
#         _filters (dict): A dictionary to store filter expressions for columns.
#         header_names (dict): A dictionary to store header names for the table.

#     Properties:
#         filters: Getter for the current filter dictionary.

#     """
#     def __init__(self, parent=None):
#         """
#         Get the current filter expressions applied to columns.

#         Returns:
#             dict: Dictionary of column filters.
#         """
#         super().__init__(parent)
#         self._filters = dict()
#         self.header_names = {}

#     @property
#     def filters(self):
#         """
#         Get the current filter expressions applied to columns.

#         Returns:
#             dict: Dictionary of column filters.
#         """
#         return self._filters

#     def setFilter(self, expresion, column, action_name=None, exact_match=False):
#         """
#         Apply a filter expression to a specific column, or remove it if necessary.

#         Args:
#             expresion (str): The filter expression.
#             column (int): The index of the column to apply the filter to.
#             action_name (str, optional): Name of the action, can be empty. Defaults to None.
#             exact_match (bool, optional): If True, use exact matching for the filter. Defaults to False.
#         """
#         if expresion or expresion == '':
#             if column in self.filters:
#                 if action_name or action_name == '':
#                     self.filters[column].remove(expresion)
#                 else:
#                     self.filters[column].append((expresion, exact_match))
#             else:
#                 self.filters[column] = [(expresion, exact_match)]
#         elif column in self.filters:
#             if action_name or action_name == '':
#                 self.filters[column].remove(expresion)
#                 if not self.filters[column]:
#                     del self.filters[column]
#             else:
#                 del self.filters[column]
#         self.invalidateFilter()

#     def filterAcceptsRow(self, source_row, source_parent):
#         """
#         Check if a row passes the filter criteria based on the column filters.

#         Args:
#             source_row (int): The row number in the source model.
#             source_parent (QModelIndex): The parent index of the row.

#         Returns:
#             bool: True if the row meets the filter criteria, False otherwise.
#         """
#         for column, expresions in self.filters.items():
#             text = self.sourceModel().index(source_row, column, source_parent).data()

#             if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
#                 text = text.toString("yyyy-MM-dd")

#             match_found = False 

#             for expresion, exact_match in expresions:
#                 if expresion == '':  # If expression is empty, match empty cells
#                     if text == '':
#                         break

#                 if exact_match:
#                     if text in expresion:  # Verificar si `text` está en la lista `expresion`
#                         match_found = True
#                         break
                
#                 elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', expresion[0]):
#                     expresion = QtCore.QDate.fromString(expresion[0], "dd/MM/yyyy")
#                     expresion = expresion.toString("yyyy-MM-dd")
#                     regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
#                     if regex.match(str(text)).hasMatch():
#                         match_found = True
#                         break

#                 else:
#                     regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion[0]))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
#                     if regex.match(str(text)).hasMatch():
#                         match_found = True
#                         break

#             if not match_found:
#                 return False
#         return True

# class EditableTableModel2(QtSql.QSqlTableModel):
#     """
#     A custom SQL table model that supports editable columns, headers, and special flagging behavior based on user permissions.

#     Signals:
#         updateFailed (str): Signal emitted when an update to the model fails.
#     """
#     updateFailed = QtCore.Signal(str)

#     def __init__(self, parent=None, column_range=None, table_check=None):
#         """
#         Initialize the model with user permissions and optional database and column range.

#         Args:
#             username (str): The username for permission-based actions.
#             parent (QObject, optional): Parent object for the model. Defaults to None.
#             column_range (list, optional): A list specifying the range of columns. Defaults to None.
#             table_check (str, optional): A text scpecifying the table selected. Defaults to None
#         """
#         super().__init__(parent)
#         self.column_range = column_range
#         self.table_check = table_check

#     def setAllColumnHeaders(self, headers):
#         """
#         Set headers for all columns in the model.

#         Args:
#             headers (list): A list of header names.
#         """
#         for column, header in enumerate(headers):
#             self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

#     def setIndividualColumnHeader(self, column, header):
#         """
#         Set the header for a specific column.

#         Args:
#             column (int): The column index.
#             header (str): The header name.
#         """
#         self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

#     def setIconColumnHeader(self, column, icon):
#         """
#         Set an icon in the header for a specific column.

#         Args:
#             column (int): The column index.
#             icon (QIcon): The icon to display in the header.
#         """
#         self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

#     def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
#         """
#         Retrieve the header data for a specific section of the model.

#         Args:
#             section (int): The section index (column or row).
#             orientation (Qt.Orientation): The orientation (horizontal or vertical).
#             role (Qt.ItemDataRole, optional): The role for the header data. Defaults to DisplayRole.

#         Returns:
#             QVariant: The header data for the specified section.
#         """
#         if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
#             return super().headerData(section, orientation, role)
#         return super().headerData(section, orientation, role)

#     def flags(self, index):
#         """
#         Get the item flags for a given index, controlling editability and selection based on user permissions.

#         Args:
#             index (QModelIndex): The index of the item.

#         Returns:
#             Qt.ItemFlags: The flags for the specified item.
#         """
#         flags = super().flags(index)

#         value = index.model().data(index, role=Qt.ItemDataRole.DisplayRole)

#         if index.column() == 165 and value == 'Facturado' and self.table_check == 'tags_data.tags_flow':
#             flags &= ~Qt.ItemFlag.ItemIsEditable
#             return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
#         elif index.column() == 178 and value == 'Facturado' and self.table_check == 'tags_data.tags_temp':
#             flags &= ~Qt.ItemFlag.ItemIsEditable
#             return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
#         elif index.column() == 175 and value == 'Facturado' and self.table_check == 'tags_data.tags_level':
#             flags &= ~Qt.ItemFlag.ItemIsEditable
#             return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
#         elif index.column() == 65 and value == 'Facturado' and self.table_check == 'tags_data.tags_others':
#             flags &= ~Qt.ItemFlag.ItemIsEditable
#             return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
#         else:
#             if index.column() == 0 or index.column() in self.column_range:
#                 flags &= ~Qt.ItemFlag.ItemIsEditable
#                 return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
#             else:
#                 return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable

#     def getColumnHeaders(self, visible_columns):
#         """
#         Retrieve the headers for the specified visible columns.

#         Args:
#             visible_columns (list): List of column indices that are visible.

#         Returns:
#             list: A list of column headers for the visible columns.
#         """
#         column_headers = [self.headerData(col, Qt.Orientation.Horizontal) for col in visible_columns]
#         return column_headers

class Ui_Report_Offers_View(QtWidgets.QMainWindow):
    """
    A window for editing tags in the application for technical.

    Attributes:
        model (EditableTableModel): The data model for the table.
        proxy (CustomProxyModel): The proxy model for filtering and sorting.
        db (object): Database connection.
        checkbox_states (dict): States of checkboxes.
        dict_valuesuniques (dict): Unique values for columns.
        dict_ordersort (dict): Sorting order for columns.
        hiddencolumns (list): List of hidden column indices.
        action_checkbox_map (dict): Map of actions to checkboxes.
        checkbox_filters (dict): Filters based on checkbox states.
        name (str): Name associated with the window.
        variable (str): Variable used in the window.
    """
    def __init__(self, username, db):
        """
        Initializes the Ui_EditTags_Technical_Window with the specified name and database connection.

        Args:
            name (str): Name associated with the window.
            db (object): Database connection.
        """
        super().__init__()
        self.username = username
        self.variable = ''

        self.model = EditableTableModel(self.username)
        self.proxy = CustomProxyModel()
        # self.model2 = EditableTableModel2()
        # self.proxy2 = CustomProxyModel2()
        self.db = db

        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []
        self.variable = ''
        self.action_checkbox_map = {}
        self.checkbox_filters = {}

        # self.checkbox_states2 = {}
        # self.dict_valuesuniques2 = {}
        # self.dict_ordersort2 = {}
        # self.hiddencolumns2 = []
        # self.variable2 = None
        # self.action_checkbox_map2 = {}
        # self.checkbox_filters2 = {}
        # self.tableEditOffers2 = None

        self.model.dataChanged.connect(self.saveChanges)
        
        self.setupUi(self)

    def closeEvent(self, event):
        """
        Handles the close event to clean up resources.

        Args:
            event (QtGui.QCloseEvent): The close event.
        """
        if self.model:
            self.model.clear()
        # if self.model2:
        #     self.model2.clear()
        self.closeConnection()

    def closeConnection(self):
        """
        Closes the database connection and cleans up resources.
        """
        self.tableEditOffers.setModel(None)
        del self.model
        # if self.tableEditOffers2:
        #     self.tableEditOffers2.setModel(None)
        # del self.model2
        if self.db:
            self.db.close()
            del self.db
            if QtSql.QSqlDatabase.contains("qt_sql_default_connection"):
                QtSql.QSqlDatabase.removeDatabase("qt_sql_default_connection")

    def setupUi(self, Report_Offers_View):
        """
        Sets up the user interface for the Report_Offers_View.

        Args:
            Report_Offers_View (QtWidgets.QMainWindow): The main window for the UI setup.
        """
        Report_Offers_View.setObjectName("Report_Offers_View")
        Report_Offers_View.resize(790, 595)
        Report_Offers_View.setMinimumSize(QtCore.QSize(790, 595))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        Report_Offers_View.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(parent=Report_Offers_View)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_2.setVerticalSpacing(10)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.hcab=QtWidgets.QHBoxLayout()
        self.hcab.setObjectName("hcab")
        # self.toolDeleteFilter = QtWidgets.QToolButton(self.frame)
        # self.toolDeleteFilter.setObjectName("Save_Button")
        # self.hcab.addWidget(self.toolDeleteFilter)
        # icon = QtGui.QIcon()
        # icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Filter_Delete.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        # self.toolDeleteFilter.setIcon(icon)
        # self.toolDeleteFilter.setIconSize(QtCore.QSize(25, 25))
        # self.hcabspacer1=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        # self.hcab.addItem(self.hcabspacer1)
        # self.toolShow = QtWidgets.QToolButton(self.frame)
        # self.toolShow.setObjectName("Show_Button")
        # self.toolShow.setToolTip("Mostrar columnas")
        # self.hcab.addWidget(self.toolShow)
        # icon = QtGui.QIcon()
        # icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Eye.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        # self.toolShow.setIcon(icon)
        # self.toolShow.setIconSize(QtCore.QSize(25, 25))
        # self.hcabspacer2=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        # self.hcab.addItem(self.hcabspacer2)
        # self.toolMatOrder = QtWidgets.QToolButton(self.frame)
        # self.toolMatOrder.setObjectName("MatOrder_Button")
        # self.toolMatOrder.setToolTip("Pedido Materiales")
        # self.hcab.addWidget(self.toolMatOrder)
        # icon = QtGui.QIcon()
        # icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Purchase_Order.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        # self.toolMatOrder.setIcon(icon)
        # self.toolMatOrder.setIconSize(QtCore.QSize(25, 25))
        # self.hcabspacer3=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        # self.hcab.addItem(self.hcabspacer3)
        # self.toolFabOrder = QtWidgets.QToolButton(self.frame)
        # self.toolFabOrder.setObjectName("FabOrder_Button")
        # self.toolFabOrder.setToolTip("Orden Fabricación")
        # self.hcab.addWidget(self.toolFabOrder)
        # icon = QtGui.QIcon()
        # icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Fab_Order.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        # self.toolFabOrder.setIcon(icon)
        # self.toolFabOrder.setIconSize(QtCore.QSize(25, 25))
        # self.hcabspacer4=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        # self.hcab.addItem(self.hcabspacer4)
        # self.toolInspection = QtWidgets.QToolButton(self.frame)
        # self.toolInspection.setObjectName("Inspection_Button")
        # self.toolInspection.setToolTip("Inspeccion")
        # self.hcab.addWidget(self.toolInspection)
        # icon = QtGui.QIcon()
        # icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Inspection.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        # self.toolInspection.setIcon(icon)
        # self.toolInspection.setIconSize(QtCore.QSize(25, 25))
        # self.hcabspacer5=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        # self.hcab.addItem(self.hcabspacer5)
        # self.toolExpExcel = QtWidgets.QToolButton(self.frame)
        # self.toolExpExcel.setObjectName("ExpExcel_Button")
        # self.toolExpExcel.setToolTip("Exportar a Excel")
        # self.hcab.addWidget(self.toolExpExcel)
        # icon = QtGui.QIcon()
        # icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Download.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        # self.toolExpExcel.setIcon(icon)
        # self.toolExpExcel.setIconSize(QtCore.QSize(25, 25))

        # self.hcabspacer7=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        # self.hcab.addItem(self.hcabspacer7)
        # self.toolImpExcel = QtWidgets.QToolButton(self.frame)
        # self.toolImpExcel.setObjectName("ImpExcel_Button")
        # self.toolImpExcel.setToolTip("Importar Excel")
        # self.hcab.addWidget(self.toolImpExcel)
        # icon = QtGui.QIcon()
        # icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Upload.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        # self.toolImpExcel.setIcon(icon)
        # self.toolImpExcel.setIconSize(QtCore.QSize(25, 25))

        # self.hcabspacer6=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        # self.hcab.addItem(self.hcabspacer6)
        # self.generate_dwg = QtWidgets.QToolButton(self.frame)
        # self.generate_dwg.setObjectName("generate_dwg_Button")
        # self.generate_dwg.setToolTip("Generar planos")
        # self.hcab.addWidget(self.generate_dwg)
        # icon = QtGui.QIcon()
        # icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "M_Drawing.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        # self.generate_dwg.setIcon(icon)
        # self.generate_dwg.setIconSize(QtCore.QSize(25, 25))
        

        self.hcabspacer=QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer)
        self.gridLayout_2.addLayout(self.hcab, 0, 0, 1, 1)
        self.hLayout1 = QtWidgets.QHBoxLayout()
        self.hLayout1.setObjectName("hLayout1")
        self.Offer_State_Label = QtWidgets.QLabel(parent=self.frame)
        self.Offer_State_Label.setMinimumSize(QtCore.QSize(80, 25))
        self.Offer_State_Label.setMaximumSize(QtCore.QSize(80, 25))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        self.Offer_State_Label.setFont(font)
        self.Offer_State_Label.setObjectName("Offer_State_Label")
        self.hLayout1.addWidget(self.Offer_State_Label)
        self.Offer_State_Combobox = QtWidgets.QComboBox(parent=self.frame)
        self.Offer_State_Combobox.setMinimumSize(QtCore.QSize(250, 25))
        self.Offer_State_Combobox.setMaximumSize(QtCore.QSize(250, 25))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.Offer_State_Combobox.setFont(font)
        self.Offer_State_Combobox.setObjectName("Offer_State_Combobox")
        self.hLayout1.addWidget(self.Offer_State_Combobox)
        self.Count_Label = QtWidgets.QLabel(parent=self.frame)
        self.Count_Label.setMinimumSize(QtCore.QSize(80, 25))
        self.Count_Label.setMaximumSize(QtCore.QSize(80, 25))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        self.Count_Label.setFont(font)
        self.Count_Label.setObjectName("Count_Label")
        self.Count_Label.setText("Recuento:")
        self.hLayout1.addWidget(self.Count_Label)
        self.Count_Value_Label = QtWidgets.QLabel(parent=self.frame)
        self.Count_Value_Label.setMinimumSize(QtCore.QSize(80, 25))
        self.Count_Value_Label.setMaximumSize(QtCore.QSize(80, 25))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        self.Count_Value_Label.setFont(font)
        self.Count_Value_Label.setObjectName("Count_Value_Label")
        self.hLayout1.addWidget(self.Count_Value_Label)
        self.Amount_Label = QtWidgets.QLabel(parent=self.frame)
        self.Amount_Label.setMinimumSize(QtCore.QSize(80, 25))
        self.Amount_Label.setMaximumSize(QtCore.QSize(80, 25))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        self.Amount_Label.setFont(font)
        self.Amount_Label.setObjectName("Amount_Label")
        self.Amount_Label.setText("Importe:")
        self.hLayout1.addWidget(self.Amount_Label)
        self.Amount_Value_Label = QtWidgets.QLabel(parent=self.frame)
        self.Amount_Value_Label.setMinimumSize(QtCore.QSize(150, 25))
        self.Amount_Value_Label.setMaximumSize(QtCore.QSize(150, 25))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        self.Amount_Value_Label.setFont(font)
        self.Amount_Value_Label.setObjectName("Amount_Value_Label")
        self.hLayout1.addWidget(self.Amount_Value_Label)


        self.gridLayout_2.addLayout(self.hLayout1, 1, 0, 1, 1)
        self.tableEditOffers=QtWidgets.QTableView(parent=self.frame)
        self.model = EditableTableModel(self.username)
        self.tableEditOffers.setObjectName("tableEditOffers")
        self.gridLayout_2.addWidget(self.tableEditOffers, 3, 0, 1, 1)
        self.hLayout3 = QtWidgets.QHBoxLayout()
        self.hLayout3.setObjectName("hLayout3")
        spacerItem2 = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hLayout3.addItem(spacerItem2)
        self.label_SumItems = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setText("")
        self.label_SumItems.setObjectName("label_SumItems")
        self.hLayout3.addWidget(self.label_SumItems)
        self.label_SumValue = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setText("")
        self.label_SumValue.setObjectName("label_SumValue")
        self.hLayout3.addWidget(self.label_SumValue)
        self.label_CountItems = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setText("")
        self.label_CountItems.setObjectName("label_CountItems")
        self.hLayout3.addWidget(self.label_CountItems)
        self.label_CountValue = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setText("")
        self.label_CountValue.setObjectName("label_CountValue")
        self.hLayout3.addWidget(self.label_CountValue)
        self.gridLayout_2.addLayout(self.hLayout3, 4, 0, 1, 1)
        self.hLayout4 = QtWidgets.QHBoxLayout()
        self.hLayout4.setObjectName("hLayout4")
        spacerItem1 = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hLayout4.addItem(spacerItem1)
        self.label_SumItems2 = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems2.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems2.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems2.setText("")
        self.label_SumItems2.setObjectName("label_SumItems2")
        self.hLayout4.addWidget(self.label_SumItems2)
        self.label_SumValue2 = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue2.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue2.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue2.setText("")
        self.label_SumValue2.setObjectName("label_SumValue2")
        self.hLayout4.addWidget(self.label_SumValue2)
        self.label_CountItems2 = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems2.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems2.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems2.setText("")
        self.label_CountItems2.setObjectName("label_CountItems2")
        self.hLayout4.addWidget(self.label_CountItems2)
        self.label_CountValue2 = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue2.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue2.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue2.setText("")
        self.label_CountValue2.setObjectName("label_CountValue2")
        self.hLayout4.addWidget(self.label_CountValue2)
        self.gridLayout_2.addLayout(self.hLayout4, 6, 0, 1, 1)

        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 0, 0, 1, 1)
        self.gridLayout.addWidget(self.frame, 0, 0, 1, 1)
        Report_Offers_View.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=Report_Offers_View)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 790, 22))
        self.menubar.setObjectName("menubar")
        Report_Offers_View.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=Report_Offers_View)
        self.statusbar.setObjectName("statusbar")
        Report_Offers_View.setStatusBar(self.statusbar)

        self.retranslateUi(Report_Offers_View)
        QtCore.QMetaObject.connectSlotsByName(Report_Offers_View)
        # self.Button_Query.clicked.connect(self.query_data)
        # self.toolDeleteFilter.clicked.connect(self.delete_allFilters)
        # self.toolShow.clicked.connect(self.show_columns)
        # self.toolMatOrder.clicked.connect(self.materialorder)
        # self.toolFabOrder.clicked.connect(self.faborder)
        # self.toolInspection.clicked.connect(self.setinspection)
        # self.toolExpExcel.clicked.connect(self.exporttoexcel)
        # self.toolImpExcel.clicked.connect(self.importexcel)
        # self.generate_dwg.clicked.connect(self.generate_drawings)
        self.Offer_State_Combobox.currentTextChanged.connect(self.query_data)
        self.model.dataChanged.connect(self.saveChanges)

        list_states=['', 'Semanal', 'Registrada', 'Presentada <=30 días', 'Presentada >30 días','Budgetary']
        self.Offer_State_Combobox.addItems(list_states)

        commands_comboboxes = [
            "SELECT client_name FROM public.clients_list ORDER BY client_name ASC",
            "SELECT material FROM public.product_type ORDER BY material ASC",
            ]

        self.all_results = []

        query_commercial = ("""
                        select username
                        from users_data.registration
                        where profile = 'Comercial'
                        order by username ASC""")

        try:
            with Database_Connection(config_database()) as conn:
                with conn.cursor() as cur:
                    for query in commands_comboboxes:
                        cur.execute(query)
                        results=cur.fetchall()
                        self.all_results.append(results)

                        cur.execute(query_commercial)
                        results_commercial=cur.fetchall()

                        self.list_commercial=[x[0] for x in results_commercial]
                        self.list_commercial.append('m.sahuquillo')
                        self.list_commercial.append('julian.martinez')

        except (Exception, psycopg2.DatabaseError) as error:
            MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "critical")

# Function to translate and updates the text of various UI elements
    def retranslateUi(self, Report_Offers_View):
        """
        Translates and updates the text of various UI elements.
        """
        _translate = QtCore.QCoreApplication.translate
        Report_Offers_View.setWindowTitle(_translate("Report_Offers_View", "Informe Ofertas"))
        self.tableEditOffers.setSortingEnabled(True)
        self.Offer_State_Label.setText(_translate("Report_Offers_View", "Informe:"))

# Function to delete all filters when tool button is clicked
    def delete_allFilters(self):
        """
        Resets all filters and updates the table model with unique values for each column.
        """
        if self.proxy.rowCount() != 0:
            columns_number=self.model.columnCount()
            for index in range(columns_number):
                if index in self.proxy.filters:
                    del self.proxy.filters[index]
                self.model.setIconColumnHeader(index, '')

            self.checkbox_states = {}
            self.dict_valuesuniques = {}
            self.dict_ordersort = {}
            self.checkbox_filters = {}

            self.proxy.invalidateFilter()
            # self.tableEditOffers.setModel(None)
            self.tableEditOffers.setModel(self.proxy)

            # Getting the unique values for each column of the model
            for column in range(self.model.columnCount()):
                list_valuesUnique = []
                if column not in self.checkbox_states:
                    self.checkbox_states[column] = {}
                    self.checkbox_states[column]['Seleccionar todo'] = True
                    for row in range(self.model.rowCount()):
                        value = self.model.record(row).value(column)
                        if value not in list_valuesUnique:
                            if isinstance(value, QtCore.QDate):
                                value=value.toString("dd/MM/yyyy")
                            list_valuesUnique.append(str(value))
                            self.checkbox_states[column][value] = True
                    self.dict_valuesuniques[column] = list_valuesUnique

            self.tableEditOffers.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditOffers.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditOffers.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

        # if self.proxy2.rowCount() != 0:
        #     columns_number=self.model2.columnCount()
        #     for index in range(columns_number):
        #         if index in self.proxy2.filters:
        #             del self.proxy2.filters[index]
        #         self.model2.setIconColumnHeader(index, '')

        #     self.checkbox_states = {}
        #     self.dict_valuesuniques = {}
        #     self.dict_ordersort = {}
        #     self.checkbox_filters = {}

        #     self.proxy2.invalidateFilter()
        #     # self.tableEditOffers.setModel(None)
        #     self.tableEditOffers2.setModel(self.proxy2)

        #     # Getting the unique values for each column of the model
        #     for column in range(self.model2.columnCount()):
        #         list_valuesUnique = []
        #         if column not in self.checkbox_states:
        #             self.checkbox_states[column] = {}
        #             self.checkbox_states[column]['Seleccionar todo'] = True
        #             for row in range(self.model2.rowCount()):
        #                 value = self.model2.record(row).value(column)
        #                 if value not in list_valuesUnique:
        #                     if isinstance(value, QtCore.QDate):
        #                         value=value.toString("dd/MM/yyyy")
        #                     list_valuesUnique.append(str(value))
        #                     self.checkbox_states[column][value] = True
        #             self.dict_valuesuniques[column] = list_valuesUnique

        #     self.tableEditOffers2.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        #     self.tableEditOffers2.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        #     self.tableEditOffers2.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function to save changes into database
    def saveChanges(self):
        """
        Saves changes made to the data models and updates unique values for each column.
        """
        self.model.submitAll()

        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            for row in range(self.model.rowCount()):
                value = self.model.record(row).value(column)
                if value not in list_valuesUnique:
                    if isinstance(value, QtCore.QDate):
                        value=value.toString("dd/MM/yyyy")
                    list_valuesUnique.append(str(value))
                    if value not in self.checkbox_states[column]:
                        self.checkbox_states[column][value] = True
            self.dict_valuesuniques[column] = list_valuesUnique

        # self.model2.submitAll()

        # for column in range(self.model2.columnCount()):
        #     list_valuesUnique2 = []
        #     for row in range(self.model2.rowCount()):
        #         value = self.model2.record(row).value(column)
        #         if value not in list_valuesUnique2:
        #             if isinstance(value, QtCore.QDate):
        #                 value=value.toString("dd/MM/yyyy")
        #             list_valuesUnique2.append(str(value))
        #             if value not in self.checkbox_states2[column]:
        #                 self.checkbox_states2[column][value] = True
        #     self.dict_valuesuniques2[column] = list_valuesUnique2

# Function to load table and setting in the window
    def query_data(self):
        """
        Queries the database based on the selected option, configures and populates tables with the query results, 
        and updates the UI accordingly. Handles potential database errors and updates the UI with appropriate messages.
        """
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []
        self.original_headers = []

        self.model.dataChanged.disconnect(self.saveChanges)
        self.state = self.Offer_State_Combobox.currentText()

        if self.state=="":
            MessageHelper.show_message("Elige una opcion", "warning")
            self.model.dataChanged.connect(self.saveChanges)

        else:
            self.model.setTable("public.offers")
            if '>' in self.state:
                self.model.setFilter(f"num_offer NOT LIKE '%B-%' AND state = 'Presentada' AND presentation_date < CURRENT_DATE - INTERVAL '30 days'")
            elif '<=' in self.state:
                self.model.setFilter(f"num_offer NOT LIKE '%B-%' AND state = 'Presentada' AND presentation_date >= CURRENT_DATE - INTERVAL '30 days'")
            elif self.state == 'Budgetary':
                self.model.setFilter(f"num_offer LIKE '%B-%' AND (EXTRACT(YEAR FROM register_date) = EXTRACT(YEAR FROM CURRENT_DATE))")
            elif self.state == 'Semanal':
                self.model.setFilter(f"recep_date >= CURRENT_DATE - INTERVAL '6 days' AND recep_date <= CURRENT_DATE")
            else:
                self.model.setFilter(f"state = '{self.state}'")
            self.model.setSort(0, QtCore.Qt.SortOrder.AscendingOrder)
            self.tableEditOffers.setModel(None)
            self.tableEditOffers.setModel(self.proxy)
            self.model.select()

            self.proxy.setSourceModel(self.model)
            self.tableEditOffers.setModel(self.proxy)

            columns_number=self.model.columnCount()

            self.tableEditOffers.hideColumn(6)
            self.tableEditOffers.hideColumn(7)
            self.tableEditOffers.hideColumn(12)
            for i in range(15, 31):
                self.tableEditOffers.hideColumn(i)
            for i in range(35,columns_number):
                self.tableEditOffers.hideColumn(i)
            self.tableEditOffers.hideColumn(32)

            # self.tableEditOffers.verticalHeader().hide()
            self.tableEditOffers.setItemDelegate(AlignDelegate(self.tableEditOffers))
            self.color_delegate = ColorDelegate_PresentationDate(self)
            self.tableEditOffers.setItemDelegateForColumn(9, self.color_delegate)
            self.tableEditOffers.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditOffers.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditOffers.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditOffers.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditOffers.horizontalHeader().setSectionResizeMode(4, QtWidgets.QHeaderView.ResizeMode.Stretch)
            self.tableEditOffers.horizontalHeader().setSectionResizeMode(5, QtWidgets.QHeaderView.ResizeMode.Stretch)
            self.tableEditOffers.horizontalHeader().setSectionResizeMode(13, QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditOffers.horizontalHeader().setSectionResizeMode(33, QtWidgets.QHeaderView.ResizeMode.Stretch)
            self.tableEditOffers.horizontalHeader().setSectionResizeMode(34, QtWidgets.QHeaderView.ResizeMode.Stretch)
            self.tableEditOffers.verticalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditOffers.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid;}")
            self.tableEditOffers.setStyleSheet("gridline-color: #CCCCCC")
            self.tableEditOffers.setObjectName("tableEditOffers")
            self.gridLayout_2.addWidget(self.tableEditOffers, 3, 0, 1, 1)
            self.tableEditOffers.setSortingEnabled(False)
            self.tableEditOffers.horizontalHeader().sectionDoubleClicked.connect(lambda logicalIndex: self.on_view_horizontalHeader_sectionClicked(logicalIndex, self.tableEditOffers, self.model, self.proxy))
            self.tableEditOffers.horizontalHeader().setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)

        # Change all column names
            headers_offers = ["OFERTA", "ESTADO", "RESP.", "CALC.", "CLIENTE", "CLIENTE FINAL", "Nº REF. OFERTA",
                            "F. REG.", "F. REC.", "F. PRES.", "F. VTO.", "PROB.", "PRIOR.", "MATERIAL", "Nº EQ.",
                            "Nac/Ext", "Comprador", "Portal", "Tarifa", "Mails", "Veces Rec.", "Ult. Rec.", "Tipo Rec.",
                            "Ult. Act.", "Validez", "Tiempo Entrega", "Forma Entrega", "Proyecto", "Forma Pago",
                            "Ult. Rev.", "F. Ult. Rev.", "IMPORTE", "Importante", "SEGUIMIENTO", "ACCIONES", "Notas", "Año", "Mes"]

            self.original_headers = [self.model.headerData(col, QtCore.Qt.Orientation.Horizontal) for col in range(self.model.columnCount())]

            self.model.setAllColumnHeaders(headers_offers)

        # Getting the unique values for each column of the model
            for column in range(self.model.columnCount()):
                list_valuesUnique = []
                if column not in self.checkbox_states:
                    self.checkbox_states[column] = {}
                    self.checkbox_states[column]['Seleccionar todo'] = True
                    for row in range(self.model.rowCount()):
                        value = self.model.record(row).value(column)
                        if value not in list_valuesUnique:
                            if isinstance(value, QtCore.QDate):
                                value=value.toString("dd/MM/yyyy")
                            list_valuesUnique.append(str(value))
                            self.checkbox_states[column][value] = True
                    self.dict_valuesuniques[column] = list_valuesUnique

        # Setting cells with comboboxes
            list_offer_state = ['Adjudicada', 'Budgetary', 'Declinada', 'En Estudio', 'No Ofertada', 'Presentada', 'Perdida', 'Registrada', 'Retirada']
            list_calculations = ['N/A', 'e.carrillo', 'e.serrano']
            list_probabilty = ['Alta', 'Media', 'Baja']

            self.combo_itemtype = EditableComboBoxDelegate(self.tableEditOffers, list_offer_state)
            self.tableEditOffers.setItemDelegateForColumn(1, self.combo_itemtype)
            self.combo_itemtype = EditableComboBoxDelegate(self.tableEditOffers, self.list_commercial)
            self.tableEditOffers.setItemDelegateForColumn(2, self.combo_itemtype)
            self.combo_itemtype = EditableComboBoxDelegate(self.tableEditOffers, list_calculations)
            self.tableEditOffers.setItemDelegateForColumn(3, self.combo_itemtype)
            self.combo_itemtype = EditableComboBoxDelegate(self.tableEditOffers, sorted([x[0] for x in self.all_results[0]]))
            self.tableEditOffers.setItemDelegateForColumn(4, self.combo_itemtype)
            self.combo_itemtype = EditableComboBoxDelegate(self.tableEditOffers, list_probabilty)
            self.tableEditOffers.setItemDelegateForColumn(11, self.combo_itemtype)
            self.combo_itemtype = EditableComboBoxDelegate(self.tableEditOffers, sorted([x[0] for x in self.all_results[1]]))
            self.tableEditOffers.setItemDelegateForColumn(13, self.combo_itemtype)

            self.tableEditOffers.sortByColumn(1, QtCore.Qt.SortOrder.AscendingOrder)

            self.model.dataChanged.connect(self.saveChanges)
            self.selection_model = self.tableEditOffers.selectionModel()
            self.selection_model.selectionChanged.connect(lambda: self.countSelectedCells(self.model))

            self.Count_Value_Label.setText(str(self.calculate_summary_values()[0]))
            self.Amount_Value_Label.setText(self.calculate_summary_values()[1] + " €")

# Function when header is clicked
    def on_view_horizontalHeader_sectionClicked(self, logicalIndex, table, model, proxy):
        """
        Displays a menu when a column header is clicked. The menu includes options for sorting, filtering, and managing column visibility.
        
        Args:
            logicalIndex (int): Index of the clicked column.
            table (QtWidgets.QTableView): The table view displaying the data.
            model (QtGui.QStandardItemModel): The model associated with the table.
            proxy (QtCore.QSortFilterProxyModel): The proxy model used for filtering and sorting.
        """
        self.logicalIndex = logicalIndex
        self.menuValues = QtWidgets.QMenu(self)
        self.signalMapper = QtCore.QSignalMapper(table)

        valuesUnique_view = {table.model().index(row, self.logicalIndex).data(Qt.ItemDataRole.DisplayRole) for row in range(table.model().rowCount())}
        valuesUnique_view = [value.toString("dd/MM/yyyy") if isinstance(value, QtCore.QDate) else value for value in valuesUnique_view]

        actionSortAscending = QtGui.QAction("Ordenar Ascendente", table)
        actionSortAscending.triggered.connect(lambda: self.on_actionSortAscending_triggered(table))
        self.menuValues.addAction(actionSortAscending)
        actionSortDescending = QtGui.QAction("Ordenar Descendente", table)
        actionSortDescending.triggered.connect(lambda: self.on_actionSortDescending_triggered(table))
        self.menuValues.addAction(actionSortDescending)
        self.menuValues.addSeparator()

        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro", table)
        actionDeleteFilterColumn.triggered.connect(lambda: self.on_actionDeleteFilterColumn_triggered(table, model, proxy))
        self.menuValues.addAction(actionDeleteFilterColumn)
        self.menuValues.addSeparator()

        actionTextFilter = QtGui.QAction("Buscar...", table)
        actionTextFilter.triggered.connect(lambda: self.on_actionTextFilter_triggered(model, proxy))
        self.menuValues.addAction(actionTextFilter)
        self.menuValues.addSeparator()

        scroll_menu = QtWidgets.QScrollArea()
        scroll_menu.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget(scroll_menu)
        scroll_menu.setWidget(scroll_widget)
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        checkbox_all_widget = QtWidgets.QCheckBox('Seleccionar todo')

        if not self.checkbox_states[self.logicalIndex]['Seleccionar todo'] == True:
            checkbox_all_widget.setChecked(False)
        else:
            checkbox_all_widget.setChecked(True)
        
        checkbox_all_widget.toggled.connect(lambda checked, name='Seleccionar todo': self.on_select_all_toggled(checked, name, model))

        scroll_layout.addWidget(checkbox_all_widget)
        self.action_checkbox_map['Seleccionar todo'] = checkbox_all_widget

        if len(self.dict_ordersort) != 0 and self.logicalIndex in self.dict_ordersort:
            list_uniquevalues = sorted(list(set(self.dict_valuesuniques[self.logicalIndex])))
        else:
            list_uniquevalues = sorted(list(set(valuesUnique_view)))

        for actionName in list_uniquevalues:
            checkbox_widget = QtWidgets.QCheckBox(str(actionName))

            if self.logicalIndex not in self.checkbox_filters:
                checkbox_widget.setChecked(True)
            elif actionName not in self.checkbox_filters[self.logicalIndex]:
                checkbox_widget.setChecked(False)
            else:
                checkbox_widget.setChecked(True)

            checkbox_widget.toggled.connect(lambda checked, name=actionName: self.on_checkbox_toggled(checked, name, model))

            scroll_layout.addWidget(checkbox_widget)
            self.action_checkbox_map[actionName] = checkbox_widget

        action_scroll_menu = QtWidgets.QWidgetAction(self.menuValues)
        action_scroll_menu.setDefaultWidget(scroll_menu)
        self.menuValues.addAction(action_scroll_menu)

        self.menuValues.addSeparator()

        accept_button = QtGui.QAction("ACEPTAR", table)
        accept_button.triggered.connect(lambda: self.menu_acceptbutton_triggered(proxy))

        cancel_button = QtGui.QAction("CANCELAR", table)
        cancel_button.triggered.connect(self.menu_cancelbutton_triggered)

        self.menuValues.addAction(accept_button)
        self.menuValues.addAction(cancel_button)

        self.menuValues.setStyleSheet("QMenu::item:selected { background-color: #33bdef; }"
                                        "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

        headerPos = table.mapToGlobal(table.horizontalHeader().pos())        

        posY = headerPos.y() + table.horizontalHeader().height()
        scrollX = table.horizontalScrollBar().value()
        xInView = table.horizontalHeader().sectionViewportPosition(logicalIndex)
        posX = headerPos.x() + xInView - scrollX

        self.menuValues.exec(QtCore.QPoint(posX, posY))

# Function when cancel button of menu is clicked
    def menu_cancelbutton_triggered(self):
        """
        Hides the menu when the cancel button is clicked.
        """
        self.menuValues.hide()

# Function when accept button of menu is clicked
    def menu_acceptbutton_triggered(self, proxy):
        """
        Applies the selected filters and updates the table model with the new filters.
        """
        # if isinstance(proxy, CustomProxyModel2):
        #     for column, filters in self.checkbox_filters2.items():
        #         if filters:
        #             proxy.setFilter(filters, column, exact_match=True)
        #         else:
        #             proxy.setFilter(None, column)
        # else:
        for column, filters in self.checkbox_filters.items():
            if filters:
                proxy.setFilter(filters, column, exact_match=True)
            else:
                proxy.setFilter(None, column)

        # self.tableEditOffers.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        # self.tableEditOffers.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        # self.tableEditOffers.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function when select all checkbox is clicked
    def on_select_all_toggled(self, checked, action_name, model):
        """
        Toggles the state of all checkboxes in the filter menu when the 'Select All' checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the 'Select All' checkbox.
            action_name (str): The name of the action (usually 'Select All').
            model (QAbstractItemModel): The model associated with the table view.
        """
        filterColumn = self.logicalIndex

    # Load icon
        if not hasattr(self, 'icono_filter_active'):
            imagen_path = str(get_path("Resources", "Iconos", "Filter_Active.png"))
            self.icono_filter_active = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
        
    # Select map and state related to model
        checkbox_map = self.action_checkbox_map #if not isinstance(model, EditableTableModel2) else self.action_checkbox_map2
        checkbox_states = self.checkbox_states #if not isinstance(model, EditableTableModel2) else self.checkbox_states2

    # Change state of checkboxes if necessary
        for checkbox_name, checkbox_widget in checkbox_map.items():
            if checkbox_widget.isChecked() != checked:
                checkbox_widget.setChecked(checked)
                checkbox_states[self.logicalIndex][checkbox_widget.text()] = checked

    # Adjust icon of header
        all_checked = all(checkbox_widget.isChecked() for checkbox_widget in checkbox_map.values())
        model.setIconColumnHeader(filterColumn, self.icono_filter_active if all_checked else '')

# Function when checkbox of header menu is clicked
    def on_checkbox_toggled(self, checked, action_name, model):
        """
        Updates the filter state when an individual checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the checkbox.
            action_name (str): The name of the checkbox.
        """
        filterColumn = self.logicalIndex
        imagen_path = str(get_path("Resources", "Iconos", "Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            if filterColumn not in self.checkbox_filters:
                self.checkbox_filters[filterColumn] = [action_name]
            else:
                if action_name not in self.checkbox_filters[filterColumn]:
                    self.checkbox_filters[filterColumn].append(action_name)
        else:
            if filterColumn in self.checkbox_filters and action_name in self.checkbox_filters[filterColumn]:
                self.checkbox_filters[filterColumn].remove(action_name)

        if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
            model.setIconColumnHeader(filterColumn, '')
        else:
            model.setIconColumnHeader(filterColumn, icono)

# Function to delete individual column filter
    def on_actionDeleteFilterColumn_triggered(self, table, model, proxy):
        """
        Removes the filter from the selected column and updates the table model.
        
        Args:
            table (QtWidgets.QTableView): The table view displaying the data.
            model (QtGui.QStandardItemModel): The model associated with the table.
            proxy (QtCore.QSortFilterProxyModel): The proxy model used for filtering and sorting.
        """
        filterColumn = self.logicalIndex
        if filterColumn in proxy.filters:
            del proxy.filters[filterColumn]
        model.setIconColumnHeader(filterColumn, "")
        proxy.invalidateFilter()

        if filterColumn in self.checkbox_filters:
            del self.checkbox_filters[filterColumn]

        self.checkbox_states[self.logicalIndex].clear()
        self.checkbox_states[self.logicalIndex]["Seleccionar todo"] = True
        for row in range(table.model().rowCount()):
            value = model.record(row).value(filterColumn)
            if isinstance(value, QtCore.QDate):
                value = value.toString("dd/MM/yyyy")
            self.checkbox_states[self.logicalIndex][str(value)] = True

        table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        table.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        table.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

        self.selection_model = table.selectionModel()
        self.selection_model.selectionChanged.connect(self.countSelectedCells)

        self.label_SumItems.setText("")
        self.label_SumValue.setText("")
        self.label_CountItems.setText("")
        self.label_CountValue.setText("")

# Function to order column ascending
    def on_actionSortAscending_triggered(self, table):
        """
        Sorts the selected column in ascending order.
        
        Args:
            table (QtWidgets.QTableView): The table view displaying the data.
        """
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.AscendingOrder
        table.sortByColumn(sortColumn, sortOrder)

# Function to order column descending
    def on_actionSortDescending_triggered(self, table):
        """
        Sorts the selected column in descending order.
        
        Args:
            table (QtWidgets.QTableView): The table view displaying the data.
        """
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.DescendingOrder
        table.sortByColumn(sortColumn, sortOrder)

# Function when text is searched
    def on_actionTextFilter_triggered(self, model, proxy):
        """
        Opens a dialog to enter a text filter and applies it to the selected column.
        
        Args:
            model (QtGui.QStandardItemModel): The model associated with the table.
            proxy (QtCore.QSortFilterProxyModel): The proxy model used for filtering and sorting.
        """
        filterColumn = self.logicalIndex
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle("Buscar")
        clickedButton = dlg.exec()

        if clickedButton == 1:
            stringAction = dlg.textValue()
            if re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', stringAction):
                stringAction=QtCore.QDate.fromString(stringAction,"dd/MM/yyyy")
                stringAction=stringAction.toString("yyyy-MM-dd")

            filterString = QtCore.QRegularExpression(stringAction, QtCore.QRegularExpression.PatternOption(0))
            # del self.proxy.filters[filterColumn]
            proxy.setFilter([stringAction], filterColumn, None)

            imagen_path = str(get_path("Resources", "Iconos", "Filter_Active.png"))
            icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
            model.setIconColumnHeader(filterColumn, icono)

# Function to export data to excel
    def exporttoexcel(self):
        """
        Exports the visible data from the table to an Excel file. If no data is loaded, displays a warning message.

        Shows a message box if there is no data to export and allows the user to save the data to an Excel file.
        """
        if self.proxy.rowCount() == 0:
            MessageHelper.show_message("No hay datos cargados", "warning")
        else:
            final_data = []

            visible_columns = [col for col in range(self.model.columnCount()) if not self.tableEditOffers.isColumnHidden(col)]
            visible_headers = self.model.getColumnHeaders(visible_columns)
            original_headers = [self.model.record().fieldName(col) for col in visible_columns]
            for row in range(self.proxy.rowCount()):
                tag_data = []
                for column in visible_columns:
                    value = self.proxy.data(self.proxy.index(row, column))
                    if isinstance(value, QDate):
                        value = value.toString("dd/MM/yyyy")
                    elif column in [55] and self.variable == 'Caudal':
                        value = int(value) if value != '' else 0
                    elif column in [15,16,41,42,70,71,72,73] and self.variable == 'Temperatura':
                        value = int(value) if value != '' else 0
                    tag_data.append(value)
                final_data.append(tag_data)

            final_data.insert(0, visible_headers)
            final_data.insert(1, original_headers)
            df = pd.DataFrame(final_data)
            df.columns = df.iloc[0]
            df = df[1:]

            output_path, _ = QtWidgets.QFileDialog.getSaveFileName(None, "Guardar Excel", "", "Archivos de Excel (*.xlsx)")
            if output_path:
                if not output_path.lower().endswith(".xlsx"):
                    output_path += ".xlsx"
                df.to_excel(output_path, index=False, header=True)

# Function to enable copy and paste cells
    def keyPressEvent(self, event):
        """
        Handles custom key events for cell operations in the table.

        Args:
            event (QtGui.QKeyEvent): The key event to handle.
        """
        if event.matches(QKeySequence.StandardKey.Copy):
            selected_indexes = self.tableEditOffers.selectionModel().selectedIndexes()
            if selected_indexes:
                clipboard = QApplication.clipboard()
                text = self.get_selected_text(selected_indexes)
                if isinstance(text, QtCore.QDate):
                    text=text.toString("dd/MM/yyyy")
                clipboard.setText(str(text))

        elif event.matches(QKeySequence.StandardKey.Paste):
            self.model.dataChanged.disconnect(self.saveChanges)
            selected_indexes = self.tableEditOffers.selectionModel().selectedIndexes()
            if selected_indexes:
                clipboard = QApplication.clipboard()
                text = clipboard.text()
                for index in selected_indexes:
                    current_row = index.row()
                    current_column = index.column()
                    first_column_value = self.proxy.data(self.proxy.index(current_row, 0))
                    target_row = None
                    for row in range(self.model.rowCount()):
                        if self.model.data(self.model.index(row, 0)) == first_column_value:
                            target_row = row
                            break
                    if target_row is not None:
                        target_index = self.model.index(target_row, current_column)
                        self.model.setData(target_index, text, Qt.ItemDataRole.EditRole)  # Pegar el valor en todas las celdas seleccionadas
                self.model.submitAll()

            self.model.dataChanged.connect(self.saveChanges)

        super().keyPressEvent(event)

# Function to get the text of the selected cells
    def get_selected_text(self, indexes):
        """
        Retrieves the text from the selected cells and returns it as a plain text string.

        Args:
            indexes (list of QModelIndex): A list of QModelIndex objects representing the selected cells.
        
        Returns:
            str: A string containing the text from the selected cells.
        """
        """
        Retrieves the text from the selected cells and returns it as a plain text string.

        Args:
            indexes (list of QModelIndex): A list of QModelIndex objects representing the selected cells.
        
        Returns:
            str: A string containing the text from the selected cells.
        """
        if len(indexes) == 1: # For only one cell selected
            index = indexes[0]
            cell_data = index.data(Qt.ItemDataRole.DisplayRole)
            return cell_data
        else:
            rows = set()
            cols = set()
            for index in indexes:
                rows.add(index.row())
                cols.add(index.column())

            text_doc = QTextDocument()
            cursor = QTextCursor(text_doc)

            for row in sorted(rows):
                for col in sorted(cols):
                    index = self.model.index(row, col)  # Obtain corresponding index
                    cell_data = index.data(Qt.ItemDataRole.DisplayRole)
                    cursor.insertText(str(cell_data))
                    cursor.insertText('\t')  # Tab separating columns
                cursor.insertText('\n')  # Line break at end of row

            return text_doc.toPlainText()

# Function to count selected cells and sum its values
    def countSelectedCells(self, model):
        """
        Counts the number of selected cells and sums their values. Updates the UI labels with the count and sum.
        """
        if len(self.tableEditOffers.selectedIndexes()) > 1:
            locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

            sum_value = sum([self.euro_string_to_float(str(ix.data())) if re.match(r'^[\d.,]+\s€$', str(ix.data())) else float(str(ix.data()).replace(',', '.')) if str(ix.data()).replace(',', '.').replace('.', '', 1).isdigit() else 0 for ix in self.tableEditOffers.selectedIndexes()])
            count_value = len([ix for ix in self.tableEditOffers.selectedIndexes() if ix.data() != ""])
            if sum_value > 0:
                self.label_SumItems.setText("Suma:")
                self.label_SumValue.setText(locale.format_string("%.2f", sum_value, grouping=True))
            if count_value > 0:
                self.label_CountItems.setText("Recuento:")
                self.label_CountValue.setText(str(count_value))
        else:
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

# Function to format money string values
    def euro_string_to_float(self, euro_str):
        """
        Converts a string representing an amount in euros to a float.

        Args:
            euro_str (str): A string representing the amount in euros (e.g., "1.234,56 €").
        
        Returns:
            float: The numeric value of the amount as a float.
        """
        match = re.match(r'^([\d.,]+)\s€$', euro_str)
        if match:
            number_str = match.group(1)
            number_str = number_str.replace('.', '').replace(',', '.')
            return float(number_str)
        else:
            return 0.0

# Function to calculate summary values
    def calculate_summary_values(self):
        """
        Calculates the total count of items and the total amount from the offers table.
        """
        locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')

        count_value = self.model.rowCount()

    # Calculate total amount
        model = self.tableEditOffers.model()

        sum_value = 0
        for row in range(model.rowCount()):
            ix = model.index(row, 31)
            val = str(ix.data())

            if re.match(r'^[\d.,]+\s€$', val):
                sum_value += self.euro_string_to_float(val)
            elif val.replace(',', '.').replace('.', '', 1).isdigit():
                sum_value += float(val.replace(',', '.'))

        return [count_value, locale.format_string("%.2f", sum_value, grouping=True)]



if __name__ == "__main__":
    import sys
    import os

    ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    if ROOT not in sys.path:
        sys.path.insert(0, ROOT)
    app = QtWidgets.QApplication(sys.argv)
    dbparam = config_database()
    user_database = dbparam["user"]
    password_database = dbparam["password"]

    db = Create_DBconnection(user_database, password_database)
    if not db:
        sys.exit()

    Report_Offers_View = Ui_Report_Offers_View('j.martinez',db)
    Report_Offers_View.show()
    sys.exit(app.exec())