# Form implementation generated from reading ui file 'EditTags_Commercial_Window.ui'
#
# Created by: PySide6 UI code generator 6.4.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PySide6 import QtCore, QtGui, QtWidgets
from PySide6 import QtSql
from PySide6.QtWidgets import QApplication
from PySide6.QtCore import Qt, QDate
from PySide6.QtGui import QKeySequence, QTextDocument, QTextCursor
from windows.Create_FabOrder_Window import Ui_CreateFabOrder_Window
from windows.Create_MatOrder import flow_matorder, temp_matorder, level_matorder, others_matorder
from windows.Create_Inspection import inspection
from utils.Database_Manager import Create_DBconnection, Database_Connection
from config.config_functions import config_database, get_path
import psycopg2
import re
import locale
from datetime import *
import os
import pandas as pd
from fpdf import FPDF
from pypdf import PdfReader, PdfWriter
import io
from utils.Show_Message import MessageHelper
from config.config_keys import ORDERS_PATH
from windows.overlay_pdf import (dwg_dim_flange_plate, dwg_dim_plate, dwg_dim_ro, dwg_dim_ms_ro, dwg_dim_mrun,
                                dwg_of_op_ro_rf,
                                drawing_number_landscape_x, drawing_number_x, flange_dwg_orifice)
from psycopg2 import sql
from psycopg2.extras import execute_batch
from pathlib import Path

STANDARD_TW_DIAMS = [35, 38, 40, 42, 45, 48, 50]


def imagen_to_base64(imagen):
    """
    Converts an image in PNG format to a base64 encoded string.

    Args:
        imagen: An instance of QImage or QPixmap to be converted.
    Return: 
        A base64 encoded string representing the image in PNG format.
    """
    buffer = QtCore.QBuffer()
    buffer.open(QtCore.QIODevice.OpenModeFlag.WriteOnly)
    imagen.save(buffer, ".png")
    base64_data = buffer.data().toBase64().data().decode()
    return base64_data


class CheckboxWidget(QtWidgets.QWidget):
    """
    A widget containing a single checkbox with the given text.

    Attributes:
        checkbox (QtWidgets.QCheckBox): The checkbox widget.
    """
    def __init__(self, text):
        """
        Initializes the CheckboxWidget with the specified text.

        Args:
            text (str): The text to display next to the checkbox.
        """
        super().__init__()
        layout = QtWidgets.QHBoxLayout(self)
        self.checkbox = QtWidgets.QCheckBox(text)
        layout.addWidget(self.checkbox)

class AlignDelegate(QtWidgets.QStyledItemDelegate):
    """
    A custom item delegate for aligning cell content in a QTableView or QTableWidget to the center.

    Inherits from:
        QtWidgets.QStyledItemDelegate: Provides custom rendering and editing for table items.

    """
    def initStyleOption(self, option, index):
        """
        Initializes the style option for the item, setting its display alignment to center.

        Args:
            option (QtWidgets.QStyleOptionViewItem): The style option to initialize.
            index (QtCore.QModelIndex): The model index of the item.
        """
        super(AlignDelegate, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

class EditableComboBoxDelegate(QtWidgets.QStyledItemDelegate):
    """
    A delegate for editing combobox items in a view.

    Attributes:
        options (list): List of options to populate the combobox.
    """
    def __init__(self, parent=None, options=None):
        """
        Initializes the EditableComboBoxDelegate with the specified options.

        Args:
            parent (QtWidgets.QWidget, optional): Parent widget.
            options (list, optional): List of options for the combobox.
        """
        super().__init__(parent)
        self.options = options
        self._cleared = False

    def createEditor(self, parent, option, index):
        """
        Creates an editor for the combobox.

        Args:
            parent (QtWidgets.QWidget): Parent widget.
            option (QtWidgets.QStyleOptionViewItem): Style options for the item.
            index (QtCore.QModelIndex): Index of the item in the model.

        Returns:
            QtWidgets.QComboBox: The created combobox editor.
        """
        editor = QtWidgets.QComboBox(parent)
        editor.setEditable(True)
        editor.addItems(self.options)
        line_edit = editor.lineEdit()
        line_edit.clear()
        line_edit.textEdited.connect(self.clear_text_on_first_edit)
        return editor

    def setEditorData(self, editor, index):
        """
        Sets the data for the combobox editor.

        Args:
            editor (QtWidgets.QComboBox): The combobox editor.
            index (QtCore.QModelIndex): Index of the item in the model.
        """
        text = index.data(Qt.ItemDataRole.DisplayRole)
        editor.setEditText(text)

    def setModelData(self, editor, model, index):
        """
        Updates the model with the data from the combobox editor.

        Args:
            editor (QtWidgets.QComboBox): The combobox editor.
            model (QtGui.QAbstractItemModel): The model to update.
            index (QtCore.QModelIndex): Index of the item in the model.
        """
        model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)

    def clear_text_on_first_edit(self, text):
        """
        Clears the text on the first edit and disconnects the signal.

        Args:
            line_edit (QtWidgets.QLineEdit): The line edit within the combobox.
        """
        line_edit = self.sender()
        if line_edit is not None:
            line_edit.blockSignals(True)  # Block signals to prevent recursive calls
            line_edit.clear()  # Clear the line edit's text
            line_edit.blockSignals(False)  # Unblock signals after clearing

            # Disconnect to avoid clearing on subsequent edits
            line_edit.textEdited.disconnect(self.clear_text_on_first_edit)

class CustomProxyModel(QtCore.QSortFilterProxyModel):
    """
    A custom proxy model that filters table rows based on expressions set for specific columns.

    Attributes:
        _filters (dict): A dictionary to store filter expressions for columns.
        header_names (dict): A dictionary to store header names for the table.

    Properties:
        filters: Getter for the current filter dictionary.

    """
    def __init__(self, parent=None):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        super().__init__(parent)
        self._filters = dict()
        self.header_names = {}

    @property
    def filters(self):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        return self._filters

    def setFilter(self, expresion, column, action_name=None, exact_match=False):
        """
        Apply a filter expression to a specific column, or remove it if necessary.

        Args:
            expresion (str): The filter expression.
            column (int): The index of the column to apply the filter to.
            action_name (str, optional): Name of the action, can be empty. Defaults to None.
            exact_match (bool, optional): If True, use exact matching for the filter. Defaults to False.
        """
        if expresion or expresion == '':
            if column in self.filters:
                if action_name or action_name == '':
                    self.filters[column].remove(expresion)
                else:
                    self.filters[column].append((expresion, exact_match))
            else:
                self.filters[column] = [(expresion, exact_match)]
        elif column in self.filters:
            if action_name or action_name == '':
                self.filters[column].remove(expresion)
                if not self.filters[column]:
                    del self.filters[column]
            else:
                del self.filters[column]
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        """
        Check if a row passes the filter criteria based on the column filters.

        Args:
            source_row (int): The row number in the source model.
            source_parent (QModelIndex): The parent index of the row.

        Returns:
            bool: True if the row meets the filter criteria, False otherwise.
        """
        for column, expresions in self.filters.items():
            text = self.sourceModel().index(source_row, column, source_parent).data()

            if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
                text = text.toString("yyyy-MM-dd")

            match_found = False 

            for expresion, exact_match in expresions:
                if expresion == '':  # If expression is empty, match empty cells
                    if text == '':
                        break

                if exact_match:
                    if text in expresion:  # Verificar si `text` está en la lista `expresion`
                        match_found = True
                        break
                
                elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', expresion[0]):
                    expresion = QtCore.QDate.fromString(expresion[0], "dd/MM/yyyy")
                    expresion = expresion.toString("yyyy-MM-dd")
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

                else:
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion[0]))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

            if not match_found:
                return False
        return True

    def lessThan(self, left, right):
        leftData = self.sourceModel().data(left)
        rightData = self.sourceModel().data(right)

        column = left.column()

        # Columns to order as integers
        numeric_columns = [6, 7]

        if column in numeric_columns:
            try:
                return int(leftData) < int(rightData)
            except (ValueError, TypeError):
                pass  # If fail, order as string

        # Order by text (default)
        return str(leftData) < str(rightData)

class EditableTableModel(QtSql.QSqlTableModel):
    """
    A custom SQL table model that supports editable columns, headers, and special flagging behavior based on user permissions.

    Signals:
        updateFailed (str): Signal emitted when an update to the model fails.
    """
    updateFailed = QtCore.Signal(str)

    def __init__(self, username, parent=None, column_range=None, table_check=None):
        """
        Initialize the model with user permissions and optional database and column range.

        Args:
            username (str): The username for permission-based actions.
            parent (QObject, optional): Parent object for the model. Defaults to None.
            column_range (list, optional): A list specifying the range of columns. Defaults to None.
            table_check (str, optional): A text scpecifying the table selected. Defaults to None
        """
        super().__init__(parent)
        self.column_range = column_range
        self.table_check = table_check
        self.username = username

    def setAllColumnHeaders(self, headers):
        """
        Set headers for all columns in the model.

        Args:
            headers (list): A list of header names.
        """
        for column, header in enumerate(headers):
            self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIndividualColumnHeader(self, column, header):
        """
        Set the header for a specific column.

        Args:
            column (int): The column index.
            header (str): The header name.
        """
        self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIconColumnHeader(self, column, icon):
        """
        Set an icon in the header for a specific column.

        Args:
            column (int): The column index.
            icon (QIcon): The icon to display in the header.
        """
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        """
        Retrieve the header data for a specific section of the model.

        Args:
            section (int): The section index (column or row).
            orientation (Qt.Orientation): The orientation (horizontal or vertical).
            role (Qt.ItemDataRole, optional): The role for the header data. Defaults to DisplayRole.

        Returns:
            QVariant: The header data for the specified section.
        """
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return super().headerData(section, orientation, role)
        return super().headerData(section, orientation, role)

    def flags(self, index):
        """
        Get the item flags for a given index, controlling editability and selection based on user permissions.

        Args:
            index (QModelIndex): The index of the item.

        Returns:
            Qt.ItemFlags: The flags for the specified item.
        """
        flags = super().flags(index)

        if self.username == 'j.martinez':
            if index.column() in range (0,8) or index.column() in self.column_range:
                flags &= ~Qt.ItemFlag.ItemIsEditable
                return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
            else:
                return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable
            
        elif self.username == 'julian.martinez':
            if index.column() == 0 or index.column() in self.column_range:
                flags &= ~Qt.ItemFlag.ItemIsEditable
                return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
            else:
                return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable
            
        else:
            if index.column() in range (0,8) or index.column() in self.column_range or 'F' in str(index.sibling(index.row(), index.model().columnCount() - 2).data()):
                flags &= ~Qt.ItemFlag.ItemIsEditable
                return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
            else:
                return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable

    def getColumnHeaders(self, visible_columns):
        """
        Retrieve the headers for the specified visible columns.

        Args:
            visible_columns (list): List of column indices that are visible.

        Returns:
            list: A list of column headers for the visible columns.
        """
        column_headers = [self.headerData(col, Qt.Orientation.Horizontal) for col in visible_columns]
        return column_headers

class EditableComboBoxDelegate2(QtWidgets.QStyledItemDelegate):
    """
    A delegate for editing combobox items in a view.

    Attributes:
        options (list): List of options to populate the combobox.
    """
    def __init__(self, parent=None, options=None):
        """
        Initializes the EditableComboBoxDelegate with the specified options.

        Args:
            parent (QtWidgets.QWidget, optional): Parent widget.
            options (list, optional): List of options for the combobox.
        """
        super().__init__(parent)
        self.options = options

    def createEditor(self, parent, option, index):
        """
        Creates an editor for the combobox.

        Args:
            parent (QtWidgets.QWidget): Parent widget.
            option (QtWidgets.QStyleOptionViewItem): Style options for the item.
            index (QtCore.QModelIndex): Index of the item in the model.

        Returns:
            QtWidgets.QComboBox: The created combobox editor.
        """
        editor = QtWidgets.QComboBox(parent)
        editor.setEditable(True)
        return editor

    def setEditorData(self, editor, index):
        """
        Sets the data for the combobox editor.

        Args:
            editor (QtWidgets.QComboBox): The combobox editor.
            index (QtCore.QModelIndex): Index of the item in the model.
        """
        text = index.data(Qt.ItemDataRole.DisplayRole)
        editor.addItems(self.options)
        editor.setEditText(text)

    def setModelData(self, editor, model, index):
        """
        Updates the model with the data from the combobox editor.

        Args:
            editor (QtWidgets.QComboBox): The combobox editor.
            model (QtGui.QAbstractItemModel): The model to update.
            index (QtCore.QModelIndex): Index of the item in the model.
        """
        model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)

class CustomProxyModel2(QtCore.QSortFilterProxyModel):
    """
    A custom proxy model that filters table rows based on expressions set for specific columns.

    Attributes:
        _filters (dict): A dictionary to store filter expressions for columns.
        header_names (dict): A dictionary to store header names for the table.

    Properties:
        filters: Getter for the current filter dictionary.

    """
    def __init__(self, parent=None):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        super().__init__(parent)
        self._filters = dict()
        self.header_names = {}

    @property
    def filters(self):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        return self._filters

    def setFilter(self, expresion, column, action_name=None, exact_match=False):
        """
        Apply a filter expression to a specific column, or remove it if necessary.

        Args:
            expresion (str): The filter expression.
            column (int): The index of the column to apply the filter to.
            action_name (str, optional): Name of the action, can be empty. Defaults to None.
            exact_match (bool, optional): If True, use exact matching for the filter. Defaults to False.
        """
        if expresion or expresion == '':
            if column in self.filters:
                if action_name or action_name == '':
                    self.filters[column].remove(expresion)
                else:
                    self.filters[column].append((expresion, exact_match))
            else:
                self.filters[column] = [(expresion, exact_match)]
        elif column in self.filters:
            if action_name or action_name == '':
                self.filters[column].remove(expresion)
                if not self.filters[column]:
                    del self.filters[column]
            else:
                del self.filters[column]
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        """
        Check if a row passes the filter criteria based on the column filters.

        Args:
            source_row (int): The row number in the source model.
            source_parent (QModelIndex): The parent index of the row.

        Returns:
            bool: True if the row meets the filter criteria, False otherwise.
        """
        for column, expresions in self.filters.items():
            text = self.sourceModel().index(source_row, column, source_parent).data()

            if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
                text = text.toString("yyyy-MM-dd")

            match_found = False 

            for expresion, exact_match in expresions:
                if expresion == '':  # If expression is empty, match empty cells
                    if text == '':
                        break

                if exact_match:
                    if text in expresion:  # Verificar si `text` está en la lista `expresion`
                        match_found = True
                        break
                
                elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', expresion[0]):
                    expresion = QtCore.QDate.fromString(expresion[0], "dd/MM/yyyy")
                    expresion = expresion.toString("yyyy-MM-dd")
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

                else:
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion[0]))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

            if not match_found:
                return False
        return True

class EditableTableModel2(QtSql.QSqlTableModel):
    """
    A custom SQL table model that supports editable columns, headers, and special flagging behavior based on user permissions.

    Signals:
        updateFailed (str): Signal emitted when an update to the model fails.
    """
    updateFailed = QtCore.Signal(str)

    def __init__(self, parent=None, column_range=None, table_check=None):
        """
        Initialize the model with user permissions and optional database and column range.

        Args:
            username (str): The username for permission-based actions.
            parent (QObject, optional): Parent object for the model. Defaults to None.
            column_range (list, optional): A list specifying the range of columns. Defaults to None.
            table_check (str, optional): A text scpecifying the table selected. Defaults to None
        """
        super().__init__(parent)
        self.column_range = column_range
        self.table_check = table_check

    def setAllColumnHeaders(self, headers):
        """
        Set headers for all columns in the model.

        Args:
            headers (list): A list of header names.
        """
        for column, header in enumerate(headers):
            self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIndividualColumnHeader(self, column, header):
        """
        Set the header for a specific column.

        Args:
            column (int): The column index.
            header (str): The header name.
        """
        self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIconColumnHeader(self, column, icon):
        """
        Set an icon in the header for a specific column.

        Args:
            column (int): The column index.
            icon (QIcon): The icon to display in the header.
        """
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        """
        Retrieve the header data for a specific section of the model.

        Args:
            section (int): The section index (column or row).
            orientation (Qt.Orientation): The orientation (horizontal or vertical).
            role (Qt.ItemDataRole, optional): The role for the header data. Defaults to DisplayRole.

        Returns:
            QVariant: The header data for the specified section.
        """
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return super().headerData(section, orientation, role)
        return super().headerData(section, orientation, role)

    def flags(self, index):
        """
        Get the item flags for a given index, controlling editability and selection based on user permissions.

        Args:
            index (QModelIndex): The index of the item.

        Returns:
            Qt.ItemFlags: The flags for the specified item.
        """
        flags = super().flags(index)

        value = index.model().data(index, role=Qt.ItemDataRole.DisplayRole)

        if index.column() == 165 and value == 'Facturado' and self.table_check == 'tags_data.tags_flow':
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        elif index.column() == 178 and value == 'Facturado' and self.table_check == 'tags_data.tags_temp':
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        elif index.column() == 175 and value == 'Facturado' and self.table_check == 'tags_data.tags_level':
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        elif index.column() == 65 and value == 'Facturado' and self.table_check == 'tags_data.tags_others':
            flags &= ~Qt.ItemFlag.ItemIsEditable
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        else:
            if index.column() == 0 or index.column() in self.column_range:
                flags &= ~Qt.ItemFlag.ItemIsEditable
                return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
            else:
                return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable

    def getColumnHeaders(self, visible_columns):
        """
        Retrieve the headers for the specified visible columns.

        Args:
            visible_columns (list): List of column indices that are visible.

        Returns:
            list: A list of column headers for the visible columns.
        """
        column_headers = [self.headerData(col, Qt.Orientation.Horizontal) for col in visible_columns]
        return column_headers

class Ui_EditTags_Technical_Window(QtWidgets.QMainWindow):
    """
    A window for editing tags in the application for technical.

    Attributes:
        model (EditableTableModel): The data model for the table.
        proxy (CustomProxyModel): The proxy model for filtering and sorting.
        db (object): Database connection.
        checkbox_states (dict): States of checkboxes.
        dict_valuesuniques (dict): Unique values for columns.
        dict_ordersort (dict): Sorting order for columns.
        hiddencolumns (list): List of hidden column indices.
        action_checkbox_map (dict): Map of actions to checkboxes.
        checkbox_filters (dict): Filters based on checkbox states.
        name (str): Name associated with the window.
        variable (str): Variable used in the window.
    """
    def __init__(self, username, db, num_order=None):
        """
        Initializes the Ui_EditTags_Technical_Window with the specified name and database connection.

        Args:
            name (str): Name associated with the window.
            db (object): Database connection.
        """
        super().__init__()
        self.username = username
        self.variable = ''

        self.model = EditableTableModel(self.username)
        self.proxy = CustomProxyModel()
        self.model2 = EditableTableModel2()
        self.proxy2 = CustomProxyModel2()
        self.db = db
        self.num_order_query = num_order

        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []
        self.variable = ''
        self.action_checkbox_map = {}
        self.checkbox_filters = {}

        self.checkbox_states2 = {}
        self.dict_valuesuniques2 = {}
        self.dict_ordersort2 = {}
        self.hiddencolumns2 = []
        self.variable2 = None
        self.action_checkbox_map2 = {}
        self.checkbox_filters2 = {}
        self.tableEditTags2 = None

        self.model.dataChanged.connect(self.saveChanges)
        
        self.setupUi(self)

    def closeEvent(self, event):
        """
        Handles the close event to clean up resources.

        Args:
            event (QtGui.QCloseEvent): The close event.
        """
        if self.model:
            self.model.clear()
        if self.model2:
            self.model2.clear()
        self.closeConnection()

    def closeConnection(self):
        """
        Closes the database connection and cleans up resources.
        """
        self.tableEditTags.setModel(None)
        del self.model
        if self.tableEditTags2:
            self.tableEditTags2.setModel(None)
        del self.model2
        if self.db:
            self.db.close()
            del self.db
            if QtSql.QSqlDatabase.contains("qt_sql_default_connection"):
                QtSql.QSqlDatabase.removeDatabase("qt_sql_default_connection")

    def setupUi(self, EditTagsTechnical_Window):
        """
        Sets up the user interface for the EditTagsTechnical_Window.

        Args:
            EditTagsTechnical_Window (QtWidgets.QMainWindow): The main window for the UI setup.
        """
        EditTagsTechnical_Window.setObjectName("EditTagsTechnical_Window")
        EditTagsTechnical_Window.resize(790, 595)
        EditTagsTechnical_Window.setMinimumSize(QtCore.QSize(790, 595))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        EditTagsTechnical_Window.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(parent=EditTagsTechnical_Window)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_2.setVerticalSpacing(10)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.hcab=QtWidgets.QHBoxLayout()
        self.hcab.setObjectName("hcab")
        self.toolDeleteFilter = QtWidgets.QToolButton(self.frame)
        self.toolDeleteFilter.setObjectName("Save_Button")
        self.hcab.addWidget(self.toolDeleteFilter)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Filter_Delete.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolDeleteFilter.setIcon(icon)
        self.toolDeleteFilter.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer1=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer1)
        self.toolShow = QtWidgets.QToolButton(self.frame)
        self.toolShow.setObjectName("Show_Button")
        self.toolShow.setToolTip("Mostrar columnas")
        self.hcab.addWidget(self.toolShow)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Eye.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolShow.setIcon(icon)
        self.toolShow.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer2=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer2)
        self.toolMatOrder = QtWidgets.QToolButton(self.frame)
        self.toolMatOrder.setObjectName("MatOrder_Button")
        self.toolMatOrder.setToolTip("Pedido Materiales")
        self.hcab.addWidget(self.toolMatOrder)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Purchase_Order.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolMatOrder.setIcon(icon)
        self.toolMatOrder.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer3=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer3)
        self.toolFabOrder = QtWidgets.QToolButton(self.frame)
        self.toolFabOrder.setObjectName("FabOrder_Button")
        self.toolFabOrder.setToolTip("Orden Fabricación")
        self.hcab.addWidget(self.toolFabOrder)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Fab_Order.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolFabOrder.setIcon(icon)
        self.toolFabOrder.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer4=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer4)
        self.toolInspection = QtWidgets.QToolButton(self.frame)
        self.toolInspection.setObjectName("Inspection_Button")
        self.toolInspection.setToolTip("Inspeccion")
        self.hcab.addWidget(self.toolInspection)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Inspection.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolInspection.setIcon(icon)
        self.toolInspection.setIconSize(QtCore.QSize(25, 25))
        self.hcabspacer5=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer5)
        self.toolExpExcel = QtWidgets.QToolButton(self.frame)
        self.toolExpExcel.setObjectName("ExpExcel_Button")
        self.toolExpExcel.setToolTip("Exportar a Excel")
        self.hcab.addWidget(self.toolExpExcel)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Download.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolExpExcel.setIcon(icon)
        self.toolExpExcel.setIconSize(QtCore.QSize(25, 25))

        self.hcabspacer7=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer7)
        self.toolImpExcel = QtWidgets.QToolButton(self.frame)
        self.toolImpExcel.setObjectName("ImpExcel_Button")
        self.toolImpExcel.setToolTip("Importar Excel")
        self.hcab.addWidget(self.toolImpExcel)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "Upload.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolImpExcel.setIcon(icon)
        self.toolImpExcel.setIconSize(QtCore.QSize(25, 25))

        self.hcabspacer6=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer6)
        self.generate_dwg = QtWidgets.QToolButton(self.frame)
        self.generate_dwg.setObjectName("generate_dwg_Button")
        self.generate_dwg.setToolTip("Generar planos")
        self.hcab.addWidget(self.generate_dwg)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "M_Drawing.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.generate_dwg.setIcon(icon)
        self.generate_dwg.setIconSize(QtCore.QSize(25, 25))
        

        self.hcabspacer=QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer)
        self.gridLayout_2.addLayout(self.hcab, 0, 0, 1, 1)
        self.hLayout1 = QtWidgets.QHBoxLayout()
        self.hLayout1.setObjectName("hLayout1")
        self.label_NumOrder = QtWidgets.QLabel(parent=self.frame)
        self.label_NumOrder.setMinimumSize(QtCore.QSize(80, 25))
        self.label_NumOrder.setMaximumSize(QtCore.QSize(80, 25))
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        self.label_NumOrder.setFont(font)
        self.label_NumOrder.setObjectName("label_NumOrder")
        self.hLayout1.addWidget(self.label_NumOrder)
        self.Numorder_EditTags = QtWidgets.QLineEdit(parent=self.frame)
        self.Numorder_EditTags.setMinimumSize(QtCore.QSize(250, 25))
        self.Numorder_EditTags.setMaximumSize(QtCore.QSize(250, 25))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.Numorder_EditTags.setFont(font)
        self.Numorder_EditTags.setObjectName("Numorder_EditTags")
        self.hLayout1.addWidget(self.Numorder_EditTags)
        self.gridLayout_2.addLayout(self.hLayout1, 1, 0, 1, 1)
        self.Button_Query = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Query.setMinimumSize(QtCore.QSize(150, 35))
        self.Button_Query.setMaximumSize(QtCore.QSize(150, 35))
        self.Button_Query.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.Button_Query.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 8px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:focus {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255)\n"
"}\n"
"\n"
"QPushButton:focus:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        self.Button_Query.setObjectName("Button_Query")
        self.hLayout1.addWidget(self.Button_Query)
        self.tableEditTags=QtWidgets.QTableView(parent=self.frame)
        self.model = EditableTableModel(self.username)
        self.tableEditTags.setObjectName("tableEditTags")
        self.gridLayout_2.addWidget(self.tableEditTags, 3, 0, 1, 1)
        self.hLayout3 = QtWidgets.QHBoxLayout()
        self.hLayout3.setObjectName("hLayout3")
        spacerItem2 = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hLayout3.addItem(spacerItem2)
        self.label_SumItems = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setText("")
        self.label_SumItems.setObjectName("label_SumItems")
        self.hLayout3.addWidget(self.label_SumItems)
        self.label_SumValue = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setText("")
        self.label_SumValue.setObjectName("label_SumValue")
        self.hLayout3.addWidget(self.label_SumValue)
        self.label_CountItems = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setText("")
        self.label_CountItems.setObjectName("label_CountItems")
        self.hLayout3.addWidget(self.label_CountItems)
        self.label_CountValue = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setText("")
        self.label_CountValue.setObjectName("label_CountValue")
        self.hLayout3.addWidget(self.label_CountValue)
        self.gridLayout_2.addLayout(self.hLayout3, 4, 0, 1, 1)
        self.tableEditTags2=QtWidgets.QTableView(parent=self.frame)
        self.tableEditTags2.setObjectName("tableEditTags2")
        self.gridLayout_2.addWidget(self.tableEditTags2, 5, 0, 1, 1)
        self.tableEditTags2.hide()
        self.hLayout4 = QtWidgets.QHBoxLayout()
        self.hLayout4.setObjectName("hLayout4")
        spacerItem1 = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hLayout4.addItem(spacerItem1)
        self.label_SumItems2 = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems2.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems2.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems2.setText("")
        self.label_SumItems2.setObjectName("label_SumItems2")
        self.hLayout4.addWidget(self.label_SumItems2)
        self.label_SumValue2 = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue2.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue2.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue2.setText("")
        self.label_SumValue2.setObjectName("label_SumValue2")
        self.hLayout4.addWidget(self.label_SumValue2)
        self.label_CountItems2 = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems2.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems2.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems2.setText("")
        self.label_CountItems2.setObjectName("label_CountItems2")
        self.hLayout4.addWidget(self.label_CountItems2)
        self.label_CountValue2 = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue2.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue2.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue2.setText("")
        self.label_CountValue2.setObjectName("label_CountValue2")
        self.hLayout4.addWidget(self.label_CountValue2)
        self.gridLayout_2.addLayout(self.hLayout4, 6, 0, 1, 1)

        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 0, 0, 1, 1)
        self.gridLayout.addWidget(self.frame, 0, 0, 1, 1)
        EditTagsTechnical_Window.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=EditTagsTechnical_Window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 790, 22))
        self.menubar.setObjectName("menubar")
        EditTagsTechnical_Window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=EditTagsTechnical_Window)
        self.statusbar.setObjectName("statusbar")
        EditTagsTechnical_Window.setStatusBar(self.statusbar)

        self.retranslateUi(EditTagsTechnical_Window)
        QtCore.QMetaObject.connectSlotsByName(EditTagsTechnical_Window)
        self.Button_Query.clicked.connect(self.query_tags)
        self.toolDeleteFilter.clicked.connect(self.delete_allFilters)
        self.toolShow.clicked.connect(self.show_columns)
        self.toolMatOrder.clicked.connect(self.materialorder)
        self.toolFabOrder.clicked.connect(self.faborder)
        self.toolInspection.clicked.connect(self.setinspection)
        self.toolExpExcel.clicked.connect(self.exporttoexcel)
        self.toolImpExcel.clicked.connect(self.importexcel)
        self.generate_dwg.clicked.connect(self.generate_drawings)
        self.Numorder_EditTags.returnPressed.connect(self.query_tags)
        self.model.dataChanged.connect(self.saveChanges)
        self.createContextMenu()

        commands_comboboxes_flow = [
            "SELECT item_type FROM validation_data.flow_item_type",
            "SELECT line_size FROM validation_data.flow_line_size",
            "SELECT rating FROM validation_data.flow_rating",
            "SELECT facing FROM validation_data.flow_facing",
            "SELECT schedule FROM validation_data.flow_schedule",
            "SELECT flange_material FROM validation_data.flow_flange_material",
            "SELECT flange_type FROM validation_data.flow_flange_type",
            "SELECT tube_material FROM validation_data.flow_tube_material",
            "SELECT tapping_size FROM validation_data.flow_tapping_size",
            "SELECT element_material FROM validation_data.flow_element_material",
            "SELECT plate_type FROM validation_data.flow_plate_type",
            "SELECT plate_thk FROM validation_data.flow_plate_thk",
            "SELECT plate_std FROM validation_data.flow_plate_std",
            "SELECT gasket_material FROM validation_data.flow_gasket_material",
            "SELECT bolts_material FROM validation_data.flow_bolts_material",
            "SELECT nuts_material FROM validation_data.flow_nuts_material",
            "SELECT nace FROM validation_data.flow_nace",
            "SELECT extractor_material FROM validation_data.flow_extractor_material",
            ]

        commands_comboboxes_temp = [
            "SELECT item_type FROM validation_data.temp_item_type",
            "SELECT tw_type FROM validation_data.temp_tw_type",
            "SELECT flange_size FROM validation_data.temp_flange_size",
            "SELECT flange_rating FROM validation_data.temp_flange_rating",
            "SELECT flange_facing FROM validation_data.temp_flange_facing",
            "SELECT tw_material FROM validation_data.temp_tw_material",
            "SELECT root_diam FROM validation_data.temp_root_diam",
            "SELECT tip_diam FROM validation_data.temp_tip_diam",
            "SELECT sensor_element FROM validation_data.temp_sensor_element",
            "SELECT sheath_stem_material FROM validation_data.temp_sheath_stem_material",
            "SELECT sheath_stem_diam FROM validation_data.temp_sheath_stem_diam",
            "SELECT insulation FROM validation_data.temp_insulation",
            "SELECT temp_inf FROM validation_data.temp_temp_inf",
            "SELECT temp_sup FROM validation_data.temp_temp_sup",
            "SELECT nipple_ext_material FROM validation_data.temp_nipple_ext_material",
            "SELECT nipple_ext_length FROM validation_data.temp_nipple_ext_length",
            "SELECT head_case_material FROM validation_data.temp_head_case_material",
            "SELECT head_conn_case_diam FROM validation_data.temp_head_conn_case_diam",
            "SELECT tttb FROM validation_data.temp_tttb",
            "SELECT flange_material_lapjoint FROM validation_data.temp_flange_material_lapjoint",
            "SELECT gasket_material FROM validation_data.temp_gasket_material",
            "SELECT puntal FROM validation_data.temp_puntal",
            "SELECT tube_t FROM validation_data.temp_tube_t",
            "SELECT nace FROM validation_data.temp_nace",
            "SELECT plug FROM validation_data.temp_plug"
            ]

        commands_comboboxes_level = [
            "SELECT item_type FROM validation_data.level_item_type",
            "SELECT model_num FROM validation_data.level_model_num",
            "SELECT body_mat FROM validation_data.level_body_mat",
            "SELECT proc_conn_type FROM validation_data.level_proc_conn_type",
            "SELECT proc_conn_size FROM validation_data.level_proc_conn_size",
            "SELECT proc_conn_rating FROM validation_data.level_proc_conn_rating",
            "SELECT proc_conn_facing FROM validation_data.level_proc_conn_facing",
            "SELECT conn_type FROM validation_data.level_conn_type",
            "SELECT valve_type FROM validation_data.level_valve_type",
            "SELECT dv_conn FROM validation_data.level_dv_conn",
            "SELECT dv_size FROM validation_data.level_dv_size",
            "SELECT dv_rating FROM validation_data.level_dv_rating",
            "SELECT dv_facing FROM validation_data.level_dv_facing",
            "SELECT gasket FROM validation_data.level_gasket",
            "SELECT stud_nuts FROM validation_data.level_stud_nuts",
            "SELECT illuminator FROM validation_data.level_illuminator",
            "SELECT float_mat FROM validation_data.level_float_mat",
            "SELECT case_cover_mat FROM validation_data.level_case_cover_mat",
            "SELECT scale_type FROM validation_data.level_scale",
            "SELECT flags_color_mat FROM validation_data.level_flags_color_mat",
            "SELECT ip_code FROM validation_data.level_ip_code",
            "SELECT flange_type FROM validation_data.level_flange_type",
            "SELECT nipple FROM validation_data.level_nipple_hex",
            "SELECT nipple FROM validation_data.level_nipple",
            "SELECT antifrost FROM validation_data.level_antifrost",
            "SELECT nace FROM validation_data.level_nace",
            ]

        commands_comboboxes_others = ["SELECT nace FROM validation_data.others_nace",]

        self.all_results_flow = []
        self.all_results_temp = []
        self.all_results_level = []
        self.all_results_others = []

        try:
            with Database_Connection(config_database()) as conn:
                with conn.cursor() as cur:
                    for query in commands_comboboxes_flow:
                        cur.execute(query)
                        results_flow=cur.fetchall()
                        self.all_results_flow.append(results_flow)
                    for query in commands_comboboxes_temp:
                        cur.execute(query)
                        results_temp=cur.fetchall()
                        self.all_results_temp.append(results_temp)
                    for query in commands_comboboxes_level:
                        cur.execute(query)
                        results_level=cur.fetchall()
                        self.all_results_level.append(results_level)
                    for query in commands_comboboxes_others:
                        cur.execute(query)
                        results_others=cur.fetchall()
                        self.all_results_others.append(results_others)

        except (Exception, psycopg2.DatabaseError) as error:
            MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "critical")

        if self.num_order_query is not None:
            self.Numorder_EditTags.setText(str(self.num_order_query))
            self.query_tags()

# Function to translate and updates the text of various UI elements
    def retranslateUi(self, EditTagsTechnical_Window):
        """
        Translates and updates the text of various UI elements.
        """
        _translate = QtCore.QCoreApplication.translate
        EditTagsTechnical_Window.setWindowTitle(_translate("EditTagsTechnical_Window", "Editar Tags"))
        self.tableEditTags.setSortingEnabled(True)
        self.Button_Query.setText(_translate("EditTagsTechnical_Window", "Buscar"))
        self.label_NumOrder.setText(_translate("EditTagsTechnical_Window", "Nº Pedido:"))

# Function to delete all filters when tool button is clicked
    def delete_allFilters(self):
        """
        Resets all filters and updates the table model with unique values for each column.
        """
        if self.proxy.rowCount() != 0:
            columns_number=self.model.columnCount()
            for index in range(columns_number):
                if index in self.proxy.filters:
                    del self.proxy.filters[index]
                self.model.setIconColumnHeader(index, '')

            self.checkbox_states = {}
            self.dict_valuesuniques = {}
            self.dict_ordersort = {}
            self.checkbox_filters = {}

            self.proxy.invalidateFilter()
            # self.tableEditTags.setModel(None)
            self.tableEditTags.setModel(self.proxy)

            # Getting the unique values for each column of the model
            for column in range(self.model.columnCount()):
                list_valuesUnique = []
                if column not in self.checkbox_states:
                    self.checkbox_states[column] = {}
                    self.checkbox_states[column]['Seleccionar todo'] = True
                    for row in range(self.model.rowCount()):
                        value = self.model.record(row).value(column)
                        if value not in list_valuesUnique:
                            if isinstance(value, QtCore.QDate):
                                value=value.toString("dd/MM/yyyy")
                            list_valuesUnique.append(str(value))
                            self.checkbox_states[column][value] = True
                    self.dict_valuesuniques[column] = list_valuesUnique

            self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditTags.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditTags.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

        if self.proxy2.rowCount() != 0:
            columns_number=self.model2.columnCount()
            for index in range(columns_number):
                if index in self.proxy2.filters:
                    del self.proxy2.filters[index]
                self.model2.setIconColumnHeader(index, '')

            self.checkbox_states = {}
            self.dict_valuesuniques = {}
            self.dict_ordersort = {}
            self.checkbox_filters = {}

            self.proxy2.invalidateFilter()
            # self.tableEditTags.setModel(None)
            self.tableEditTags2.setModel(self.proxy2)

            # Getting the unique values for each column of the model
            for column in range(self.model2.columnCount()):
                list_valuesUnique = []
                if column not in self.checkbox_states:
                    self.checkbox_states[column] = {}
                    self.checkbox_states[column]['Seleccionar todo'] = True
                    for row in range(self.model2.rowCount()):
                        value = self.model2.record(row).value(column)
                        if value not in list_valuesUnique:
                            if isinstance(value, QtCore.QDate):
                                value=value.toString("dd/MM/yyyy")
                            list_valuesUnique.append(str(value))
                            self.checkbox_states[column][value] = True
                    self.dict_valuesuniques[column] = list_valuesUnique

            self.tableEditTags2.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditTags2.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditTags2.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function to save changes into database
    def saveChanges(self):
        """
        Saves changes made to the data models and updates unique values for each column.
        """
        self.model.submitAll()

        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            for row in range(self.model.rowCount()):
                value = self.model.record(row).value(column)
                if value not in list_valuesUnique:
                    if isinstance(value, QtCore.QDate):
                        value=value.toString("dd/MM/yyyy")
                    list_valuesUnique.append(str(value))
                    if value not in self.checkbox_states[column]:
                        self.checkbox_states[column][value] = True
            self.dict_valuesuniques[column] = list_valuesUnique

        self.model2.submitAll()

        for column in range(self.model2.columnCount()):
            list_valuesUnique2 = []
            for row in range(self.model2.rowCount()):
                value = self.model2.record(row).value(column)
                if value not in list_valuesUnique2:
                    if isinstance(value, QtCore.QDate):
                        value=value.toString("dd/MM/yyyy")
                    list_valuesUnique2.append(str(value))
                    if value not in self.checkbox_states2[column]:
                        self.checkbox_states2[column][value] = True
            self.dict_valuesuniques2[column] = list_valuesUnique2

# Function to load table and setting in the window
    def query_tags(self):
        """
        Queries the database for tags based on the number order, configures and populates tables with the query results, 
        and updates the UI accordingly. Handles potential database errors and updates the UI with appropriate messages.
        """
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []
        self.original_headers = []

        self.variable2 = None

        self.model.dataChanged.disconnect(self.saveChanges)
        self.numorder = self.Numorder_EditTags.text()

        if self.numorder=="":
            MessageHelper.show_message("Rellena alguno de los campos", "warning")
            self.model.dataChanged.connect(self.saveChanges)

        else:
            if not re.match(r'^(P|PA|p|pa)-\d{2}/\d{3}.*$', self.numorder):
                MessageHelper.show_message("El número de pedido debe tener formato P-XX/YYY o PA-XX/YYY", "warning")
                self.model.dataChanged.connect(self.saveChanges)

            else:
                query = ('''
                        SELECT num_order, product_type."variable"
                        FROM orders
                        INNER JOIN offers ON (offers."num_offer" = orders."num_offer")
                        INNER JOIN product_type ON (product_type."material" = offers."material")
                        WHERE
                        UPPER (orders."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')

                try:
                    with Database_Connection(config_database()) as conn:
                        with conn.cursor() as cur:
                            cur.execute(query,(self.numorder,))
                            results_variable=cur.fetchone()
                            self.variable = results_variable[1] if results_variable != None else ''

                except (Exception, psycopg2.DatabaseError) as error:
                    MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                                + str(error), "critical")

                if results_variable == None:
                    MessageHelper.show_message("El número de pedido no existe", "warning")
                    self.model.dataChanged.connect(self.saveChanges)

                else:
                    query_flow = ('''
                        SELECT tags_data.tags_flow."num_order"
                        FROM tags_data.tags_flow
                        WHERE UPPER (tags_data.tags_flow."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')
                    query_temp = ('''
                        SELECT tags_data.tags_temp."num_order"
                        FROM tags_data.tags_temp
                        WHERE UPPER (tags_data.tags_temp."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')
                    query_level = ('''
                        SELECT tags_data.tags_level."num_order"
                        FROM tags_data.tags_level
                        WHERE UPPER (tags_data.tags_level."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')
                    query_others = ('''
                        SELECT tags_data.tags_others."num_order"
                        FROM tags_data.tags_others
                        WHERE UPPER (tags_data.tags_others."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')

                    try:
                        with Database_Connection(config_database()) as conn:
                            with conn.cursor() as cur:
                                cur.execute(query_flow,(self.numorder,))
                                results_flow=cur.fetchall()
                                cur.execute(query_temp,(self.numorder,))
                                results_temp=cur.fetchall()
                                cur.execute(query_level,(self.numorder,))
                                results_level=cur.fetchall()
                                cur.execute(query_others,(self.numorder,))
                                results_others=cur.fetchall()

                        if len(results_flow) != 0 and len(results_temp) != 0:
                            self.variable = 'Caudal+Temp'
                        elif len(results_flow) != 0 and len(results_level) != 0:
                            self.variable = 'Caudal+Nivel'
                        elif len(results_temp) != 0 and len(results_level) != 0:
                            self.variable = 'Temp+Nivel'
                        elif len(results_flow) != 0:
                            self.variable = 'Caudal'
                        elif len(results_temp) != 0:
                            self.variable = 'Temperatura'
                        elif len(results_level) != 0:
                            self.variable = 'Nivel'
                        elif len(results_others) != 0:
                            self.variable = 'Otros'
                        else:
                            self.variable = ''

                    except (Exception, psycopg2.DatabaseError) as error:
                        MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                                    + str(error), "critical")

                    if self.variable == 'Caudal+Temp':
                        self.variable = 'Caudal'
                        self.variable2 = 'Temperatura'
                        self.model.setTable("tags_data.tags_flow")
                        self.model2.setTable("tags_data.tags_temp")
                        self.model.table_check = "tags_data.tags_flow"
                        self.model2.table_check = "tags_data.tags_temp"
                        self.initial_column = 33
                        self.initial_column2 = 102
                        self.initial_column3 = 138
                        self.initial_column_ = 35
                        self.initial_column2_ = 80
                    elif self.variable =='Caudal+Nivel':
                        self.variable = 'Caudal'
                        self.variable2 = 'Nivel'
                        self.model.setTable("tags_data.tags_flow")
                        self.model2.setTable("tags_data.tags_level")
                        self.model.table_check = "tags_data.tags_flow"
                        self.model2.table_check = "tags_data.tags_level"
                        self.initial_column = 33
                        self.initial_column2 = 102
                        self.initial_column3 = 138
                        self.initial_column_ = 36
                        self.initial_column2_ = 66
                    elif self.variable =='Temp+Nivel':
                        self.variable = 'Temperatura'
                        self.variable2 = 'Nivel'
                        self.model.setTable("tags_data.tags_temp")
                        self.model2.setTable("tags_data.tags_level")
                        self.model.table_check = "tags_data.tags_temp"
                        self.model2.table_check = "tags_data.tags_level"
                        self.initial_column = 35
                        self.initial_column2 = 80
                        self.initial_column_ = 36
                        self.initial_column2_ = 66
                    elif self.variable == 'Caudal':
                        self.model.setTable("tags_data.tags_flow")
                        self.model.table_check = "tags_data.tags_flow"
                        self.initial_column = 33
                        self.initial_column2 = 102
                        self.initial_column3 = 138
                    elif self.variable == 'Temperatura':
                        self.model.setTable("tags_data.tags_temp")
                        self.model.table_check = "tags_data.tags_temp"
                        self.initial_column = 35
                        self.initial_column2 = 80
                    elif self.variable == 'Nivel':
                        self.model.setTable("tags_data.tags_level")
                        self.model.table_check = "tags_data.tags_level"
                        self.initial_column = 36
                        self.initial_column2 = 66
                    elif self.variable == 'Otros':
                        self.model.setTable("tags_data.tags_others")
                        self.model.table_check = "tags_data.tags_others"
                        self.initial_column = 11
                        self.initial_column2 = 25

                    if self.username != 'j.martinez':
                        self.model.setFilter(f"num_order <>'' AND UPPER(num_order) LIKE '%{self.numorder.upper()}%' AND tag_state <> 'FOR INVOICING'")
                        self.model2.setFilter(f"num_order <>'' AND UPPER(num_order) LIKE '%{self.numorder.upper()}%' AND tag_state <> 'FOR INVOICING'")
                    else:
                        self.model.setFilter(f"num_order <>'' AND UPPER(num_order) LIKE '%{self.numorder.upper()}%'")
                        self.model2.setFilter(f"num_order <>'' AND UPPER(num_order) LIKE '%{self.numorder.upper()}%'")

        if self.variable != '':
            self.tableEditTags.setModel(None)
            self.tableEditTags.setModel(self.proxy)
            self.model.select()

            self.proxy.setSourceModel(self.model)
            self.tableEditTags.setModel(self.proxy)

            columns_number=self.model.columnCount()
            for column in range(columns_number):
                self.tableEditTags.setItemDelegateForColumn(column, None)

            if self.variable == 'Caudal':
                self.model.column_range = list(range(self.initial_column, self.initial_column + 4)) + \
                                            list(range(self.initial_column2, self.initial_column2 + 33)) + \
                                            list(range(self.initial_column3, columns_number))
            else:
                self.model.column_range = list(range(self.initial_column,self.initial_column + 4)) + list(range(self.initial_column2,columns_number))

            if self.variable == 'Caudal':
                for i in range(140,columns_number):
                    self.tableEditTags.hideColumn(i)

            elif self.variable == 'Temperatura':
                for i in range(80,132):
                    self.tableEditTags.hideColumn(i)
                for i in range(134,138):
                    self.tableEditTags.hideColumn(i)
                for i in range(139,143):
                    self.tableEditTags.hideColumn(i)
                for i in range(144,149):
                    self.tableEditTags.hideColumn(i)
                for i in range(150,157):
                    self.tableEditTags.hideColumn(i)
                for i in range(158,160):
                    self.tableEditTags.hideColumn(i)
                for i in range(161,163):
                    self.tableEditTags.hideColumn(i)
                for i in range(164,166):
                    self.tableEditTags.hideColumn(i)
                for i in range(167,columns_number-1):
                    self.tableEditTags.hideColumn(i)
                if self.username not in ['j.martinez','julian.martinez']:
                    self.tableEditTags.showColumn(35)

            elif self.variable == 'Nivel':
                for i in range(66,138):
                    self.tableEditTags.hideColumn(i)
                for i in range(140,144):
                    self.tableEditTags.hideColumn(i)
                for i in range(145,149):
                    self.tableEditTags.hideColumn(i)
                for i in range(150,155):
                    self.tableEditTags.hideColumn(i)
                for i in range(156,163):
                    self.tableEditTags.hideColumn(i)
                for i in range(164,166):
                    self.tableEditTags.hideColumn(i)
                for i in range(167,169):
                    self.tableEditTags.hideColumn(i)
                for i in range(170,columns_number):
                    self.tableEditTags.hideColumn(i)
                if self.username not in ['j.martinez','julian.martinez']:
                    self.tableEditTags.showColumn(36)

            elif self.variable == 'Otros':
                for i in range(27,31):
                    self.tableEditTags.hideColumn(i)
                for i in range(32,36):
                    self.tableEditTags.hideColumn(i)
                for i in range(37,42):
                    self.tableEditTags.hideColumn(i)
                for i in range(43,50):
                    self.tableEditTags.hideColumn(i)
                for i in range(51,53):
                    self.tableEditTags.hideColumn(i)
                for i in range(54,56):
                    self.tableEditTags.hideColumn(i)
                for i in range(57,columns_number):
                    self.tableEditTags.hideColumn(i)
                if self.username not in ['j.martinez','julian.martinez']:
                    self.tableEditTags.showColumn(11)

            if self.username not in ['j.martinez','julian.martinez']:
                if self.variable == 'Caudal':
                    self.tableEditTags.hideColumn(33)
                elif self.variable == 'Temperatura':
                    self.tableEditTags.hideColumn(35)
                elif self.variable == 'Nivel':
                    self.tableEditTags.hideColumn(36)
                elif self.variable == 'Otros':
                    self.tableEditTags.hideColumn(11)

            # self.tableEditTags.verticalHeader().hide()
            self.tableEditTags.setItemDelegate(AlignDelegate(self.tableEditTags))
            self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableEditTags.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditTags.horizontalHeader().setSectionResizeMode(columns_number-2,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
            self.tableEditTags.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")
            self.tableEditTags.setStyleSheet("gridline-color: #CCCCCC")
            self.tableEditTags.setObjectName("tableEditTags")
            self.gridLayout_2.addWidget(self.tableEditTags, 3, 0, 1, 1)
            self.tableEditTags.setSortingEnabled(False)
            self.tableEditTags.horizontalHeader().sectionDoubleClicked.connect(lambda logicalIndex: self.on_view_horizontalHeader_sectionClicked(logicalIndex, self.tableEditTags, self.model, self.proxy))
            self.tableEditTags.horizontalHeader().customContextMenuRequested.connect(self.showColumnContextMenu)
            self.tableEditTags.horizontalHeader().setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)

        # Change all column names
            headers_flow = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido", "PO", "Posición", "Subposición",
                            "Tipo", "Tamaño Línea", "Rating", "Facing", "Schedule", "Mat. Brida", "Tipo Brida",
                            "Mat. Tubo", "Tamaño Tomas", "Nº Tomas", "Orient. Tomas", "Mat. Elemento", "Tipo Placa",
                            "Esp. Placa", "Std Paca", "Mat. Junta", "Mat. Torn.", "Mat. Tuercas", "Con. Vlv.", "Mat. Cuerpo Vlv.",
                            "Nº Saltos", "Pipe Spec.", "Peso (mm)", "Long. (mm)", "NACE", "Precio (€)", "Notas Oferta", "Cambios Com.",
                            "Fecha Contr.", "øOrif. (mm)", "øD/V (mm)", "Cant. Juntas", "Tamaño Torn.", "Cant. Torn", "Mat. Tapón",
                            "Cant. Tapón", "Mat. Extractor", "Tamaño Extractor", "Cant. Extractor", "Mat. Porta RTJ", "Espesor RTJ", "Tipo RTJ",
                            "Notas Brida", "Notas Tornillos", "Notas Tuercas", "Notas Placa", "Notas Junta", "Notas Tapones", "Notas Extractor",
                            "øInt. Línea", "øExt. Placa", "Cota C Placa", "Alto Mango", "Ancho Mango", "Espesor Mango",
                            "Cota P RTJ", "Cota E RTJ", "Cota F RTJ",
                            "O Brida", "A Brida", "C Brida", "Y Brida", "X Brida", "R Brida", "D Brida", "T Brida", "øBore Torn.",
                            "Mat. Conos Vent.", "A Venturi", "D Venturi", "E Venturi", "F Venturi", "G Venturi", "C Venturi", "H Venturi", "T Venturi",
                            "Cambios Tec.", "Notas Tec.", "Notas Equipo", "Doc EIPSA Calc.", "Doc EIPSA Plano",
                            "Orden de Compra", "Fecha Orden Compra", "Notas Orden Compra",
                            "Plano Dim.", "Rev. Plano Dim.", "Fecha Plano Dim.", "Plano OF", "Rev. Plano OF", "Fecha Plano OF",
                            "Colada Placa", "Cert. Placa", "Colada Brida", "Cert. Brida",
                            "Fecha PMI", "Fecha PH1", "Manómetro PH1", "Presión PH1", "Estado PH1", "Notas PH1",
                            "Fecha PH2", "Manómetro PH2", "Presión PH2", "Estado PH2", "Notas PH2",
                            "Fecha LP", "Colada LP 9PR5", "Colada LP 9D1B", "Colada LP 996PB", "Estado LP", "Notas LP",
                            "Fecha Dureza", "Dureza", "Dureza HB", "Bola", "Carga", "Colada Dureza", "Estado Dureza", "Notas Dureza",
                            "Fecha Verif. Dim.", "Estado Verif. Dim.", "Notas Verif. Dim", "Fecha Verif. OF", "Estado Verif. OF", "Notas Verif. OF",
                            "Fotos", "Fotos 2", "Estado Fab.", "Inspeccion", "Fecha IRC", "Envío RN", "Fecha RN",
                            "Posición", "Subposición", "Importe", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas", "Estado Fact.", "% Fact.",
                            "Ruta Dim.", "Ruta OF", "Pedido Tipo Tag", "Cod. Equipo", "Cod. Fab. Equipo", "Trad. Equipo",
                            "Cod. Brida Orif.", "Cod. Brida Línea", "Cod. Junta", "Cod. Tornillería", "Cod. Tapones", "Cod. Extractor",
                            "Cod. Placa", "Cod. Niplo", "Cod. Mango", "Cod. ChRing", "Cod. Tubo", "Cod. Wedge",
                            "Cod Fab. Brida Orif.", "Cod Fab. Brida Línea", "Cod Fab. Junta", "Cod Fab. Tornillería", "Cod Fab. Tapones", "Cod Fab. Extractor",
                            "Cod Fab. Placa", "Cod Fab. Niplo", "Cod Fab. Mango", "Cod Fab. ChRing", "Cod Fab. Tubo", "Cod Fab. Wedge",
                            "Cant. Brida Orif.", "Cant. Brida Línea", "Cant. Junta", "Cant. Tornillería", "Cant. Tapones", "Cant. Extractor",
                            "Cant. Placa", "Cant. Niplo", "Cant. Mango", "Cant. ChRing", "Cant. Tubo", "Cant. Wedge",
                            "Trad. Brida Orif.", "Trad. Brida Línea", "Trad. Junta", "Trad. Tornillería", "Trad. Tapones", "Trad. Extractor",
                            "Trad. Placa", "Trad. Niplo", "Trad. Mango", "Trad. ChRing", "Trad. Tubo", "Trad. Wedge"]

            headers_temp = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                            "PO", "Posición", "Subposición", "Tipo", "Tipo TW",
                            "Tamaño", "Rating", "Facing", "Standard TW", "Material TW",
                            "Long. STD (mm)", "Long. Ins. (mm)", "Ø Raíz (mm)", "Ø Punta (mm)", "Sensor",
                            "Material Sheath/Stem", "Ø Sheath/Stem (mm)", "Insulation", "Temp Inf (ºC)", "Temp Sup ºC",
                            "Material Nipple Ext.", "Long. Nipple Ext. (mm)", "Material Head/Case", "Con. Elec./Diam. Case", "TT/Terminal Insulation",
                            "Material Brida LapJoint", "Material Junta", "Puntal", "Tubo", "NACE",
                            "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual", "Stress",
                            "Geometría", "Long. Cónica (mm)", "Long. Recta (mm)", "Bore // Tip", "Notas Cálculo",
                            "Cambios Técnicos", "Notas Técnicas", "Nº Doc. EIPSA Cálculo", "Estado Cálculo", "Fecha Estado Cálculo",
                            "Nº Doc. EIPSA Plano", "Estado Plano", "Fecha Estado Plano", "Notas Planos", "Orden de Compra",
                            "Fecha Orden Compra", "Notas Orden Compra", "Plano Dimensional", "Plano OF Sensor", "Fecha OF Sensor", 
                            "Notas Sensor", "Estado Fabricación Sensor", "Plano OF TW", "Fecha OF TW", "Notas TW",
                            "Estado Fabricación TW", "Colada Barra", "Cert. Barra", "Colada Brida", "Cert. Brida",
                            "Long. Corte TW (mm)", "Cota A Sensor (mm)", "Cota B Sensor (mm)", "Cota L Sensor (mm)", "Tapón",
                            "Estado Fabricación", "Inspección", "Fecha Inspección", "Envío RN", "Fecha RN", "Cod. Equipo", "Cod. Fab. Equipo",
                            "Trad. Equipo", "Cod. Barra", "Cod. Fab. Barra", "Cant. Barra", "Cod. Tubo",
                            "Cod. Fab. Tubo", "Cant. Tubo", "Cod. Brida", "Cod. Fab. Brida", "Cant. Brida",
                            "Cod. Sensor", "Cod. Fab. Sensor", "Cant. Sensor", "Cod. Cabeza", "Cod. Fab. Cabeza",
                            "Cant. Cabeza", "Cod. BTB", "Cod. Fab. BTB", "Cant. BTB", "Cod. Niplo Ext.",
                            "Cod. Fab. Niplo Ext.", "Cant. Niplo Ext.", "Cod. Muelle", "Cod. Fab. Muelle", "Cant. Muelle",
                            "Cod. Puntal", "Cod. Fab. Puntal", "Cant. Puntal", "Cod. Tapón", "Cod. Fab. Tapón", "Cant. Tapón",
                            "Cod. TW", "Cod. Fab. TW", "Cant. TW", "Cod. Adit.", "Cod. Fab. Adit.",
                            "Cant. Adit", "Pedido Tipo Tag", "Trad. Barra", "Trad. Tubo", "Trad. Brida",
                            "Trad. Sensor", "Trad. Cabeza", "Trad. BTB", "Trad. Niplo Ext.", "Trad. Muelle",
                            "Trad. Puntal", "Trad. Tapón", "Trad. TW", "Trad. Adit.", "Fecha PMI", "Fecha PH1",
                            "Manómetro PH1", "Presión PH1", "Estado PH1", "Notas PH1", "Fecha PH2",
                            "Manómetro PH2", "Presión PH2", "Estado PH2", "Notas PH2", "Fecha LP",
                            "LP Colada 9PR5", "LP Colada 9D1B", "LP Colada 996PB", "Estado LP", "Notas LP",
                            "Fecha Dureza", "Dureza", "Dureza HB", "Bola", "Carga",
                            "Colada Dureza", "Estado Dureza", "Notas Dureza", "Fecha Verif. Dim.", "Estado Verif. Dim.",
                            "Notas Verif. Dim", "Fecha Verif. OF", "Estado Verif. OF.", "Notas Verif. OF", "Fecha Verif. OF Sensor",
                            "Estado Verif. OF Sensor", "Notas Verif. OF Sensor", "Fotos",
                            "Posición", "Subposición", "Importe Factura", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas", "Estado Fact", "Fotos 2", "ØOrigen"]

            headers_level = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                            "PO", "Posición", "Subposición", "Tipo", "Modelo",
                            "Material Cuerpo", "Tipo Conex. Proc.", "Tamaño Conex. Proc.", "Rating Conex. Proc.", "Facing Conex. Proc.",
                            "Tipo Conex.", "Visibilidad (mm)", "Long. C-C (mm)", "Tipo Válv.", "Tipo Conex. Ext.",
                            "Tamaño Conex. Ext.", "Rating Conex. Ext.", "Facing Conex. Ext.", "Junta", "Tornillería",
                            "Iluminador", "Mat. Flotador", "Mat. Cubierta", "Escala", "Banderas",
                            "Cod. IP", "Tipo Brida", "Niplo Hex.", "Niplo Tubo", "Antifrost",
                            "NACE", "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual",
                            "Dim. Flotador", "Junta Bridas", "Cambios Técnicos", "Notas Técnicas", "Nº Doc. EIPSA Plano",
                            "Estado Plano", "Fecha Estado Plano", "Notas Plano", "Orden de Compra", "Fecha Orden Compra",
                            "Notas Orden Compra", "Plano Dimensional", "Plano OF", "Fecha OF", "Notas Equipo",
                            "Colada Cuerpo", "Cert. Cuerpo", "Colada Cuerpo Vlv", "Cert. Cuerpo Vlv", "Colada Brida Vlv", "Cert. Brida Vlv",
                            "Estado Fabricación", "Inspección", "Fecha Inspección", "Envío RN", "Fecha RN", "Cod. Equipo", "Cod. Fab. Equipo",
                            "Trad. Equipo", "Cod. Cuerpo", "Cod. Fab. Cuerpo", "Cant. Cuerpo", "Cod. Cubierta",
                            "Cod. Fab. Cubierta", "Cant. Cubierta", "Cod. Tornillería", "Cod. Fab. Tornillería", "Cant. Tornillería",
                            "Cdo. Niplo Hex.", "Cod. Fab. Niplo Hex.", "Cant. Niplo Hex.", "Cod. Válv.", "Cod. Fab. Válv.",
                            "Cant. Válv.", "Cod. Brida", "Cod. Fab. Brida", "Cant. Brida", "Cod. DV",
                            "Cod. Fab. DV", "Cant. DV", "Cod. Escala", "Cod. Fab. Escala", "Cant. Escala",
                            "Cod. Ilum.", "Cod. Fab. Ilum", "Cant. Ilum", "Cod. Junta Vidrio", "Cod. Fab. Junta Vidrio",
                            "Cant. Junta Vidrio", "Cod. Vidrio", "Cod. Fab. Vidrio", "Cant. Vidrio", "Cod. Flotador",
                            "Cod. Fab. Flotador", "Cant. Flotador", "Cod. Mica", "Cod. Fab. Mica", "Cant. Mica",
                            "Cod. Flags", "Cod. Fab. Flags", "Cant. Flags", "Cod. Junta Brida", "Cod. Fab. Junta Brida",
                            "Cant. Junta Brida", "Cod. Niplo Tubo", "Cod. Fab. Niplo Tubo", "Cant. Niplo Tubo", "Cod. Antifrost",
                            "Cod. Fab. Antifrost", "Cant. Antifrost", "Pedido Tipo Tag", "Trad. Cuerpo", "Trad. Cubierta",
                            "Trad. Tornillería", "Trad. Niplo Hex.", "Trad. Válv", "Trad. Brida", "Trad. DV",
                            "Trad. Escala", "Trad. Ilum.", "Trad. Junta Vidrio", "Trad. Vidrio", "Trad. Flotador",
                            "Trad. Mica", "Trad. Flags", "Trad. Junta Brida", "Trad. Niplo Tubo", "Trad. Antifrost",
                            "Fecha PMI", "Fecha PH1", "Manómetro PH1", "Presión PH1",
                            "Estado PH1", "Notas PH1", "Fecha PH2", "Manómetro PH2", "Presión PH2",
                            "Estado PH2", "Notas PH2", "Fecha LP", "LP Colada 9PR5", "LP Colada 9D1B",
                            "LP Colada 996PB", "Estado LP", "Notas LP", "Fecha Dureza", "Dureza",
                            "Dureza HB", "Bola", "Carga", "Colada Dureza", "Estado Dureza",
                            "Notas Dureza", "Fecha Verif. Dim.", "Estado Verif. Dim.", "Notas Verif. Dim", "Fecha Verif. OF",
                            "Estado Verif. OF", "Notas Verif. OF", "Fotos",
                            "Posición", "Subposición", "Importe", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas", "Estado Fact", "Fotos 2"]

            headers_others = ["ID", "TAG", "Estado", "Nº Oferta", "Nº Pedido",
                            "PO", "Posición", "Subposición", "Descripción", "Código Equipo",
                            "NACE", "Precio (€)", "Notas Oferta", "Cambio Comercial", "Fecha Contractual",
                            "Plano Dimensional", "Plano OF", "Fecha OF", "Colada", "Cert. Colada", "Estado Fabricación", "Inspección", "Fecha Inspección", "Envío RN", "Fecha RN",
                            "Fecha PMI", "Fecha PH1", "Manómetro PH1", "Presión PH1",
                            "Estado PH1", "Notas PH1", "Fecha PH2", "Manómetro PH2", "Presión PH2",
                            "Estado PH2", "Notas PH2", "Fecha LP", "LP Colada 9PR5", "LP Colada 9D1B",
                            "LP Colada 996PB", "Estado LP", "Notas LP", "Fecha Dureza", "Dureza",
                            "Dureza HB", "Bola", "Carga", "Colada Dureza", "Estado Dureza",
                            "Notas Dureza", "Fecha Verif. Dim.", "Estado Verif. Dim.", "Notas Verif. Dim", "Fecha Verif. OF",
                            "Estado Verif. OF", "Notas Verif. OF", "Fotos",
                            "Posición", "Subposición", "Importe", "Diferencia", "CajaBr", "CajaPl", "Descripción", "Notas", "Estado Fact", "Fotos 2"]

            self.original_headers = [self.model.headerData(col, QtCore.Qt.Orientation.Horizontal) for col in range(self.model.columnCount())]

            if self.variable == 'Caudal':
                self.model.setAllColumnHeaders(headers_flow)
            elif self.variable == 'Temperatura':
                self.model.setAllColumnHeaders(headers_temp)
            elif self.variable == 'Nivel':
                self.model.setAllColumnHeaders(headers_level)
            elif self.variable == 'Otros':
                self.model.setAllColumnHeaders(headers_others)

        # Getting the unique values for each column of the model
            for column in range(self.model.columnCount()):
                list_valuesUnique = []
                if column not in self.checkbox_states:
                    self.checkbox_states[column] = {}
                    self.checkbox_states[column]['Seleccionar todo'] = True
                    for row in range(self.model.rowCount()):
                        value = self.model.record(row).value(column)
                        if value not in list_valuesUnique:
                            if isinstance(value, QtCore.QDate):
                                value=value.toString("dd/MM/yyyy")
                            list_valuesUnique.append(str(value))
                            self.checkbox_states[column][value] = True
                    self.dict_valuesuniques[column] = list_valuesUnique

        # Setting cells with comboboxes
            list_fab_state = ['','PTE.APROBACIÓN','EN FABRICACIÓN','INSPECCIÓN','ENVIADO']
            if self.variable == 'Caudal':
                for i in range(9):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_flow[i]]))
                    self.tableEditTags.setItemDelegateForColumn(i+8, self.combo_itemtype)
                for i in range(7):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_flow[i+9]]))
                    self.tableEditTags.setItemDelegateForColumn(i+19, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_flow[16]]))
                self.tableEditTags.setItemDelegateForColumn(32, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_flow[17]]))
                self.tableEditTags.setItemDelegateForColumn(44, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_flow[5]]))
                self.tableEditTags.setItemDelegateForColumn(42, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, list_fab_state)
                self.tableEditTags.setItemDelegateForColumn(135, self.combo_itemtype)

            elif self.variable == 'Temperatura':
                for i in range(5):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_temp[i]]))
                    self.tableEditTags.setItemDelegateForColumn(i+8, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_temp[5]]))
                self.tableEditTags.setItemDelegateForColumn(14, self.combo_itemtype)
                for i in range(6,24):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_temp[i]]))
                    self.tableEditTags.setItemDelegateForColumn(i+11, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, list_fab_state)
                self.tableEditTags.setItemDelegateForColumn(61, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, list_fab_state)
                self.tableEditTags.setItemDelegateForColumn(65, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_temp[24]]))
                self.tableEditTags.setItemDelegateForColumn(74, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, list_fab_state)
                self.tableEditTags.setItemDelegateForColumn(75, self.combo_itemtype)

            elif self.variable == 'Nivel':
                for i in range(8):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_level[i]]))
                    self.tableEditTags.setItemDelegateForColumn(i+8, self.combo_itemtype)
                for i in range(18):
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_level[i+8]]))
                    self.tableEditTags.setItemDelegateForColumn(i+18, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, list_fab_state)
                self.tableEditTags.setItemDelegateForColumn(61, self.combo_itemtype)

            elif self.variable == 'Otros':
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, sorted([x[0] for x in self.all_results_others[0]]))
                self.tableEditTags.setItemDelegateForColumn(10, self.combo_itemtype)
                self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags, list_fab_state)
                self.tableEditTags.setItemDelegateForColumn(20, self.combo_itemtype)

            self.tableEditTags.sortByColumn(1, QtCore.Qt.SortOrder.AscendingOrder)

            self.model.dataChanged.connect(self.saveChanges)
            self.selection_model = self.tableEditTags.selectionModel()
            self.selection_model.selectionChanged.connect(lambda: self.countSelectedCells(self.model))

            if self.variable2 is not None:
                self.tableEditTags2.show()
                self.checkbox_states2 = {}
                self.dict_valuesuniques2 = {}
                self.dict_ordersort2 = {}
                self.hiddencolumns2 = []

                self.tableEditTags2.setModel(None)
                self.tableEditTags2.setModel(self.proxy2)
                self.model2.select()

                self.proxy2.setSourceModel(self.model2)
                self.tableEditTags2.setModel(self.proxy2)

                columns_number=self.model2.columnCount()
                for column in range(columns_number):
                    self.tableEditTags2.setItemDelegateForColumn(column, None)

                if self.username in ['julian.martinez']:
                    self.model.column_range = range(0,columns_number)
                else:
                    self.model2.column_range = list(range(self.initial_column_,self.initial_column_ + 4)) + list(range(self.initial_column2_,columns_number))

                if self.variable2 == 'Temperatura':
                    for i in range(80,132):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(134,138):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(139,143):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(144,149):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(150,157):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(158,160):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(161,163):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(164,166):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(167,columns_number-1):
                        self.tableEditTags2.hideColumn(i)

                elif self.variable2 == 'Nivel':
                    for i in range(66,138):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(140,144):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(145,149):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(150,155):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(156,163):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(164,166):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(167,169):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(170,columns_number-1):
                        self.tableEditTags2.hideColumn(i)

                elif self.variable2 == 'Otros':
                    for i in range(27,31):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(32,36):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(37,42):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(43,50):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(51,53):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(54,56):
                        self.tableEditTags2.hideColumn(i)
                    for i in range(57,columns_number-1):
                        self.tableEditTags2.hideColumn(i)

                if self.variable2 == 'Temperatura':
                    self.tableEditTags2.hideColumn(35)
                elif self.variable2 == 'Nivel':
                    self.tableEditTags2.hideColumn(36)
                elif self.variable2 == 'Otros':
                    self.tableEditTags2.hideColumn(11)

                self.tableEditTags2.setItemDelegate(AlignDelegate(self.tableEditTags2))
                self.tableEditTags2.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
                self.tableEditTags2.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
                self.tableEditTags2.horizontalHeader().setSectionResizeMode(columns_number-2,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
                self.tableEditTags2.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")
                self.tableEditTags2.setStyleSheet("gridline-color: #CCCCCC")
                self.tableEditTags2.setObjectName("tableEditTags2")
                self.gridLayout_2.addWidget(self.tableEditTags2, 5, 0, 1, 1)
                self.tableEditTags2.setSortingEnabled(False)
                self.tableEditTags2.horizontalHeader().sectionDoubleClicked.connect(lambda logicalIndex: self.on_view_horizontalHeader_sectionClicked(logicalIndex, self.tableEditTags2, self.model2, self.proxy2))
                self.tableEditTags2.horizontalHeader().customContextMenuRequested.connect(self.showColumnContextMenu)
                self.tableEditTags2.horizontalHeader().setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)

                if self.variable2 == 'Temperatura':
                    self.model2.setAllColumnHeaders(headers_temp)
                elif self.variable2 == 'Nivel':
                    self.model2.setAllColumnHeaders(headers_level)
                elif self.variable2 == 'Otros':
                    self.model2.setAllColumnHeaders(headers_others)

            # Getting the unique values for each column of the model
                for column in range(self.model2.columnCount()):
                    list_valuesUnique = []
                    if column not in self.checkbox_states2:
                        self.checkbox_states2[column] = {}
                        self.checkbox_states2[column]['Seleccionar todo'] = True
                        for row in range(self.model2.rowCount()):
                            value = self.model2.record(row).value(column)
                            if value not in list_valuesUnique:
                                if isinstance(value, QtCore.QDate):
                                    value=value.toString("dd/MM/yyyy")
                                list_valuesUnique.append(str(value))
                                self.checkbox_states2[column][value] = True
                        self.dict_valuesuniques2[column] = list_valuesUnique

            # Setting cells with comboboxes
                list_fab_state = ['','PTE.APROBACIÓN','EN FABRICACIÓN','INSPECCIÓN','ENVIADO']
                if self.variable2 == 'Temperatura':
                    for i in range(5):
                        self.combo_itemtype = EditableComboBoxDelegate2(self.tableEditTags2, sorted([x[0] for x in self.all_results_temp[i]]))
                        self.tableEditTags2.setItemDelegateForColumn(i+8, self.combo_itemtype)
                    self.combo_itemtype = EditableComboBoxDelegate2(self.tableEditTags2, sorted([x[0] for x in self.all_results_temp[5]]))
                    self.tableEditTags2.setItemDelegateForColumn(14, self.combo_itemtype)
                    for i in range(6,24):
                        self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags2, sorted([x[0] for x in self.all_results_temp[i]]))
                        self.tableEditTags2.setItemDelegateForColumn(i+11, self.combo_itemtype)
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags2, list_fab_state)
                    self.tableEditTags2.setItemDelegateForColumn(61, self.combo_itemtype)
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags2, list_fab_state)
                    self.tableEditTags2.setItemDelegateForColumn(65, self.combo_itemtype)
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags2, sorted([x[0] for x in self.all_results_temp[24]]))
                    self.tableEditTags2.setItemDelegateForColumn(74, self.combo_itemtype)
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags2, list_fab_state)
                    self.tableEditTags2.setItemDelegateForColumn(75, self.combo_itemtype)

                elif self.variable2 == 'Nivel':
                    for i in range(8):
                        self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags2, sorted([x[0] for x in self.all_results_level[i]]))
                        self.tableEditTags2.setItemDelegateForColumn(i+8, self.combo_itemtype)
                    for i in range(18):
                        self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags2, sorted([x[0] for x in self.all_results_level[i+8]]))
                        self.tableEditTags2.setItemDelegateForColumn(i+18, self.combo_itemtype)
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags2, list_fab_state)
                    self.tableEditTags2.setItemDelegateForColumn(61, self.combo_itemtype)

                elif self.variable2 == 'Otros':
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags2, sorted([x[0] for x in self.all_results_others[0]]))
                    self.tableEditTags2.setItemDelegateForColumn(10, self.combo_itemtype)
                    self.combo_itemtype = EditableComboBoxDelegate(self.tableEditTags2, list_fab_state)
                    self.tableEditTags2.setItemDelegateForColumn(20, self.combo_itemtype)

                self.tableEditTags2.sortByColumn(1, QtCore.Qt.SortOrder.AscendingOrder)

                self.model2.dataChanged.connect(self.saveChanges)
                self.selection_model = self.tableEditTags2.selectionModel()
                self.selection_model.selectionChanged.connect(lambda: self.countSelectedCells(self.model2))

                self.tableEditTags2.doubleClicked.connect(lambda index: self.open_pics(index, self.variable2))
            else:
                self.tableEditTags2.hide()

        else:
            self.model.dataChanged.connect(self.saveChanges)

            MessageHelper.show_message("No hay TAGS introducidos para este pedido", "warning")

        self.tableEditTags.doubleClicked.connect(lambda index: self.open_pics(index, self.variable))

# Function to open equipment photos
    def open_pics(self, index, variable):
        """
        Opens a file based on the provided index and variable.

        Args:
            index (QModelIndex): The index representing the selected cell in the table.
            variable (str): The variable type to determine the relevant column (e.g., 'Caudal', 'Temperatura', 'Nivel', 'Otros').

        Raises:
            Exception: If there is an error while trying to open the file, a message box displays the error details.
        """
        if ((variable == 'Caudal' and index.column() in [133, 134])
        or (variable == 'Temperatura' and index.column() in [166, 176])
        or (variable == 'Nivel' and index.column() in [169, 179])
        or (variable == 'Otros' and index.column() in [56, 66])):
            value = index.data()

            if value != '':
                try:
                    file_path = os.path.normpath(value)
                    os.startfile(file_path)

                except (Exception, psycopg2.DatabaseError) as error:
                    MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                                + str(error), "critical")

# Function when header is clicked
    def on_view_horizontalHeader_sectionClicked(self, logicalIndex, table, model, proxy):
        """
        Displays a menu when a column header is clicked. The menu includes options for sorting, filtering, and managing column visibility.
        
        Args:
            logicalIndex (int): Index of the clicked column.
            table (QtWidgets.QTableView): The table view displaying the data.
            model (QtGui.QStandardItemModel): The model associated with the table.
            proxy (QtCore.QSortFilterProxyModel): The proxy model used for filtering and sorting.
        """
        if isinstance(model, EditableTableModel2):
            self.logicalIndex = logicalIndex
            self.menuValues = QtWidgets.QMenu(self)
            self.signalMapper = QtCore.QSignalMapper(table)

            valuesUnique_view = {table.model().index(row, self.logicalIndex).data(Qt.ItemDataRole.DisplayRole) for row in range(table.model().rowCount())}
            valuesUnique_view = [value.toString("dd/MM/yyyy") if isinstance(value, QtCore.QDate) else value for value in valuesUnique_view]

            actionSortAscending = QtGui.QAction("Ordenar Ascendente", table)
            actionSortAscending.triggered.connect(lambda: self.on_actionSortAscending_triggered(table))
            self.menuValues.addAction(actionSortAscending)
            actionSortDescending = QtGui.QAction("Ordenar Descendente", table)
            actionSortDescending.triggered.connect(lambda: self.on_actionSortDescending_triggered(table))
            self.menuValues.addAction(actionSortDescending)
            self.menuValues.addSeparator()

            actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro", table)
            actionDeleteFilterColumn.triggered.connect(lambda: self.on_actionDeleteFilterColumn_triggered(table, model, proxy))
            self.menuValues.addAction(actionDeleteFilterColumn)
            self.menuValues.addSeparator()

            actionTextFilter = QtGui.QAction("Buscar...", table)
            actionTextFilter.triggered.connect(lambda: self.on_actionTextFilter_triggered(model, proxy))
            self.menuValues.addAction(actionTextFilter)
            self.menuValues.addSeparator()

            scroll_menu = QtWidgets.QScrollArea()
            scroll_menu.setWidgetResizable(True)
            scroll_widget = QtWidgets.QWidget(scroll_menu)
            scroll_menu.setWidget(scroll_widget)
            scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

            checkbox_all_widget = QtWidgets.QCheckBox('Seleccionar todo')

            if not self.checkbox_states2[self.logicalIndex]['Seleccionar todo'] == True:
                checkbox_all_widget.setChecked(False)
            else:
                checkbox_all_widget.setChecked(True)
            
            checkbox_all_widget.toggled.connect(lambda checked, name='Seleccionar todo': self.on_select_all_toggled(checked, name, model))

            scroll_layout.addWidget(checkbox_all_widget)
            self.action_checkbox_map2['Seleccionar todo'] = checkbox_all_widget

            if len(self.dict_ordersort2) != 0 and self.logicalIndex in self.dict_ordersort2:
                list_uniquevalues = sorted(list(set(self.dict_valuesuniques2[self.logicalIndex])))
            else:
                list_uniquevalues = sorted(list(set(valuesUnique_view)))

            for actionName in list_uniquevalues:
                checkbox_widget = QtWidgets.QCheckBox(str(actionName))

                if self.logicalIndex not in self.checkbox_filters2:
                    checkbox_widget.setChecked(True)
                elif actionName not in self.checkbox_filters2[self.logicalIndex]:
                    checkbox_widget.setChecked(False)
                else:
                    checkbox_widget.setChecked(True)

                checkbox_widget.toggled.connect(lambda checked, name=actionName: self.on_checkbox_toggled(checked, name, model))

                scroll_layout.addWidget(checkbox_widget)
                self.action_checkbox_map2[actionName] = checkbox_widget

            action_scroll_menu = QtWidgets.QWidgetAction(self.menuValues)
            action_scroll_menu.setDefaultWidget(scroll_menu)
            self.menuValues.addAction(action_scroll_menu)

            self.menuValues.addSeparator()

            accept_button = QtGui.QAction("ACEPTAR", table)
            accept_button.triggered.connect(lambda: self.menu_acceptbutton_triggered(proxy))

            cancel_button = QtGui.QAction("CANCELAR", table)
            cancel_button.triggered.connect(self.menu_cancelbutton_triggered)

            self.menuValues.addAction(accept_button)
            self.menuValues.addAction(cancel_button)

            self.menuValues.setStyleSheet("QMenu::item:selected { background-color: #33bdef; }"
                                            "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

            headerPos = table.mapToGlobal(table.horizontalHeader().pos())        

            posY = headerPos.y() + table.horizontalHeader().height()
            scrollX = table.horizontalScrollBar().value()
            xInView = table.horizontalHeader().sectionViewportPosition(logicalIndex)
            posX = headerPos.x() + xInView - scrollX

            self.menuValues.exec(QtCore.QPoint(posX, posY))
        
        else:
            self.logicalIndex = logicalIndex
            self.menuValues = QtWidgets.QMenu(self)
            self.signalMapper = QtCore.QSignalMapper(table)

            valuesUnique_view = {table.model().index(row, self.logicalIndex).data(Qt.ItemDataRole.DisplayRole) for row in range(table.model().rowCount())}
            valuesUnique_view = [value.toString("dd/MM/yyyy") if isinstance(value, QtCore.QDate) else value for value in valuesUnique_view]

            actionSortAscending = QtGui.QAction("Ordenar Ascendente", table)
            actionSortAscending.triggered.connect(lambda: self.on_actionSortAscending_triggered(table))
            self.menuValues.addAction(actionSortAscending)
            actionSortDescending = QtGui.QAction("Ordenar Descendente", table)
            actionSortDescending.triggered.connect(lambda: self.on_actionSortDescending_triggered(table))
            self.menuValues.addAction(actionSortDescending)
            self.menuValues.addSeparator()

            actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro", table)
            actionDeleteFilterColumn.triggered.connect(lambda: self.on_actionDeleteFilterColumn_triggered(table, model, proxy))
            self.menuValues.addAction(actionDeleteFilterColumn)
            self.menuValues.addSeparator()

            actionTextFilter = QtGui.QAction("Buscar...", table)
            actionTextFilter.triggered.connect(lambda: self.on_actionTextFilter_triggered(model, proxy))
            self.menuValues.addAction(actionTextFilter)
            self.menuValues.addSeparator()

            scroll_menu = QtWidgets.QScrollArea()
            scroll_menu.setWidgetResizable(True)
            scroll_widget = QtWidgets.QWidget(scroll_menu)
            scroll_menu.setWidget(scroll_widget)
            scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

            checkbox_all_widget = QtWidgets.QCheckBox('Seleccionar todo')

            if not self.checkbox_states[self.logicalIndex]['Seleccionar todo'] == True:
                checkbox_all_widget.setChecked(False)
            else:
                checkbox_all_widget.setChecked(True)
            
            checkbox_all_widget.toggled.connect(lambda checked, name='Seleccionar todo': self.on_select_all_toggled(checked, name, model))

            scroll_layout.addWidget(checkbox_all_widget)
            self.action_checkbox_map['Seleccionar todo'] = checkbox_all_widget

            if len(self.dict_ordersort) != 0 and self.logicalIndex in self.dict_ordersort:
                list_uniquevalues = sorted(list(set(self.dict_valuesuniques[self.logicalIndex])))
            else:
                list_uniquevalues = sorted(list(set(valuesUnique_view)))

            for actionName in list_uniquevalues:
                checkbox_widget = QtWidgets.QCheckBox(str(actionName))

                if self.logicalIndex not in self.checkbox_filters:
                    checkbox_widget.setChecked(True)
                elif actionName not in self.checkbox_filters[self.logicalIndex]:
                    checkbox_widget.setChecked(False)
                else:
                    checkbox_widget.setChecked(True)

                checkbox_widget.toggled.connect(lambda checked, name=actionName: self.on_checkbox_toggled(checked, name, model))

                scroll_layout.addWidget(checkbox_widget)
                self.action_checkbox_map[actionName] = checkbox_widget

            action_scroll_menu = QtWidgets.QWidgetAction(self.menuValues)
            action_scroll_menu.setDefaultWidget(scroll_menu)
            self.menuValues.addAction(action_scroll_menu)

            self.menuValues.addSeparator()

            accept_button = QtGui.QAction("ACEPTAR", table)
            accept_button.triggered.connect(lambda: self.menu_acceptbutton_triggered(proxy))

            cancel_button = QtGui.QAction("CANCELAR", table)
            cancel_button.triggered.connect(self.menu_cancelbutton_triggered)

            self.menuValues.addAction(accept_button)
            self.menuValues.addAction(cancel_button)

            self.menuValues.setStyleSheet("QMenu::item:selected { background-color: #33bdef; }"
                                            "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

            headerPos = table.mapToGlobal(table.horizontalHeader().pos())        

            posY = headerPos.y() + table.horizontalHeader().height()
            scrollX = table.horizontalScrollBar().value()
            xInView = table.horizontalHeader().sectionViewportPosition(logicalIndex)
            posX = headerPos.x() + xInView - scrollX

            self.menuValues.exec(QtCore.QPoint(posX, posY))

# Function when cancel button of menu is clicked
    def menu_cancelbutton_triggered(self):
        """
        Hides the menu when the cancel button is clicked.
        """
        self.menuValues.hide()

# Function when accept button of menu is clicked
    def menu_acceptbutton_triggered(self, proxy):
        """
        Applies the selected filters and updates the table model with the new filters.
        """
        if isinstance(proxy, CustomProxyModel2):
            for column, filters in self.checkbox_filters2.items():
                if filters:
                    proxy.setFilter(filters, column, exact_match=True)
                else:
                    proxy.setFilter(None, column)
        else:
            for column, filters in self.checkbox_filters.items():
                if filters:
                    proxy.setFilter(filters, column, exact_match=True)
                else:
                    proxy.setFilter(None, column)

        # self.tableEditTags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        # self.tableEditTags.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        # self.tableEditTags.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function when select all checkbox is clicked
    def on_select_all_toggled(self, checked, action_name, model):
        """
        Toggles the state of all checkboxes in the filter menu when the 'Select All' checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the 'Select All' checkbox.
            action_name (str): The name of the action (usually 'Select All').
            model (QAbstractItemModel): The model associated with the table view.
        """
        filterColumn = self.logicalIndex

    # Load icon
        if not hasattr(self, 'icono_filter_active'):
            imagen_path = str(get_path("Resources", "Iconos", "Filter_Active.png"))
            self.icono_filter_active = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
        
    # Select map and state related to model
        checkbox_map = self.action_checkbox_map2 if isinstance(model, EditableTableModel2) else self.action_checkbox_map
        checkbox_states = self.checkbox_states2 if isinstance(model, EditableTableModel2) else self.checkbox_states

    # Change state of checkboxes if necessary
        for checkbox_name, checkbox_widget in checkbox_map.items():
            if checkbox_widget.isChecked() != checked:
                checkbox_widget.setChecked(checked)
                checkbox_states[self.logicalIndex][checkbox_widget.text()] = checked

    # Adjust icon of header
        all_checked = all(checkbox_widget.isChecked() for checkbox_widget in checkbox_map.values())
        model.setIconColumnHeader(filterColumn, self.icono_filter_active if all_checked else '')

# Function when checkbox of header menu is clicked
    def on_checkbox_toggled(self, checked, action_name, model):
        """
        Updates the filter state when an individual checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the checkbox.
            action_name (str): The name of the checkbox.
        """
        filterColumn = self.logicalIndex
        imagen_path = str(get_path("Resources", "Iconos", "Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            if isinstance(model, EditableTableModel2):
                if filterColumn not in self.checkbox_filters2:
                    self.checkbox_filters2[filterColumn] = [action_name]
                else:
                    if action_name not in self.checkbox_filters2[filterColumn]:
                        self.checkbox_filters2[filterColumn].append(action_name)
            else:
                if filterColumn not in self.checkbox_filters:
                    self.checkbox_filters[filterColumn] = [action_name]
                else:
                    if action_name not in self.checkbox_filters[filterColumn]:
                        self.checkbox_filters[filterColumn].append(action_name)
        else:
            if isinstance(model, EditableTableModel2):
                if filterColumn in self.checkbox_filters2 and action_name in self.checkbox_filters2[filterColumn]:
                    self.checkbox_filters2[filterColumn].remove(action_name)
            else:
                if filterColumn in self.checkbox_filters and action_name in self.checkbox_filters[filterColumn]:
                    self.checkbox_filters[filterColumn].remove(action_name)

        if isinstance(model, EditableTableModel2):
            if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map2.values()):
                model.setIconColumnHeader(filterColumn, '')
            else:
                model.setIconColumnHeader(filterColumn, icono)
        else:
            if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
                model.setIconColumnHeader(filterColumn, '')
            else:
                model.setIconColumnHeader(filterColumn, icono)

# Function to delete individual column filter
    def on_actionDeleteFilterColumn_triggered(self, table, model, proxy):
        """
        Removes the filter from the selected column and updates the table model.
        
        Args:
            table (QtWidgets.QTableView): The table view displaying the data.
            model (QtGui.QStandardItemModel): The model associated with the table.
            proxy (QtCore.QSortFilterProxyModel): The proxy model used for filtering and sorting.
        """
        if isinstance(model, EditableTableModel2):
            filterColumn = self.logicalIndex
            if filterColumn in proxy.filters:
                del proxy.filters[filterColumn]
            model.setIconColumnHeader(filterColumn, "")
            proxy.invalidateFilter()

            if filterColumn in self.checkbox_filters2:
                del self.checkbox_filters2[filterColumn]

            self.checkbox_states2[self.logicalIndex].clear()
            self.checkbox_states2[self.logicalIndex]["Seleccionar todo"] = True
            for row in range(table.model().rowCount()):
                value = model.record(row).value(filterColumn)
                if isinstance(value, QtCore.QDate):
                    value = value.toString("dd/MM/yyyy")
                self.checkbox_states2[self.logicalIndex][str(value)] = True

        else:
            filterColumn = self.logicalIndex
            if filterColumn in proxy.filters:
                del proxy.filters[filterColumn]
            model.setIconColumnHeader(filterColumn, "")
            proxy.invalidateFilter()

            if filterColumn in self.checkbox_filters:
                del self.checkbox_filters[filterColumn]

            self.checkbox_states[self.logicalIndex].clear()
            self.checkbox_states[self.logicalIndex]["Seleccionar todo"] = True
            for row in range(table.model().rowCount()):
                value = model.record(row).value(filterColumn)
                if isinstance(value, QtCore.QDate):
                    value = value.toString("dd/MM/yyyy")
                self.checkbox_states[self.logicalIndex][str(value)] = True

        table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        table.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        table.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

        self.selection_model = table.selectionModel()
        self.selection_model.selectionChanged.connect(self.countSelectedCells)

        if isinstance(model,EditableTableModel2):
            self.label_SumItems2.setText("")
            self.label_SumValue2.setText("")
            self.label_CountItems2.setText("")
            self.label_CountValue2.setText("")
        else:
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

# Function to order column ascending
    def on_actionSortAscending_triggered(self, table):
        """
        Sorts the selected column in ascending order.
        
        Args:
            table (QtWidgets.QTableView): The table view displaying the data.
        """
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.AscendingOrder
        table.sortByColumn(sortColumn, sortOrder)

# Function to order column descending
    def on_actionSortDescending_triggered(self, table):
        """
        Sorts the selected column in descending order.
        
        Args:
            table (QtWidgets.QTableView): The table view displaying the data.
        """
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.DescendingOrder
        table.sortByColumn(sortColumn, sortOrder)

# Function when text is searched
    def on_actionTextFilter_triggered(self, model, proxy):
        """
        Opens a dialog to enter a text filter and applies it to the selected column.
        
        Args:
            model (QtGui.QStandardItemModel): The model associated with the table.
            proxy (QtCore.QSortFilterProxyModel): The proxy model used for filtering and sorting.
        """
        filterColumn = self.logicalIndex
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle("Buscar")
        clickedButton = dlg.exec()

        if clickedButton == 1:
            stringAction = dlg.textValue()
            if re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', stringAction):
                stringAction=QtCore.QDate.fromString(stringAction,"dd/MM/yyyy")
                stringAction=stringAction.toString("yyyy-MM-dd")

            filterString = QtCore.QRegularExpression(stringAction, QtCore.QRegularExpression.PatternOption(0))
            # del self.proxy.filters[filterColumn]
            proxy.setFilter([stringAction], filterColumn, None)

            imagen_path = str(get_path("Resources", "Iconos", "Filter_Active.png"))
            icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
            model.setIconColumnHeader(filterColumn, icono)

# Function to show all hidden columns
    def show_columns(self):
        """
        Makes all previously hidden columns visible in the table and clears the list of hidden columns.
        """
        for column in self.hiddencolumns:
            self.tableEditTags.setColumnHidden(column, False)
        self.hiddencolumns.clear()

        if self.variable == 'Caudal':
            for i in range(140,self.model.columnCount()):
                self.tableEditTags.hideColumn(i)

        elif self.variable == 'Temperatura':
            for i in range(80,132):
                self.tableEditTags.hideColumn(i)
            for i in range(134,138):
                self.tableEditTags.hideColumn(i)
            for i in range(139,143):
                self.tableEditTags.hideColumn(i)
            for i in range(144,149):
                self.tableEditTags.hideColumn(i)
            for i in range(150,157):
                self.tableEditTags.hideColumn(i)
            for i in range(158,160):
                self.tableEditTags.hideColumn(i)
            for i in range(161,163):
                self.tableEditTags.hideColumn(i)
            for i in range(164,166):
                self.tableEditTags.hideColumn(i)
            for i in range(167,self.model.columnCount()):
                self.tableEditTags.hideColumn(i)

        elif self.variable == 'Nivel':
            for i in range(66,138):
                self.tableEditTags.hideColumn(i)
            for i in range(140,144):
                self.tableEditTags.hideColumn(i)
            for i in range(145,149):
                self.tableEditTags.hideColumn(i)
            for i in range(150,155):
                self.tableEditTags.hideColumn(i)
            for i in range(156,163):
                self.tableEditTags.hideColumn(i)
            for i in range(164,166):
                self.tableEditTags.hideColumn(i)
            for i in range(167,169):
                self.tableEditTags.hideColumn(i)
            for i in range(170,self.model.columnCount()):
                self.tableEditTags.hideColumn(i)

        elif self.variable == 'Otros':
            for i in range(27,31):
                self.tableEditTags.hideColumn(i)
            for i in range(32,36):
                self.tableEditTags.hideColumn(i)
            for i in range(37,42):
                self.tableEditTags.hideColumn(i)
            for i in range(43,50):
                self.tableEditTags.hideColumn(i)
            for i in range(51,53):
                self.tableEditTags.hideColumn(i)
            for i in range(54,56):
                self.tableEditTags.hideColumn(i)
            for i in range(57,self.model.columnCount()):
                self.tableEditTags.hideColumn(i)

        if self.variable == 'Caudal':
            self.tableEditTags.hideColumn(33)
        elif self.variable == 'Temperatura':
            self.tableEditTags.hideColumn(35)
        elif self.variable == 'Nivel':
            self.tableEditTags.hideColumn(36)
        elif self.variable == 'Otros':
            self.tableEditTags.hideColumn(11)

        for column in self.hiddencolumns2:
            self.tableEditTags2.setColumnHidden(column, False)
        self.hiddencolumns2.clear()

        if self.variable2 == 'Caudal':
            for i in range(140,self.model2.columnCount()):
                self.tableEditTags2.hideColumn(i)

        elif self.variable2 == 'Temperatura':
            for i in range(80,132):
                self.tableEditTags2.hideColumn(i)
            for i in range(134,138):
                self.tableEditTags2.hideColumn(i)
            for i in range(139,143):
                self.tableEditTags2.hideColumn(i)
            for i in range(144,149):
                self.tableEditTags2.hideColumn(i)
            for i in range(150,157):
                self.tableEditTags2.hideColumn(i)
            for i in range(158,160):
                self.tableEditTags2.hideColumn(i)
            for i in range(161,163):
                self.tableEditTags2.hideColumn(i)
            for i in range(164,166):
                self.tableEditTags2.hideColumn(i)
            for i in range(167,self.model2.columnCount()):
                self.tableEditTags2.hideColumn(i)

        elif self.variable2 == 'Nivel':
            for i in range(66,138):
                self.tableEditTags2.hideColumn(i)
            for i in range(140,144):
                self.tableEditTags2.hideColumn(i)
            for i in range(145,149):
                self.tableEditTags2.hideColumn(i)
            for i in range(150,155):
                self.tableEditTags2.hideColumn(i)
            for i in range(156,163):
                self.tableEditTags2.hideColumn(i)
            for i in range(164,166):
                self.tableEditTags2.hideColumn(i)
            for i in range(167,169):
                self.tableEditTags2.hideColumn(i)
            for i in range(170,self.model2.columnCount()):
                self.tableEditTags2.hideColumn(i)

        elif self.variable2 == 'Otros':
            for i in range(27,31):
                self.tableEditTags2.hideColumn(i)
            for i in range(32,36):
                self.tableEditTags2.hideColumn(i)
            for i in range(37,42):
                self.tableEditTags2.hideColumn(i)
            for i in range(43,50):
                self.tableEditTags2.hideColumn(i)
            for i in range(51,53):
                self.tableEditTags2.hideColumn(i)
            for i in range(54,56):
                self.tableEditTags2.hideColumn(i)
            for i in range(57,self.model2.columnCount()):
                self.tableEditTags2.hideColumn(i)

        if self.variable2 == 'Caudal':
            self.tableEditTags2.hideColumn(33)
        elif self.variable2 == 'Temperatura':
            self.tableEditTags2.hideColumn(35)
        elif self.variable2 == 'Nivel':
            self.tableEditTags2.hideColumn(36)
        elif self.variable2 == 'Otros':
            self.tableEditTags2.hideColumn(11)

# Function to create fabrication order
    def faborder(self):
        """
        Opens a window to create a fabrication order if data is present.
        """
        if self.username not in ['julian.martinez']:
            if self.proxy.rowCount() == 0:
                MessageHelper.show_message("No hay datos cargados", "warning")
            else:
                if self.variable in ['Caudal', 'Temperatura', 'Nivel']:
                    self.createfaborder_window=QtWidgets.QMainWindow()
                    self.ui=Ui_CreateFabOrder_Window(self.variable, self.proxy, self.model)
                    self.ui.setupUi(self.createfaborder_window)
                    self.createfaborder_window.showMaximized()

# Function to set inspection number
    def setinspection(self):
        """
        Sets the inspection number if data is present.
        """
        if self.username not in ['julian.martinez']:
            if self.proxy.rowCount() == 0:
                MessageHelper.show_message("No hay datos cargados", "warning")
            else:
                if self.variable in ['Caudal', 'Temperatura', 'Nivel']:
                    inspection(self.proxy, self.model, self.variable)

# Function to export data to excel
    def exporttoexcel(self):
        """
        Exports the visible data from the table to an Excel file. If no data is loaded, displays a warning message.

        Shows a message box if there is no data to export and allows the user to save the data to an Excel file.
        """
        if self.proxy.rowCount() == 0:
            MessageHelper.show_message("No hay datos cargados", "warning")
        else:
            final_data = []

            visible_columns = [col for col in range(self.model.columnCount()) if not self.tableEditTags.isColumnHidden(col)]
            visible_headers = self.model.getColumnHeaders(visible_columns)
            original_headers = [self.model.record().fieldName(col) for col in visible_columns]
            for row in range(self.proxy.rowCount()):
                tag_data = []
                for column in visible_columns:
                    value = self.proxy.data(self.proxy.index(row, column))
                    if isinstance(value, QDate):
                        value = value.toString("dd/MM/yyyy")
                    elif column in [55] and self.variable == 'Caudal':
                        value = int(value) if value != '' else 0
                    elif column in [15,16,41,42,70,71,72,73] and self.variable == 'Temperatura':
                        value = int(value) if value != '' else 0
                    tag_data.append(value)
                final_data.append(tag_data)

            final_data.insert(0, visible_headers)
            final_data.insert(1, original_headers)
            df = pd.DataFrame(final_data)
            df.columns = df.iloc[0]
            df = df[1:]

            output_path, _ = QtWidgets.QFileDialog.getSaveFileName(None, "Guardar Excel", "", "Archivos de Excel (*.xlsx)")
            if output_path:
                if not output_path.lower().endswith(".xlsx"):
                    output_path += ".xlsx"
                df.to_excel(output_path, index=False, header=True)

# Function to import data from excel
    def importexcel(self):
        input_file, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Seleccionar archivo Excel", "", "Archivos de Excel (*.xlsx)")

        if input_file:
        #Importing excel file into dataframe
            df_table = pd.read_excel(input_file, keep_default_na=False, skiprows=1, dtype={'image': str, 'document':str})
            df_table = df_table.fillna('')
            df_table = df_table.astype(str)

            df_final = df_table.drop([
                    "pmi_date",
                    "ph1_date",
                    "ph2_date",
                    "lp_date",
                    "hard_date",
                    "final_verif_dim_date",
                    "final_verif_of_eq_date",
                    "tag_images"
                    ],
                    axis=1,
                    errors="ignore",)

            try:
                with Database_Connection(config_database()) as conn:
                    with conn.cursor() as cur:
                        for index, row in df_table.iterrows():
                            if "id_tag_flow" in row:
                                id_value = row["id_tag_flow"]
                                table_name = 'tags_data.tags_flow'
                                where_clause = f"id_tag_flow = {id_value}"

                            elif "id_tag_temp" in row:
                                id_value = row["id_tag_temp"]
                                table_name = 'tags_data.tags_temp'
                                where_clause = f"id_tag_temp = {id_value}"

                            elif "id_tag_level" in row:
                                id_value = row["id_tag_level"]
                                table_name = 'tags_data.tags_level'
                                where_clause = f"id_tag_level = {id_value}"

                            elif "id_tag_others" in row:
                                id_value = row["id_tag_others"]
                                table_name = 'tags_data.tags_others'
                                where_clause = f"id_tag_others = {id_value}"

                            # Creating string for columns names and values
                            columns_values = [(column, row[column]) for column in df_final.columns if column not in ['tapping_size','tapping_number'] and not pd.isnull(row[column])]

                            columns = ', '.join([column for column, _ in columns_values])
                            values = ', '.join([f"'{int(float(value))}'" if column in ['plug_number', 'tapping_number', 'bolts_quantity', 'extractor_quantity', 'rating', 'sheath_stem_diam', 'nipple_ext_length', 'temp_inf', 'temp_sup', 'root_diam', 'tip_diam',] and value.endswith('.0')
                                                else (f"'{value.replace('.', ',')}'" if column in ['amount', 'orif_diam', 'dv_diam', 'plate_thk','plate_ext_diam', 'conical_length', 'straigth_length', 'bore_tip', 'length_cut_tw', 'dim_a_sensor', 'dim_b_sensor', 'dim_l_sensor']
                                                else ('NULL' if value == 'N/A' and column in ['std_length', 'ins_length']
                                                else ('NULL' if value == '' and column in ['rating', 'plate_thk', 'contractual_date', 'irc_date', 'rn_date', 'purchase_order_date', 'of_date', 'of_sensor_date', 'calc_state_date','dwg_state_date','plug_number']
                                                else "'{}'".format(value.replace('\'', '\'\''))))) for column, value in columns_values])

                        # Creating the SET  and WHERE clause with proper formatting
                            set_clause = ", ".join([f"{column} = {value}" for column, value in zip(columns.split(", ")[1:], values.split(", ")[1:])])

                        # Creating the update query and executing it after checking existing tags and id
                            sql_update = f'UPDATE {table_name} SET {set_clause} WHERE {where_clause}'
                            cur.execute(sql_update)
                    conn.commit()

                MessageHelper.show_message("Datos actualizados con éxito", "information")

            except (Exception, psycopg2.DatabaseError) as error:
                MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                            + str(error), "critical")

# Function to enable copy and paste cells
    def keyPressEvent(self, event):
        """
        Handles custom key events for cell operations in the table.

        Args:
            event (QtGui.QKeyEvent): The key event to handle.
        """
        if event.matches(QKeySequence.StandardKey.Copy):
            selected_indexes = self.tableEditTags.selectionModel().selectedIndexes()
            if selected_indexes:
                clipboard = QApplication.clipboard()
                text = self.get_selected_text(selected_indexes)
                if isinstance(text, QtCore.QDate):
                    text=text.toString("dd/MM/yyyy")
                clipboard.setText(str(text))

        elif event.matches(QKeySequence.StandardKey.Paste):
            self.model.dataChanged.disconnect(self.saveChanges)
            selected_indexes = self.tableEditTags.selectionModel().selectedIndexes()
            if selected_indexes:
                clipboard = QApplication.clipboard()
                text = clipboard.text()
                for index in selected_indexes:
                    current_row = index.row()
                    current_column = index.column()
                    first_column_value = self.proxy.data(self.proxy.index(current_row, 0))
                    target_row = None
                    for row in range(self.model.rowCount()):
                        if self.model.data(self.model.index(row, 0)) == first_column_value:
                            target_row = row
                            break
                    if target_row is not None:
                        target_index = self.model.index(target_row, current_column)
                        self.model.setData(target_index, text, Qt.ItemDataRole.EditRole)  # Pegar el valor en todas las celdas seleccionadas
                self.model.submitAll()

            self.model.dataChanged.connect(self.saveChanges)

        super().keyPressEvent(event)

# Function to get the text of the selected cells
    def get_selected_text(self, indexes):
        """
        Retrieves the text from the selected cells and returns it as a plain text string.

        Args:
            indexes (list of QModelIndex): A list of QModelIndex objects representing the selected cells.
        
        Returns:
            str: A string containing the text from the selected cells.
        """
        """
        Retrieves the text from the selected cells and returns it as a plain text string.

        Args:
            indexes (list of QModelIndex): A list of QModelIndex objects representing the selected cells.
        
        Returns:
            str: A string containing the text from the selected cells.
        """
        if len(indexes) == 1: # For only one cell selected
            index = indexes[0]
            cell_data = index.data(Qt.ItemDataRole.DisplayRole)
            return cell_data
        else:
            rows = set()
            cols = set()
            for index in indexes:
                rows.add(index.row())
                cols.add(index.column())

            text_doc = QTextDocument()
            cursor = QTextCursor(text_doc)

            for row in sorted(rows):
                for col in sorted(cols):
                    index = self.model.index(row, col)  # Obtain corresponding index
                    cell_data = index.data(Qt.ItemDataRole.DisplayRole)
                    cursor.insertText(str(cell_data))
                    cursor.insertText('\t')  # Tab separating columns
                cursor.insertText('\n')  # Line break at end of row

            return text_doc.toPlainText()

# Function to count selected cells and sum its values
    def countSelectedCells(self, model):
        """
        Counts the number of selected cells and sums their values. Updates the UI labels with the count and sum.
        """
        if isinstance(model,EditableTableModel2):
            if len(self.tableEditTags2.selectedIndexes()) > 1:
                locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
                self.label_SumItems2.setText("")
                self.label_SumValue2.setText("")
                self.label_CountItems2.setText("")
                self.label_CountValue2.setText("")

                sum_value = sum([self.euro_string_to_float(str(ix.data())) if re.match(r'^[\d.,]+\s€$', str(ix.data())) else float(str(ix.data()).replace(',', '.')) if str(ix.data()).replace(',', '.').replace('.', '', 1).isdigit() else 0 for ix in self.tableEditTags2.selectedIndexes()])
                count_value = len([ix for ix in self.tableEditTags2.selectedIndexes() if ix.data() != ""])
                if sum_value > 0:
                    self.label_SumItems2.setText("Suma:")
                    self.label_SumValue2.setText(locale.format_string("%.2f", sum_value, grouping=True))
                if count_value > 0:
                    self.label_CountItems2.setText("Recuento:")
                    self.label_CountValue2.setText(str(count_value))
            else:
                self.label_SumItems2.setText("")
                self.label_SumValue2.setText("")
                self.label_CountItems2.setText("")
                self.label_CountValue2.setText("")
        else:
            if len(self.tableEditTags.selectedIndexes()) > 1:
                locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
                self.label_SumItems.setText("")
                self.label_SumValue.setText("")
                self.label_CountItems.setText("")
                self.label_CountValue.setText("")

                sum_value = sum([self.euro_string_to_float(str(ix.data())) if re.match(r'^[\d.,]+\s€$', str(ix.data())) else float(str(ix.data()).replace(',', '.')) if str(ix.data()).replace(',', '.').replace('.', '', 1).isdigit() else 0 for ix in self.tableEditTags.selectedIndexes()])
                count_value = len([ix for ix in self.tableEditTags.selectedIndexes() if ix.data() != ""])
                if sum_value > 0:
                    self.label_SumItems.setText("Suma:")
                    self.label_SumValue.setText(locale.format_string("%.2f", sum_value, grouping=True))
                if count_value > 0:
                    self.label_CountItems.setText("Recuento:")
                    self.label_CountValue.setText(str(count_value))
            else:
                self.label_SumItems.setText("")
                self.label_SumValue.setText("")
                self.label_CountItems.setText("")
                self.label_CountValue.setText("")

# Function to format money string values
    def euro_string_to_float(self, euro_str):
        """
        Converts a string representing an amount in euros to a float.

        Args:
            euro_str (str): A string representing the amount in euros (e.g., "1.234,56 €").
        
        Returns:
            float: The numeric value of the amount as a float.
        """
        match = re.match(r'^([\d.,]+)\s€$', euro_str)
        if match:
            number_str = match.group(1)
            number_str = number_str.replace('.', '').replace(',', '.')
            return float(number_str)
        else:
            return 0.0

# Function for creating context menu
    def createContextMenu(self):
        """
        Creates a context menu with options for hiding selected columns.
        """
        self.context_menu = QtWidgets.QMenu(self)
        hide_columns_action = self.context_menu.addAction("Ocultar Columnas")
        hide_columns_action.triggered.connect(self.hideSelectedColumns)

# Function to show context menu when right-click
    def showColumnContextMenu(self, pos):
        """
        Displays the context menu at the specified position for column operations.

        Args:
            pos (QPoint): The position at which to display the context menu.
        """
        header = self.tableEditTags.horizontalHeader()
        column = header.logicalIndexAt(pos)
        self.context_menu.exec(self.tableEditTags.mapToGlobal(pos))

# Function to hide selected columns
    def hideSelectedColumns(self):
        """
        Hides the currently selected columns in the table and updates the list of hidden columns.
        """
        selected_columns = set()
        header = self.tableEditTags.horizontalHeader()
        for index in header.selectionModel().selectedColumns():
            selected_columns.add(index.column())

        for column in selected_columns:
            self.tableEditTags.setColumnHidden(column, True)
            self.hiddencolumns.append(column)

        self.context_menu.close()


# Function to select which material order has to be created
    def materialorder(self):
        """
        Initiates material order process based on the variable value.
        """
        if self.proxy.rowCount() == 0:
            MessageHelper.show_message("No hay datos cargados", "warning")
        else:
            if self.variable == 'Caudal':
                self.materialorder_flow()
            elif self.variable == 'Temperatura':
                self.materialorder_temp()
            elif self.variable == 'Nivel':
                self.materialorder_level()
            elif self.variable == 'Otros':
                self.materialorder_others()
            elif self.variable == 'Caudal+Temp':
                self.materialorder_flow()
                self.materialorder_temp()
            elif self.variable == 'Caudal+Nivel':
                self.materialorder_flow()
                self.materialorder_level()
            elif self.variable =='Temp+Nivel':
                self.materialorder_temp()
                self.materialorder_level()

# Function to create material order for flow elements
    def materialorder_flow(self):
        """
        Prompts for a flow material order number and processes it.
        """
        if self.username not in ['julian.martinez']:
            dlg = QtWidgets.QInputDialog()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle('Pedido Materiales Caudal')
            dlg.setLabelText('Introduce el pedido:')
            clickedButton=dlg.exec()

            if clickedButton == 1:
                numorder_pedmat = dlg.textValue()
                flow_matorder(self.proxy, self.model, self.numorder, numorder_pedmat, self.variable)

# Function to create material order for temperature elements
    def materialorder_temp(self):
        """
        Prompts for a temperature material order number and processes it.
        """
        if self.username not in ['julian.martinez']:
            dlg = QtWidgets.QInputDialog()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle('Pedido Materiales Temperatura')
            dlg.setLabelText('Introduce el pedido:')
            clickedButton=dlg.exec()

            if clickedButton == 1:
                numorder_pedmat = dlg.textValue()
                temp_matorder(self.proxy, self.model, self.numorder, numorder_pedmat, self.variable)

# Function to create material order for level elements
    def materialorder_level(self):
        """
        Prompts for a level material order number and processes it.
        """
        if self.username not in ['julian.martinez']:
            dlg = QtWidgets.QInputDialog()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle('Pedido Materiales Nivel')
            dlg.setLabelText('Introduce el pedido:')
            clickedButton=dlg.exec()

            if clickedButton == 1:
                numorder_pedmat = dlg.textValue()
                level_matorder(self.proxy, self.model, self.numorder, numorder_pedmat, self.variable)

# Function to create material order for others elements
    def materialorder_others(self):
        """
        Prompts for a material order number for other elements and processes it.
        """
        if self.username not in ['julian.martinez']:
            dlg = QtWidgets.QInputDialog()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle('Pedido Materiales Otros')
            dlg.setLabelText('Introduce el pedido:')
            clickedButton=dlg.exec()

            if clickedButton == 1:
                numorder_pedmat = dlg.textValue()
                others_matorder(self.proxy, self.model, self.numorder, numorder_pedmat, self.variable)


# Function to insert components OF drawings
    def insert_of(self, numorder):
        """
        Opens a window to insert a drawing if a number is provided.
        """
        if numorder == '':
            MessageHelper.show_message("Introduce un número de pedido", "warning")
        else:
            from windows.OF_DrawingInsertComp_Window import Ui_OF_DrawingInsertComp_Window
            self.of_drawing_insert_window_menu=QtWidgets.QMainWindow()
            self.ui=Ui_OF_DrawingInsertComp_Window(numorder, self.username)
            self.ui.setupUi(self.of_drawing_insert_window_menu)
            self.of_drawing_insert_window_menu.show()

# Function to insert text on existing PDF
    def editpdf(self):
        """
        Inserts text into an existing PDF based on data from database.

        Raises:
            Exception: If there is an error during the PDF editing process.
        """
        data = []
        column_count = self.proxy.columnCount()

        if column_count != 0:

            for row in range(self.proxy.rowCount()):
                row_data = [self.proxy.data(self.proxy.index(row, col)) for col in range(column_count)]
                data.append(row_data)

            df = pd.DataFrame(data, columns=self.original_headers)

            columns_interest = []

            list_item_type= df['item_type'].unique().tolist()

            for item_type in list_item_type:
                df_itemtype = df[df['item_type'] == item_type]

                if item_type in ['F+P','P']:
                    columns_interest = ["tag", "internal_diameter", "element_material", "orif_diam", "plate_thk", "dv_diam",
                                        "line_size", "rating", "facing", "schedule", "of_drawing"]
                elif item_type == 'RO':
                    columns_interest = ["tag", "internal_diameter", "element_material", "orif_diam", "plate_thk", "dv_diam",
                                        "line_size", "rating", "facing", "schedule", "of_drawing"]

                if len(columns_interest) != 0:
                    df_filtered_item = df_itemtype[columns_interest]
                    df_filtered_item = df_filtered_item.copy()

                    list_drawings= df_filtered_item['of_drawing'].unique().tolist()

                    for drawing in list_drawings:
                        df_final = df_filtered_item[df_filtered_item['of_drawing'] == drawing]

                        pdf_file, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Seleccionar archivo PDF", "", "Archivos PDF (*.pdf)")

                        if pdf_file:
                            try:
                                reader = PdfReader(pdf_file)

                                for row in range(df_filtered_item.shape[0]):
                                    page_overlay = PdfReader(self.new_content(df_final, item_type, drawing)).pages[0] # PdfReader(self.new_content(df_data.iloc[row,1], df_data.iloc[row,2], orientation)).pages[0]
                                    reader.pages[0].merge_page(page2=page_overlay)

                                path_parts = pdf_file.rsplit('/', 1)
                                first_part = path_parts[0] + "/"
                                name, extension = path_parts[1].rsplit('.', 1)

                                output_path = first_part + name + " RELLENO.pdf"

                                if output_path:

                                    writer = PdfWriter()
                                    writer.append_pages_from_reader(reader)
                                    writer.write(output_path)

                                    MessageHelper.show_message("PDF Generado con éxito", "information")

                            except Exception as error:
                                MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                                            + str(error), "critical")

# Function to create PDF with specific text in a position
    def new_content(self, dataframe, item_type, drawing):
        """
        Generates a PDF containing a new content based on the dataframe.

        Args:
            dataframe (df): Dataframe with the content to be added to the PDF.
            item_type (str): Value with the type of equipment
            drawing (str): Value with the drawing number

        Returns:
            io.BytesIO: A byte stream containing the generated PDF.
        """
        pdf = FPDF('landscape', unit='mm', format='A3')
        pdf.set_font("helvetica", "", 14)
        pdf.set_text_color(0, 0, 0)

        df_data = dataframe

        pdf.add_page()

        if item_type in ['F+P','P']:
            pdf.set_xy(44, 111)
            with pdf.rotation(270):
                pdf.cell(20, 5, str(df_data.shape[0]), align='C')

            pdf.set_xy(44, 240)
            with pdf.rotation(270):
                pdf.cell(50, 5, str(self.numorder), align='C')

            pdf.set_xy(30, 250)
            with pdf.rotation(270):
                pdf.cell(50, 5, str(re.search(r'\d{2}/\d{3}', self.numorder).group(0) + '-' + re.search(r'-(\d{2})/', drawing).group(1)), align='C')

            pdf.set_xy(20.5, 250)
            with pdf.rotation(270):
                pdf.cell(40, 5, str(drawing), align='C')

            y_position = 91.5
            x_position = 272
            df_data.loc[:, 'size'] = df_data['line_size'].astype(str) + ' ' + df_data['rating'].astype(str) + ' ' + df_data['facing'].astype(str) + '\nSCH ' + df_data['schedule'].astype(str)
            df_data = df_data.drop(columns=['line_size', 'rating', 'facing', 'schedule'])

            for row in df_data.itertuples():
                pdf.set_font("helvetica", "", 9)
                pdf.set_xy(x_position, y_position)
                with pdf.rotation(270):
                    pdf.cell(33, 5, str(getattr(row,'tag')), align='C')
                    pdf.cell(32.5, 5, str(getattr(row,'size')), align='C')
                    pdf.cell(20, 5, str(getattr(row,'internal_diameter')), align='C')
                    pdf.cell(33, 5, str(getattr(row,'element_material')), align='C')
                    pdf.cell(21, 5, str(getattr(row,'orif_diam')), align='C')
                    pdf.cell(19, 5, str(getattr(row,'plate_thk')), align='C')
                    pdf.cell(21, 5, str(getattr(row,'dv_diam')), align='C')

                x_position -= 7

        elif item_type == 'RO':
            pdf.set_xy(43, 111)
            with pdf.rotation(270):
                pdf.cell(20, 5, str(df_data.shape[0]), align='C')

            pdf.set_xy(43, 240)
            with pdf.rotation(270):
                pdf.cell(50, 5, str(self.numorder), align='C')

            pdf.set_xy(30, 250)
            with pdf.rotation(270):
                pdf.cell(40, 5, str(re.search(r'\d{2}/\d{3}', self.numorder).group(0) + '-' + re.search(r'-(\d{2})/', drawing).group(1)), align='C')

            pdf.set_xy(20.5, 250)
            with pdf.rotation(270):
                pdf.cell(40, 5, str(drawing), align='C')

            y_position = 111
            x_position = 275
            df_data.loc[:, 'size'] = df_data['line_size'].astype(str) + ' ' + df_data['rating'].astype(str) + ' ' + df_data['facing'].astype(str) + '\nSCH ' + df_data['schedule'].astype(str)
            df_data = df_data.drop(columns=['line_size', 'rating', 'facing', 'schedule'])

            for row in df_data.itertuples():
                pdf.set_font("helvetica", "", 9)
                pdf.set_xy(x_position, y_position)
                with pdf.rotation(270):
                    pdf.cell(30, 5, str(getattr(row,'tag')), align='C')
                    pdf.cell(33, 5, str(getattr(row,'size')), align='C')
                    pdf.cell(33, 5, str(getattr(row,'element_material')), align='C')
                    pdf.cell(15.5, 5, str(getattr(row,'internal_diameter')), align='C')
                    pdf.cell(16, 5, str(getattr(row,'orif_diam')), align='C')
                    pdf.cell(15, 5, str(getattr(row,'plate_thk')), align='C')

                x_position -= 8

        return io.BytesIO(pdf.output())


# Function to open drawing generator selector
    def generate_drawings(self):
        self.numorder = self.Numorder_EditTags.text()

        if self.numorder=="":
            MessageHelper.show_message('Inserta el número de pedido', "warning")

        else:
            if not re.match(r'^(P|PA)-\d{2}/\d{3}.*$', self.numorder):
                MessageHelper.show_message("El número de pedido debe tener formato P-XX/YYY o PA-XX/YYY", "warning")

            else:
                query = ('''
                        SELECT num_order, product_type."variable", offers."client", offers."final_client", offers."project", num_ref_order
                        FROM orders
                        INNER JOIN offers ON (offers."num_offer" = orders."num_offer")
                        INNER JOIN product_type ON (product_type."material" = offers."material")
                        WHERE
                        UPPER (orders."num_order") LIKE UPPER('%%'||%s||'%%')
                        ''')

                try:
                    with Database_Connection(config_database()) as conn:
                        with conn.cursor() as cur:
                            cur.execute(query,(self.numorder,))
                            results_variable=cur.fetchone()
                            self.client = results_variable[2]
                            self.final_client = results_variable[3]
                            self.project = results_variable[4]
                            self.num_po = results_variable[5]

                except (Exception, psycopg2.DatabaseError) as error:
                    MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                                + str(error), "critical")

                if results_variable == None:
                    MessageHelper.show_message("El número de pedido no existe", "warning")

                else:
                    while True:
                        action, ok = QtWidgets.QInputDialog.getItem(None, "Generar Planos", "Elige el tipo de plano:",
                                                                    ['Dimensional', 'OF', 'M'], 0, False)
                        if ok and action:
                            while True:
                                if action == 'Dimensional':
                                    self.generate_dim_drawings(self.client, self.final_client, self.project, self.num_po)
                                    break
                                elif action == 'OF':
                                    self.generate_of_drawings()
                                    break
                                elif action == 'M':
                                    self.generate_m_drawings()
                                    break
                            break
                        else:
                            break

    def generate_dim_drawings(self, client, final_client, project, num_po):
        order_year = str(datetime.now().year)[:2] + self.numorder[self.numorder.rfind("/") - 2:self.numorder.rfind("/")]

        if self.numorder[:2] == 'PA':
            path = ORDERS_PATH / f"Año {order_year}" / f"{order_year} Pedidos Almacen"
            for folder in os.listdir(path):
                if self.numorder.replace("/", "-") in folder:
                    output_path_Dim = path / folder / "3-Fabricacion" / "Planos Dimensionales"
        else:
            path = ORDERS_PATH / f"Año {order_year}" / f"{order_year} Pedidos"
            for folder in sorted(os.listdir(path)):
                if 'S00' in self.numorder:
                    if self.numorder[:8].replace("/", "-") in folder:
                        output_path_Dim = path / folder / "3-Fabricacion" / "Planos Dimensionales"
                        break
                else:
                    if self.numorder.replace("/", "-") in folder:
                        output_path_Dim = path / folder / "3-Fabricacion" / "Planos Dimensionales"
                        break

        if not os.path.exists(output_path_Dim):
            os.makedirs(output_path_Dim)

        try:
            query_select_drawings = ("""
                SELECT * FROM (
                    SELECT id_tag_flow, dim_drawing, 'tags_data.tags_flow' as table, 'id_tag_flow' as id_column, tag
                    FROM tags_data.tags_flow
                    WHERE num_order ILIKE %s and tag_state = 'PURCHASED'
                    ORDER BY tag) t_flow

                UNION ALL

                SELECT * FROM (
                    SELECT id_tag_temp, dim_drawing, 'tags_data.tags_temp' as table, 'id_tag_temp' as id_column, tag
                FROM tags_data.tags_temp
                WHERE num_order ILIKE %s and tag_state = 'PURCHASED'
                ORDER BY tag) t_temp

                UNION ALL

                SELECT * FROM (
                    SELECT id_tag_level, dim_drawing, 'tags_data.tags_level' as table, 'id_tag_level' as id_column, tag
                FROM tags_data.tags_level
                WHERE num_order ILIKE %s and tag_state = 'PURCHASED'
                ORDER BY tag) t_level

                UNION ALL

                SELECT * FROM (
                    SELECT id_tag_others, dim_drawing, 'tags_data.tags_others' as table, 'id_tag_others' as id_column, tag
                FROM tags_data.tags_others
                WHERE num_order ILIKE %s and tag_state = 'PURCHASED'
                ORDER BY tag) t_others
                """)

            query_update = sql.SQL("UPDATE {table} SET dim_drawing = %s WHERE {id_column} = %s")

            query_tags_flow = ("SELECT * FROM tags_data.tags_flow WHERE num_order ILIKE %s and tag_state = 'PURCHASED'")

            try:
                with Database_Connection(config_database()) as conn:
                    with conn.cursor() as cur:
                        cur.execute(query_select_drawings,(f"%{self.numorder}%", f"%{self.numorder}%", f"%{self.numorder}%", f"%{self.numorder}%",))
                        results_tags_drawings=cur.fetchall()
                        df_final = pd.DataFrame(results_tags_drawings, columns=["id", "dim_drawing", "table", "id_column", "tag"])

            except (Exception, psycopg2.DatabaseError) as error:
                MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                            + str(error), "critical")

            mask_new = df_final["dim_drawing"].isna() | (df_final["dim_drawing"] == "")

            last_drawing = (df_final.loc[~mask_new, "dim_drawing"].str.split("-", expand=False).str[-1].astype(int).max())
            if pd.isna(last_drawing):
                last_drawing = 0

            start = last_drawing + 1
            qty_new = mask_new.sum()
            total = len(df_final)
            num_width = len(str(total))

            # df_final.loc[mask_new, "dim_drawing"] = [f"{i:0{num_width}d}/{total}" for i in range(start, start + qty_new)]

            df_final.loc[mask_new, "dim_drawing"] = [self.numorder[2:].replace("/", "-") + "-" + f"{i:0{num_width}d}" for i in range(start, start + qty_new)]

            try:
                with Database_Connection(config_database()) as conn:
                    with conn.cursor() as cur:
                        for table_name in df_final["table"].dropna().unique():
                            rows = df_final[df_final["table"] == table_name]

                            schema, table = table_name.split(".")
                            
                            query = query_update.format(
                                table=sql.Identifier(schema, table),
                                id_column=sql.Identifier(rows.iloc[0]["id_column"])
                            )

                            data = [
                                (row["dim_drawing"], row["id"])
                                for _, row in rows.iterrows()
                            ]

                            execute_batch(cur, query, data, page_size=100)
                    conn.commit()
            except (Exception, psycopg2.DatabaseError) as error:
                MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                            + str(error), "critical")

        # Loop through different types of equipment and create drawings accordingly
            for table_name in df_final["table"].unique():
                if table_name == 'tags_data.tags_flow':
                    try:
                        with Database_Connection(config_database()) as conn:
                            with conn.cursor() as cur:
                                cur.execute(query_tags_flow,(f"%{self.numorder}%",))
                                results_tags_flow=cur.fetchall()

                    except (Exception, psycopg2.DatabaseError) as error:
                        MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                                    + str(error), "critical")

                    columns = ["id_tag_flow", "tag", "tag_state", "num_offer", "num_order", "num_po", "position", "subposition",
                    "item_type", "line_size", "rating", "facing", "schedule", "flange_material", "flange_type", "tube_material", "tapping_size",
                    "tapping_number", "tapping_orientation", "element_material", "plate_type", "plate_thk", "plate_std", "gasket_material", "bolts_material",
                    "nuts_material", "valve_conn", "valve_material_body", "stages_number", "pipe_spec", "aprox_weight", "aprox_length", "nace", "amount", "offer_notes",
                    "commercial_changes", "contractual_date", "orif_diam", "dv_diam", "gasket_quantity", "bolts_size", "bolts_quantity", "plug_material", "plug_quantity",
                    "jack_screw_material", "jack_screw_size", "jack_screw_quantity", "rtj_porta_material", "rtj_thickness", "rtj_r_type",
                    "notes_flange", "notes_stud", "notes_nut", "notes_plate", "notes_gasket", "notes_plugs", "notes_jack_screw",
                    "pipe_int_diam", "plate_ext_diam",
                    "plate_c_dim", "handle_height", "handle_width", "handle_thickness", "rtj_p_diam", "rtj_e_dim", "rtj_f_dim", "o_flange", "a_flange", "c_flange", "y_flange",
                    "x_flange", "r_flange", "d_flange", "t_flange", "bore_bolts_diam", "cones_material", "a_venturi", "d_venturi", "e_venturi", "f_venturi", "g_venturi",
                    "c_venturi", "h_venturi", "t_venturi", "technical_changes", "technical_notes", "notes_equipment", "calc_num_doc_eipsa", "dwg_num_doc_eipsa", "purchase_order",
                    "purchase_order_date", "purchase_order_notes", "dim_drawing", "dim_drawing_rev", "dim_drawing_date", "of_drawing", "of_drawing_rev", "of_drawing_date",
                    "heat_number_plate", "cert_plate", "heat_number_flange", "cert_flange", "pmi_date", "ph1_date", "ph1_manometer", "ph1_pressure", "ph1_state", "ph1_obs",
                    "ph2_date", "ph2_manometer", "ph2_pressure", "ph2_state", "ph2_obs", "lp_date", "lp_hn_liq1", "lp_hn_liq2", "lp_hn_liq3", "lp_state", "lp_obs", "hard_date",
                    "hard_hardness", "hard_hardness_hb", "hard_ball", "hard_force", "hard_hn", "hard_state", "hard_obs", "final_verif_dim_date", "final_verif_dim_state",
                    "final_verif_dim_obs", "final_verif_of_eq_date", "final_verif_of_eq_state", "final_verif_of_eq_obs", "tag_images", "tag_images2", "fab_state", "inspection",
                    "irc_date", "rn_delivery", "rn_date", "pos_fact", "subpos_fact", "amount_fact", "diff_amount", "box_br", "box_pl", "description_fact", "notes_fact",
                    "invoice_number", "percent_invoiced", "dim_drawing_path", "of_drawing_path", "order_type_tag", "code_equipment", "code_fab_equipment", "translate_equipment",
                    "code_orifice_flange", "code_line_flange", "code_gasket", "code_bolts", "code_plugs", "code_extractor", "code_plate", "code_nipple", "code_handle",
                    "code_chring", "code_tube", "code_wedge", "code_fab_orifice_flange", "code_fab_line_flange", "code_fab_gasket", "code_fab_bolts", "code_fab_plugs",
                    "code_fab_extractor", "code_fab_plate", "code_fab_nipple", "code_fab_handle", "code_fab_chring", "code_fab_tube", "code_fab_wedge", "quant_orifice_flange",
                    "quant_line_flange", "quant_gasket", "quant_bolts", "quant_plugs", "quant_extractor", "quant_plate", "quant_nipple", "quant_handle", "quant_chring",
                    "quant_tube", "quant_wedge", "trad_orifice_flange", "trad_line_flange", "trad_gasket", "trad_bolts", "trad_plugs", "trad_extractor", "trad_plate", "trad_nipple",
                    "trad_handle", "trad_chring", "trad_tube", "trad_wedge"]

                    df_flow = pd.DataFrame(results_tags_flow, columns=columns)

                    df_flow['dim_drawing_date'] = pd.to_datetime(df_flow['dim_drawing_date']).dt.strftime('%d/%m/%Y').fillna('')

                    for _, row in df_flow.iterrows():
                        writer = PdfWriter()

                        drawing_path = row["dim_drawing_path"]
                        if os.path.exists(drawing_path):
                            with open(drawing_path, 'rb') as f:
                                # reader = PdfReader(f)
                                reader = PdfReader(drawing_path)
                                base_page = reader.pages[0]

                                if row["item_type"] == "F+P":
                                    pdf_buffer = dwg_dim_flange_plate(self.numorder, row["tag"],
                                                                row["line_size"], row["schedule"], row["rating"], row["facing"],
                                                                row["pipe_int_diam"], row["orif_diam"], row["plate_thk"], row["dv_diam"], row["nace"], row['tapping_size'],
                                                                row["o_flange"], row["a_flange"], row["c_flange"], row["y_flange"], row["x_flange"], row["r_flange"], row["d_flange"], row["t_flange"], row["bolts_quantity"], row["bore_bolts_diam"],
                                                                row["handle_height"], row["handle_width"], row["plate_c_dim"], row["plate_ext_diam"],
                                                                row["rtj_thickness"], row["rtj_r_type"], row["rtj_p_diam"], row["rtj_e_dim"], row["rtj_f_dim"],
                                                                client, final_client, project, row["num_po"],
                                                                row["flange_material"], row["bolts_material"], row["nuts_material"], row["element_material"], row["gasket_material"], row["plug_quantity"], row["plug_material"], row["jack_screw_material"],
                                                                row["notes_flange"], row["notes_stud"], row["notes_nut"], row["notes_plate"], row["notes_gasket"], row["notes_plugs"], row["notes_jack_screw"],
                                                                row["dim_drawing"][-2:], row["dim_drawing_date"], total)

                                elif row["item_type"] == "P":
                                    pdf_buffer = dwg_dim_plate(self.numorder, row["tag"],
                                                                row["line_size"], row["schedule"], row["rating"], row["facing"],
                                                                row["pipe_int_diam"], row["orif_diam"], row["plate_thk"], row["dv_diam"], row["nace"], row["element_material"],
                                                                row["handle_height"], row["handle_width"], row["plate_c_dim"], row["plate_ext_diam"],
                                                                row["rtj_thickness"], row["rtj_r_type"], row["rtj_p_diam"], row["rtj_e_dim"], row["rtj_f_dim"],
                                                                client, final_client, project, row["num_po"],
                                                                row["dim_drawing"][-2:], row["dim_drawing_date"], total)

                                elif row["item_type"] == "RO":
                                    pdf_buffer = dwg_dim_ro(self.numorder, row["tag"],
                                                                row["line_size"], row["schedule"], row["rating"], row["facing"], row["element_material"],
                                                                row["pipe_int_diam"], row["orif_diam"], row["plate_thk"], row["nace"],
                                                                row["handle_height"], row["handle_width"], row["plate_ext_diam"],
                                                                row["rtj_thickness"], row["rtj_r_type"], row["rtj_p_diam"], row["rtj_e_dim"], row["rtj_f_dim"],
                                                                client, final_client, project, row["num_po"],
                                                                row["dim_drawing"][-2:], row["dim_drawing_date"], total)

                                elif row["item_type"] == "MULTISTAGE RO":
                                    pdf_buffer = dwg_dim_ms_ro(self.numorder, row["tag"],
                                                                row["line_size"], row["schedule"], row["rating"], row["facing"],
                                                                row["flange_material"], row["tube_material"], row["element_material"],
                                                                row["pipe_int_diam"], row["nace"],
                                                                row["stages_number"], row["aprox_length"],
                                                                row["rtj_thickness"], row["rtj_r_type"], row["rtj_p_diam"], row["rtj_e_dim"], row["rtj_f_dim"],
                                                                client, final_client, project, row["num_po"],
                                                                row["dim_drawing"][-2:], row["dim_drawing_date"], total)

                                elif row["item_type"] == "M.RUN":
                                    pdf_buffer = dwg_dim_mrun(self.numorder, row["tag"],
                                                                row["line_size"], row["schedule"], row["rating"], row["facing"],
                                                                row["pipe_int_diam"], row["orif_diam"], row["nace"], row['tapping_size'],
                                                                row["handle_height"], row["handle_width"], row["plate_c_dim"], row["plate_ext_diam"],
                                                                row["rtj_thickness"], row["rtj_r_type"], row["rtj_p_diam"], row["rtj_e_dim"], row["rtj_f_dim"],
                                                                client, final_client, project, row["num_po"],
                                                                row["flange_material"], row["bolts_material"], row["nuts_material"], row["element_material"], row["gasket_material"], row["plug_quantity"], row["plug_material"], row["jack_screw_material"],
                                                                row["notes_flange"], row["notes_stud"], row["notes_nut"], row["notes_plate"], row["notes_gasket"], row["notes_plugs"], row["notes_jack_screw"],
                                                                row["dim_drawing"][-2:], row["dim_drawing_date"], total)

                                page_overlay = PdfReader(pdf_buffer).pages[0]
                                
                                base_page.merge_page(page2=page_overlay)
                                writer.add_page(base_page)

                                writer.write(str(output_path_Dim / f'{row["dim_drawing"]}.pdf'))

            MessageHelper.show_message("Planos Generados", "info")
        except (Exception, psycopg2.DatabaseError) as error:
            print(error)
            MessageHelper.show_message("Ha ocurrido un error:\n"
                        "Los planos no se han podido generar", "critical")

    def generate_of_drawings(self):
        order_year = str(datetime.now().year)[:2] + self.numorder[self.numorder.rfind("/") - 2:self.numorder.rfind("/")]

        if self.numorder[:2] == 'PA':
            path = ORDERS_PATH / f"Año {order_year}" / f"{order_year} Pedidos Almacen"
            for folder in os.listdir(path):
                if self.numorder.replace("/", "-") in folder:
                    output_path_OF = path / folder / "3-Fabricacion" / "Planos OF"
        else:
            path = ORDERS_PATH / f"Año {order_year}" / f"{order_year} Pedidos"
            for folder in sorted(os.listdir(path)):
                if 'S00' in self.numorder:
                    if self.numorder[:8].replace("/", "-") in folder:
                        output_path_OF = path / folder / "3-Fabricacion" / "Planos OF"
                        break
                else:
                    if self.numorder.replace("/", "-") in folder:
                        output_path_OF = path / folder / "3-Fabricacion" / "Planos OF"
                        break

        if not os.path.exists(output_path_OF):
            os.makedirs(output_path_OF)

        try:
            query_select_drawings = ("""
                SELECT * FROM (
                    SELECT id_tag_flow, item_type, line_size, rating, facing, element_material, of_drawing, 'tags_data.tags_flow' as table, 'id_tag_flow' as id_column, tag
                    FROM tags_data.tags_flow
                    WHERE num_order ILIKE %s and tag_state = 'PURCHASED'
                    ORDER BY tag) t_flow
                    """)

            query_update = sql.SQL("UPDATE {table} SET of_drawing = %s WHERE {id_column} = %s")

            query_tags_flow = ("SELECT * FROM tags_data.tags_flow WHERE num_order ILIKE %s and tag_state = 'PURCHASED'")

            try:
                with Database_Connection(config_database()) as conn:
                    with conn.cursor() as cur:
                        cur.execute(query_select_drawings,(f"%{self.numorder}%",))
                        results_tags_drawings=cur.fetchall()
                        df_final = pd.DataFrame(results_tags_drawings, columns=["id", "item_type", "line_size", "rating", "facing", "element_material", "of_drawing", "table", "id_column", "tag"])
                        total = len(df_final)

            except (Exception, psycopg2.DatabaseError) as error:
                MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                            + str(error), "critical")

            GROUP_COLS_BY_TABLE = {
                'tags_data.tags_flow':   ["item_type", "line_size", "rating", "facing", "element_material"],
                }
            
            mask_new = df_final["of_drawing"].isna() | (df_final["of_drawing"] == "")

            if mask_new.any():
                last_drawing = (df_final.loc[~mask_new, "of_drawing"].str.split("/", expand=False).str.split("-", expand=False).str[-1].astype(int).max())

                if pd.isna(last_drawing):
                    last_drawing = 0

                current = last_drawing + 1

                for table_name, group_cols in GROUP_COLS_BY_TABLE.items():
                    df_table = df_final[df_final["table"] == table_name]

                    if df_table.empty:
                        continue

                    mask_new_table = (
                        df_table["of_drawing"].isna() | (df_table["of_drawing"] == "")
                    )

                    if not mask_new_table.any():
                        continue

                    df_groups = (
                        df_table[mask_new_table]
                        .drop_duplicates(subset=group_cols)
                        .sort_values(group_cols)
                    )

                    for _, grp in df_groups.iterrows():

                        drawing = f"OF-{current:02d}"
                        current += 1

                        mask_group = (
                            (df_final["table"] == table_name) &
                            df_final[group_cols].eq(grp[group_cols]).all(axis=1) &
                            mask_new
                        )

                        df_final.loc[mask_group, "of_drawing"] = drawing

                try:
                    with Database_Connection(config_database()) as conn:
                        with conn.cursor() as cur:
                            for table_name in df_final["table"].unique():
                                rows = df_final[
                                    (df_final["table"] == table_name) &
                                    (df_final["of_drawing"].notna())
                                ]

                                if rows.empty:
                                    continue

                                schema, table = table_name.split(".")
                                query = query_update.format(
                                    table=sql.Identifier(schema, table),
                                    id_column=sql.Identifier(rows.iloc[0]["id_column"])
                                )

                                data = [
                                    (row["of_drawing"], row["id"])
                                    for _, row in rows.iterrows()
                                ]

                                execute_batch(cur, query, data, page_size=100)
                        conn.commit()
                except (Exception, psycopg2.DatabaseError) as error:
                    MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                                + str(error), "critical")

        # Loop through different types of equipment and create drawings accordingly
            for table_name in df_final["table"].unique():
                if table_name == 'tags_data.tags_flow':
                    try:
                        with Database_Connection(config_database()) as conn:
                            with conn.cursor() as cur:
                                cur.execute(query_tags_flow,(f"%{self.numorder}%",))
                                results_tags_flow=cur.fetchall()

                    except (Exception, psycopg2.DatabaseError) as error:
                        MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                                    + str(error), "critical")

                    columns = ["id_tag_flow", "tag", "tag_state", "num_offer", "num_order", "num_po", "position", "subposition",
                    "item_type", "line_size", "rating", "facing", "schedule", "flange_material", "flange_type", "tube_material", "tapping_size",
                    "tapping_number", "tapping_orientation", "element_material", "plate_type", "plate_thk", "plate_std", "gasket_material", "bolts_material",
                    "nuts_material", "valve_conn", "valve_material_body", "stages_number", "pipe_spec", "aprox_weight", "aprox_length", "nace", "amount", "offer_notes",
                    "commercial_changes", "contractual_date", "orif_diam", "dv_diam", "gasket_quantity", "bolts_size", "bolts_quantity", "plug_material", "plug_quantity",
                    "jack_screw_material", "jack_screw_size", "jack_screw_quantity", "rtj_porta_material", "rtj_thickness", "rtj_r_type",
                    "notes_flange", "notes_stud", "notes_nut", "notes_plate", "notes_gasket", "notes_plugs", "notes_jack_screw",
                    "pipe_int_diam", "plate_ext_diam",
                    "plate_c_dim", "handle_height", "handle_width", "handle_thickness", "rtj_p_diam", "rtj_e_dim", "rtj_f_dim", "o_flange", "a_flange", "c_flange", "y_flange",
                    "x_flange", "r_flange", "d_flange", "t_flange", "bore_bolts_diam", "cones_material", "a_venturi", "d_venturi", "e_venturi", "f_venturi", "g_venturi",
                    "c_venturi", "h_venturi", "t_venturi", "technical_changes", "technical_notes", "notes_equipment", "calc_num_doc_eipsa", "dwg_num_doc_eipsa", "purchase_order",
                    "purchase_order_date", "purchase_order_notes", "dim_drawing", "dim_drawing_rev", "dim_drawing_date", "of_drawing", "of_drawing_rev", "of_drawing_date",
                    "heat_number_plate", "cert_plate", "heat_number_flange", "cert_flange", "pmi_date", "ph1_date", "ph1_manometer", "ph1_pressure", "ph1_state", "ph1_obs",
                    "ph2_date", "ph2_manometer", "ph2_pressure", "ph2_state", "ph2_obs", "lp_date", "lp_hn_liq1", "lp_hn_liq2", "lp_hn_liq3", "lp_state", "lp_obs", "hard_date",
                    "hard_hardness", "hard_hardness_hb", "hard_ball", "hard_force", "hard_hn", "hard_state", "hard_obs", "final_verif_dim_date", "final_verif_dim_state",
                    "final_verif_dim_obs", "final_verif_of_eq_date", "final_verif_of_eq_state", "final_verif_of_eq_obs", "tag_images", "tag_images2", "fab_state", "inspection",
                    "irc_date", "rn_delivery", "rn_date", "pos_fact", "subpos_fact", "amount_fact", "diff_amount", "box_br", "box_pl", "description_fact", "notes_fact",
                    "invoice_number", "percent_invoiced", "dim_drawing_path", "of_drawing_path", "order_type_tag", "code_equipment", "code_fab_equipment", "translate_equipment",
                    "code_orifice_flange", "code_line_flange", "code_gasket", "code_bolts", "code_plugs", "code_extractor", "code_plate", "code_nipple", "code_handle",
                    "code_chring", "code_tube", "code_wedge", "code_fab_orifice_flange", "code_fab_line_flange", "code_fab_gasket", "code_fab_bolts", "code_fab_plugs",
                    "code_fab_extractor", "code_fab_plate", "code_fab_nipple", "code_fab_handle", "code_fab_chring", "code_fab_tube", "code_fab_wedge", "quant_orifice_flange",
                    "quant_line_flange", "quant_gasket", "quant_bolts", "quant_plugs", "quant_extractor", "quant_plate", "quant_nipple", "quant_handle", "quant_chring",
                    "quant_tube", "quant_wedge", "trad_orifice_flange", "trad_line_flange", "trad_gasket", "trad_bolts", "trad_plugs", "trad_extractor", "trad_plate", "trad_nipple",
                    "trad_handle", "trad_chring", "trad_tube", "trad_wedge"]

                    df_flow = pd.DataFrame(results_tags_flow, columns=columns)

                    df_flow['of_drawing_date'] = pd.to_datetime(df_flow['of_drawing_date']).dt.strftime('%d/%m/%Y').fillna('')

                    count_of_drawings = len(df_flow['of_drawing'].unique().tolist())

                    for item_type in df_flow["item_type"].unique():
                        if item_type in ['F+P', 'P', 'RO', 'M.RUN']:
                            df_selected = df_flow.iloc[:, [0, 1, 8, 9, 10, 11, 12, 13, 19, 21, 32, 37, 38, 57, 58, 59, 60, 61, 95, 97, 151]].copy()

                            df_selected = df_selected[df_selected['item_type'] == item_type].copy()

                            df_selected.rename(columns={
                                0: 'id', 1: 'tag', 8: 'type', 9: 'line_size', 10: 'rating',
                                11: 'facing', 12: 'schedule', 13: 'material', 19:'element_material', 21: 'plate_thk',
                                32: 'nace', 37: 'orif_diam', 38: 'dv_diam', 57: 'pipe_int_diam', 58: 'plate_ext_diam',
                                59: 'plate_c_dim', 60: 'handle_height', 61: 'handle_width', 95: 'of_drawing', 97: 'of_drawing_date', 151: 'of_drawing_path'
                            }, inplace=True)

                            grouped_plates = self.create_df_orifice_plates(df_selected)

                            for _, row in grouped_plates.iterrows():
                                writer = PdfWriter()

                                drawing_path = row["of_drawing_path"]
                                if os.path.exists(drawing_path):
                                    with open(drawing_path, 'rb') as f:
                                        reader = PdfReader(f)
                                        base_page = reader.pages[0]

                                        if 'RF' in row['connection']:
                                            pdf_buffer = dwg_of_op_ro_rf(item_type, self.numorder, count_of_drawings, row["connection"], row["element_material"], row["of_drawing"], row["of_drawing_date"],
                                                                            row["handle_height"], row["handle_width"], row["plate_c_dim"], row["plate_ext_diam"],
                                                                            zip(row["tag"], row["line_size"], row["rating"], row["facing"], row["schedule"], row["element_material"], row["pipe_int_diam"],
                                                                            row["orif_diam"], row["plate_thk"], row["dv_diam"], row["w_diam"], row["nace"], row["count"]))

                                        page_overlay = PdfReader(pdf_buffer).pages[0]
                                        
                                        base_page.merge_page(page2=page_overlay)
                                        writer.add_page(base_page)

                                        writer.write(str(output_path_OF / f"{row["of_drawing"][:5]}.pdf"))

            MessageHelper.show_message("Planos Generados", "info")

            # self.query_drawings()

        except (Exception, psycopg2.DatabaseError) as error:
            print(error)
            MessageHelper.show_message("Ha ocurrido un error:\n"
                        "Los planos no se han podido generar", "critical")

    def generate_m_drawings(self):
        query_flow = ('''
            SELECT tags_data.tags_flow."num_order"
            FROM tags_data.tags_flow
            WHERE UPPER (tags_data.tags_flow."num_order") LIKE UPPER('%%'||%s||'%%')
            ''')

        query_temp = ('''
            SELECT tags_data.tags_temp."num_order"
            FROM tags_data.tags_temp
            WHERE UPPER (tags_data.tags_temp."num_order") LIKE UPPER('%%'||%s||'%%')
            ''')

        query_level = ('''
            SELECT tags_data.tags_level."num_order"
            FROM tags_data.tags_level
            WHERE UPPER (tags_data.tags_level."num_order") LIKE UPPER('%%'||%s||'%%')
            ''')

        query_others = ('''
            SELECT tags_data.tags_others."num_order"
            FROM tags_data.tags_others
            WHERE UPPER (tags_data.tags_others."num_order") LIKE UPPER('%%'||%s||'%%')
            ''')

        try:
            with Database_Connection(config_database()) as conn:
                with conn.cursor() as cur:
                    cur.execute(query_flow,(self.numorder,))
                    results_flow=cur.fetchall()
                    cur.execute(query_temp,(self.numorder,))
                    results_temp=cur.fetchall()
                    cur.execute(query_level,(self.numorder,))
                    results_level=cur.fetchall()
                    cur.execute(query_others,(self.numorder,))
                    results_others=cur.fetchall()

            if len(results_flow) != 0 and len(results_temp) != 0:
                self.variable = 'Caudal + Temperatura'
                self.table_toquery = "tags_data.tags_flow"
            elif len(results_flow) != 0:
                self.variable = 'Caudal'
                self.table_toquery = "tags_data.tags_flow"
            elif len(results_temp) != 0:
                self.variable = 'Temperatura'
                self.table_toquery = "tags_data.tags_temp"
            elif len(results_level) != 0:
                self.variable = 'Nivel'
                self.table_toquery = "tags_data.tags_level"
            elif len(results_others) != 0:
                self.variable = 'Otros'
                self.table_toquery = "tags_data.tags_others"
            else:
                self.variable = ''
                self.table_toquery = ""

        except (Exception, psycopg2.DatabaseError) as error:
            MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "critical")

        order_year = str(datetime.now().year)[:2] + self.numorder[self.numorder.rfind("/") - 2:self.numorder.rfind("/")]

        if self.numorder[:2] == 'PA':
            path = ORDERS_PATH / f"Año {order_year}" / f"{order_year} Pedidos Almacen"
            for folder in os.listdir(path):
                if self.numorder.replace("/", "-") in folder:
                    output_path_M = path / folder / "3-Fabricacion" / "Planos M"
        else:
            path = ORDERS_PATH / f"Año {order_year}" / f"{order_year} Pedidos"
            for folder in sorted(os.listdir(path)):
                if 'S00' in self.numorder:
                    if self.numorder[:8].replace("/", "-") in folder:
                        output_path_M = path / folder / "3-Fabricacion" / "Planos M"
                        break
                else:
                    if self.numorder.replace("/", "-") in folder:
                        output_path_M = path / folder / "3-Fabricacion" / "Planos M"
                        break

        if not os.path.exists(output_path_M):
            os.makedirs(output_path_M)

        commands_select_m_drawing = ("""
            SELECT drawing_number
            FROM verification."m_drawing_verification"
            WHERE "num_order" = %s
            ORDER BY drawing_number DESC
            """)

        try:
            with Database_Connection(config_database()) as conn:
                with conn.cursor() as cur:  
                    cur.execute(commands_select_m_drawing,(self.numorder,))
                    results_drawings_m=cur.fetchall()

        except (Exception, psycopg2.DatabaseError) as error:
            MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "critical")

        dict_drawings = {}
        counter_drawings = 0
        # if len(results_drawings_m) == 0:
        #     counter_drawings = 0
        # else:
        #     counter_drawings = int(results_drawings_m[0][0][-2:])

        try:
            # if self.table_toquery == "tags_data.tags_temp":
            # # Obtain the data from the database for temperature tags and create the correspondig dataframe with the necessary columns
            #     query = ('''
            #         SELECT *
            #         FROM tags_data.tags_temp
            #         WHERE UPPER (num_order) LIKE UPPER('%%'||%s||'%%') and tag_state = 'PURCHASED'
            #         ''')

            #     try:
            #         with Database_Connection(config_database()) as conn:
            #             with conn.cursor() as cur:
            #                 cur.execute(query,(self.numorder,))
            #                 results_tags=cur.fetchall()

            #         df_general = pd.DataFrame(results_tags)

            #     except (Exception, psycopg2.DatabaseError) as error:
            #         MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
            #                     + str(error), "critical")

            #     df_selected = df_general.iloc[:, [0, 9, 10, 11, 12, 13, 14, 15, 17, 43, 64]].copy()
            #     df_selected.rename(columns={
            #         0: 'id', 9: 'type', 10: 'size', 11: 'rating',
            #         12: 'facing', 13: 'std_tw', 14: 'material', 15: 'std_length', 17: 'root_diam',
            #         43: 'dim_tw', 64: 'notes_tw'
            #     }, inplace=True)

            # # Loop through different types of equipment and create drawings accordingly
            #     for item in df_selected['type'].unique().tolist():
            #         if item == 'Flanged TW':
            #             df_selected = df_selected[df_selected['type'] == 'Flanged TW'].copy()

            #             grouped_flanges = self.create_df_flanges_flanged_tw(df_selected)
            #             total_count = grouped_flanges['count'].explode().sum() 

            #             for _, row in grouped_flanges.iterrows():
            #                 counter_drawings += 1

            #                 writer = PdfWriter()

            #                 drawing_path = row["drawing_path"]
            #                 if os.path.exists(drawing_path):
            #                     reader = PdfReader(drawing_path)
            #                     page_overlay = PdfReader(flange_dwg_flangedTW(self.numorder, row["material"], row["count"][0])).pages[0]

            #                     if row["base_diam"] == 32:
            #                         reader.pages[0].merge_page(page2=page_overlay)
            #                         writer.add_page(reader.pages[0])
            #                     elif row["base_diam"] == 35:
            #                         reader.pages[1].merge_page(page2=page_overlay)
            #                         writer.add_page(reader.pages[1])
            #                     elif row["base_diam"] == 30:
            #                         reader.pages[2].merge_page(page2=page_overlay)
            #                         writer.add_page(reader.pages[2])
            #                     elif row["base_diam"] == 38:
            #                         reader.pages[3].merge_page(page2=page_overlay)
            #                         writer.add_page(reader.pages[3])

            #                     writer.write(str(output_path_M / f"M-{counter_drawings:02d}.pdf"))
            #                     dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", str(sum(row["count"])) + " BPC " + str(row["connection"]) + " " +str(row["material"]), str(sum(row["count"]))]
            #                 else:
            #                     dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", "FALTA PLANO // " + str(sum(row["count"])) + " BPC " + str(row["connection"]) + " " +str(row["material"]), str(sum(row["count"]))]

            #             grouped_bars = self.create_df_bars_flanged_tw(df_selected)
            #             total_count = grouped_bars['count'].explode().sum() 

            #             for _, row in grouped_bars.iterrows():
            #                 counter_drawings += 1

            #                 writer = PdfWriter()

            #                 drawing_path = row["drawing_path"]
            #                 if os.path.exists(drawing_path):
            #                     reader = PdfReader(drawing_path)
            #                     page_overlay = PdfReader(bar_dwg_flangedTW(self.numorder, row["material"], row["base_diam"], zip(row["bore_diameter"], row["std_length"], row["p_length"], row["count"]))).pages[0]

            #                     reader.pages[0].merge_page(page2=page_overlay)
            #                     writer.add_page(reader.pages[0])

            #                     writer.write(str(output_path_M / f"M-{counter_drawings:02d}.pdf"))
            #                     dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", str(sum(row["count"])) + " Vainas C+R Ø" + str(row["base_diam"]) + " " + str(row["material"]), str(sum(row["count"]))]
            #                 else:
            #                     dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", "FALTA PLANO // " + str(sum(row["count"])) + " Vainas C+R Ø" + str(row["base_diam"]) + " " + str(row["material"]), str(sum(row["count"]))]

            #         elif item in ['Buttweld TW', 'Socket TW']:
            #             df_selected = df_selected[df_selected['type'].isin(['Buttweld TW', 'Socket TW'])].copy()

            #             grouped_bars = self.create_df_not_flanged_tw(df_selected, item)
            #             total_count = grouped_bars['count'].explode().sum() 

            #             for _, row in grouped_bars.iterrows():
            #                 counter_drawings += 1

            #                 writer = PdfWriter()

            #                 drawing_path = row["drawing_path"]
            #                 if os.path.exists(drawing_path):
            #                     reader = PdfReader(drawing_path)
            #                     page_overlay = PdfReader(bar_dwg_notflangedTW(self.numorder, row["material"], row['base_diam'], zip(row["bore_diameter"], row["std_length"], row["p_length"], row["count"]))).pages[0]

            #                     reader.pages[0].merge_page(page2=page_overlay)
            #                     writer.add_page(reader.pages[0])

            #                     writer.write(str(output_path_M / f"M-{counter_drawings:02d}.pdf"))
            #                     dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", str(total_count) + " Vainas C+R Ø" + str(row["base_diam"]) + " " + str(row["material"]), total_count]
            #                 else:
            #                     dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", "FALTA PLANO // " + str(total_count) + " Vainas C+R Ø" + str(row["base_diam"]) + " " + str(row["material"]), total_count]

            # # Loop to add the drawing number and insert into the database
            #     for key, value in dict_drawings.items():
            #         if os.path.exists(key):
            #             writer = PdfWriter()
            #             reader = PdfReader(key)
            #             page_overlay = PdfReader(drawing_number(self.numorder, value, counter_drawings)).pages[0]
            #             reader.pages[0].merge_page(page2=page_overlay)
            #             writer.add_page(reader.pages[0])

            #             writer.write(key)

            #         query_insert_drawing = ("""
            #             INSERT INTO verification."m_drawing_verification" (num_order, drawing_number, drawing_description, printed_date, printed_state)
            #             VALUES (%s, %s, %s, %s, %s)
            #             """)

            #         try:
            #             with Database_Connection(config_database()) as conn:
            #                 with conn.cursor() as cur:
            #                     cur.execute(query_insert_drawing,(self.numorder,value[0][:4] + f"/{counter_drawings:02d}", value[1], str(datetime.today().strftime('%d/%m/%Y')), 'Realizado por Julio' if self.username == 'j.zofio' else 'Realizado por Jose Alberto'))
            #                 conn.commit()

            #         except (Exception, psycopg2.DatabaseError) as error:
            #             MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
            #                         + str(error), "critical")

            if self.table_toquery == "tags_data.tags_flow":
            # Obtain the data from the database for flow tags and create the correspondig dataframe with the necessary columns
                query = ('''
                    SELECT *
                    FROM tags_data.tags_flow
                    WHERE UPPER (num_order) LIKE UPPER('%%'||%s||'%%') and tag_state = 'PURCHASED'
                    ''')

                try:
                    with Database_Connection(config_database()) as conn:
                        with conn.cursor() as cur:
                            cur.execute(query,(self.numorder,))
                            results_tags=cur.fetchall()

                    df_general = pd.DataFrame(results_tags)

                except (Exception, psycopg2.DatabaseError) as error:
                    MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                                + str(error), "critical")

                df_selected = df_general.iloc[:, [0, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 23, 57, 86]].copy()
                df_selected.rename(columns={
                    0: 'id', 8: 'type', 9: 'size', 10: 'rating',
                    11: 'facing', 12: 'schedule', 13: 'material', 14:'flange_type',
                    15: 'tube_material', 16: 'tapping_size', 17: 'tapping_num', 18: 'tapping_orientation',
                    23: 'gasket', 86: 'notes_equipment', 57: 'pipe_int_diam'
                }, inplace=True)

            # Loop through different types of equipment and create drawings accordingly
                for item in df_selected['type'].unique().tolist():
                    if item in ['F+P', 'F']:
                        df_selected_fp = df_selected[df_selected['type'] == item].copy()

                        grouped_flanges = self.create_df_orifice_flanges(df_selected_fp)
                        total_count = grouped_flanges['count'].explode().sum() 

                        for _, row in grouped_flanges.iterrows():
                            counter_drawings += 1

                            writer = PdfWriter()

                            drawing_path = row["drawing_path"]
                            if os.path.exists(drawing_path):
                                with open(drawing_path, 'rb') as f:
                                    reader = PdfReader(f)
                                    base_page = reader.pages[0]

                                    pdf_buffer = flange_dwg_orifice(self.numorder, row["type"], row["material"], row["schedule"], row["tapping_size"], row["tapping_num"], row["tapping_orientation"], row["gasket"], row["flange_type"], zip(row["pipe_int_diam"], row["count"]))

                                    page_overlay = PdfReader(pdf_buffer).pages[0]
                                    
                                    base_page.merge_page(page2=page_overlay)
                                    writer.add_page(base_page)

                                    writer.write(str(output_path_M / f"M-{counter_drawings:02d}.pdf"))
                                    dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", str(2*sum(row['count'])) + "-BO" + str(row["flange_type"]) + " " + str(row["connection"]) + " SCH " + str(row["schedule"])  + " " + str(row["material"]) + " " + str(row["tapping_num"]) + " TOMAS + " + "2 EXTRACTORES", 2*sum(row['count'])]
                            else:
                                dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", "FALTA PLANO // " + str(2*sum(row['count'])) + "-BO" + str(row["flange_type"]) + " " + str(row["connection"]) + " SCH " + str(row["schedule"])  + " " + str(row["material"]) + " " + str(row["tapping_num"]) + " TOMAS + " + "2 EXTRACTORES", 2*sum(row['count'])]

                    # elif item == 'M.RUN':
                    #     df_selected_mrun = df_selected[df_selected['type'] == 'M.RUN'].copy()

                    #     df_selected_transformed = self.transform_df_mrun(df_selected_mrun)

                    #     grouped_orifice_flanges = self.create_df_orifice_flanges_mrun(df_selected_transformed)
                    #     total_count = grouped_orifice_flanges['count'].explode().sum()

                    #     for _, row in grouped_orifice_flanges.iterrows():
                    #         counter_drawings += 1

                    #         writer = PdfWriter()

                    #         drawing_path = row["drawing_path"]
                    #         if os.path.exists(drawing_path):
                    #             with open(drawing_path, 'rb') as f:
                    #                 reader = PdfReader(f)
                    #                 base_page = reader.pages[0]

                    #                 pdf_buffer = flange_dwg_orifice(self.numorder, row["type"], row["material"], row["schedule"], row["tapping"], row["gasket"], row["type_orifice_flange"], zip(row["final_pipe_int_diam"], row["orifice_flange_height"], row["count"]))

                    #                 page_overlay = PdfReader(pdf_buffer).pages[0]
                                    
                    #                 base_page.merge_page(page2=page_overlay)
                    #                 writer.add_page(base_page)

                    #                 writer.write(str(output_path_M / f"M-{counter_drawings:02d}.pdf"))
                    #                 dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", str(2*sum(row['count'])) + "-BO" + str(row["type_orifice_flange"]) + " " + str(row["connection"]) + " SCH " + str(row["schedule"])  + " " + str(row["material"]) + " " + str(row["tapping"][-2:-1]) + " TOMAS + " + "2 EXTRACTORES", 2*sum(row['count'])]
                    #         else:
                    #             dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", "FALTA PLANO // " + str(2*sum(row['count'])) + "-BO" + str(row["type_orifice_flange"]) + " " + str(row["connection"]) + " SCH " + str(row["schedule"])  + " " + str(row["material"]) + " " + str(row["tapping"][-2:-1]) + " TOMAS + " + "2 EXTRACTORES", 2*sum(row['count'])]

                    #     grouped_line_flanges = self.create_df_line_flanges_mrun(df_selected_transformed)
                    #     total_count = grouped_line_flanges['count'].explode().sum()

                    #     for _, row in grouped_line_flanges.iterrows():
                    #         counter_drawings += 1

                    #         writer = PdfWriter()

                    #         drawing_path = row["drawing_path"]
                    #         if os.path.exists(drawing_path):
                    #             with open(drawing_path, 'rb') as f:
                    #                 reader = PdfReader(f)
                    #                 base_page = reader.pages[0]

                    #                 pdf_buffer = flange_dwg_line(self.numorder, row["material"], row["schedule"], row["type_line_flange"], row["reduction"], row["connection"], zip(row["final_pipe_int_diam"], row["line_flange_height"], row["count"]))

                    #                 page_overlay = PdfReader(pdf_buffer).pages[0]
                                    
                    #                 base_page.merge_page(page2=page_overlay)
                    #                 writer.add_page(base_page)

                    #                 writer.write(str(output_path_M / f"M-{counter_drawings:02d}.pdf"))
                    #                 dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", str(2*sum(row['count'])) + "-BL" + str(row["type_line_flange"]) + " " + str(row["connection"]) + " SCH " + str(row["schedule"])  + " " + str(row["material"]), 2*sum(row['count'])]
                    #         else:
                    #             dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", "FALTA PLANO // " + str(2*sum(row['count'])) + "-BL" + str(row["type_line_flange"]) + " " + str(row["connection"]) + " SCH " + str(row["schedule"])  + " " + str(row["material"]), 2*sum(row['count'])]

                    #     grouped_tubes = self.create_df_tubes_mrun(df_selected_transformed)
                    #     total_count = grouped_tubes['count'].explode().sum()

                    #     for _, row in grouped_tubes.iterrows():
                    #         counter_drawings += 1

                    #         writer = PdfWriter()

                    #         drawing_path = row["drawing_path"]
                    #         if os.path.exists(drawing_path):
                    #             with open(drawing_path, 'rb') as f:
                    #                 reader = PdfReader(f)
                    #                 base_page = reader.pages[0]

                    #                 pdf_buffer = tube_dwg_meterrun(self.numorder, row["size_orifice_flange"], row["sch_orifice_flange"], row["tube_material"], row["calibrated"], zip(row["final_pipe_int_diam"], row["pipe_ext_diam"], row["length_long"], row["length_short"], row["welding_type_orifice"], row["welding_type_line"], row["count"]))

                    #                 page_overlay = PdfReader(pdf_buffer).pages[0]
                                    
                    #                 base_page.merge_page(page2=page_overlay)
                    #                 writer.add_page(base_page)

                    #                 writer.write(str(output_path_M / f"M-{counter_drawings:02d}.pdf"))
                    #                 dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", "CORTE TUBOS TRAMO " + str(row["size_orifice_flange"]) + " SCH " + str(row["sch_orifice_flange"])  + " " + str(row["tube_material"]), sum(row['count'])]
                    #         else:
                    #             dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", "FALTA PLANO // CORTE TUBOS TRAMO " + str(row["size_orifice_flange"]) + " SCH " + str(row["sch_orifice_flange"])  + " " + str(row["tube_material"]), sum(row['count'])]

                    #     grouped_welding = self.create_df_welding_mrun(df_selected_transformed)
                    #     total_count = grouped_welding['count'].explode().sum()

                    #     for _, row in grouped_welding.iterrows():
                    #         counter_drawings += 1

                    #         writer = PdfWriter()

                    #         drawing_path = row["drawing_path"]
                    #         if os.path.exists(drawing_path):
                    #             with open(drawing_path, 'rb') as f:
                    #                 reader = PdfReader(f)
                    #                 base_page = reader.pages[0]

                    #                 pdf_buffer = welding_dwg_meterrun(self.numorder, row["material"], row["flange_type"], zip(row["count"]))

                    #                 page_overlay = PdfReader(pdf_buffer).pages[0]

                    #                 if row["flange_type"] == 'WN':
                    #                     reader.pages[0].merge_page(page2=page_overlay)
                    #                     writer.add_page(reader.pages[0])
                    #                 elif row["flange_type"] == 'SW/WN':
                    #                     reader.pages[1].merge_page(page2=page_overlay)
                    #                     writer.add_page(reader.pages[1])
                    #                 elif row["flange_type"] == 'SO/WN':
                    #                     reader.pages[2].merge_page(page2=page_overlay)
                    #                     writer.add_page(reader.pages[2])
                    #                 elif row["flange_type"] == 'SO/WN':
                    #                     reader.pages[3].merge_page(page2=page_overlay)
                    #                     writer.add_page(reader.pages[3])
                    #                 elif row["flange_type"] == 'SW/SO':
                    #                     reader.pages[4].merge_page(page2=page_overlay)
                    #                     writer.add_page(reader.pages[4])
                    #                 elif row["flange_type"] == 'SO':
                    #                     reader.pages[5].merge_page(page2=page_overlay)
                    #                     writer.add_page(reader.pages[5])

                    #                 writer.write(str(output_path_M / f"M-{counter_drawings:02d}.pdf"))
                    #                 dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", "DETALLES SOLDADURA TIPO " + str(row["flange_type"]) + " " + str(row["material"]), sum(row['count'])]
                    #         else:
                    #             dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", "FALTA PLANO // DETALLES SOLDADURA TIPO " + str(row["flange_type"]) + " " + str(row["material"]), sum(row['count'])]

                    # else:
                    #     pass

            # Loop to add the drawing number and insert into the database
                for key, value in dict_drawings.items():
                    if os.path.exists(key):
                        writer = PdfWriter()
                        reader = PdfReader(key)
                        page_overlay = PdfReader(drawing_number_x(self.numorder, value, counter_drawings)).pages[0]
                        reader.pages[0].merge_page(page2=page_overlay)
                        writer.add_page(reader.pages[0])

                        writer.write(key)

                    # query_insert_drawing = ("""
                    #     INSERT INTO verification."m_drawing_verification" (num_order, drawing_number, drawing_description, printed_date, printed_state)
                    #     VALUES (%s, %s, %s, %s, %s)
                    #     """)

                    # try:
                    #     with Database_Connection(config_database()) as conn:
                    #         with conn.cursor() as cur:
                    #             cur.execute(query_insert_drawing,(self.numorder,value[0][:4] + f"/{counter_drawings:02d}", value[1], str(datetime.today().strftime('%d/%m/%Y')), 'Realizado por Julio' if self.username == 'j.zofio' else 'Realizado por Jose Alberto'))
                    #         conn.commit()

                    # except (Exception, psycopg2.DatabaseError) as error:
                    #     MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                    #                 + str(error), "critical")

            # elif self.table_toquery == "tags_data.tags_level":
            #     print('c')

            # elif self.table_toquery == "tags_data.tags_others":
            # # Obtain the data from the database for temperature tags and create the correspondig dataframe with the necessary columns
            #     query = ('''
            #         SELECT *
            #         FROM tags_data.tags_others
            #         WHERE UPPER (num_order) LIKE UPPER('%%'||%s||'%%') and tag_state = 'PURCHASED'
            #         ''')

            #     try:
            #         with Database_Connection(config_database()) as conn:
            #             with conn.cursor() as cur:
            #                 cur.execute(query,(self.numorder,))
            #                 results_tags=cur.fetchall()

            #         df_general = pd.DataFrame(results_tags)

            #     except (Exception, psycopg2.DatabaseError) as error:
            #         MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
            #                     + str(error), "critical")

            #     df_selected = df_general.iloc[:, [0, 8, 9, 15]].copy()
            #     df_selected.rename(columns={
            #         0: 'id', 8: 'description', 9: 'code_equipment', 15: 'dim_drawing'
            #     }, inplace=True)

            # # Loop through different types of equipment and create drawings accordingly
            #     for item in df_selected['description'].unique().tolist():
            #         if '2V260' in item:
            #             df_selected_final = df_selected[df_selected['description'].str.contains('2V260')].copy()

            #             df_grouped = df_selected_final.groupby(['description', 'dim_drawing']).size().reset_index(name="count")
            #             grouped_valves = df_grouped.groupby(['description', 'dim_drawing']).agg({"count": list}).reset_index()
            #             total_count = grouped_valves['count'].explode().sum()

            #             drawings_dict = {}

            #             for _, row in grouped_valves.iterrows():
            #                 material = 'A105' if row['description'].split('-')[1] == 'NB' else '316'
            #                 connection_1 = '3/4" NPT' if row['description'].split('-')[2] == '1N' else '1/2" NPT'
            #                 connection_2 = '3/4" NPT' if row['description'].split('-')[3] == '1N' else '1/2" NPT'
            #                 connection_3 = 'Flanged' if row['description'].split('-')[4] == 'F' else 'Welded'
            #                 vent_drain = 'Tapón purga' if row['description'].split('-')[5] == 'Q' else 'Tapón'
            #                 exterior_size = row['description'].split(' / ')[1]

            #                 if connection_3 == 'Flanged':
            #                     coded_connection = (('-0' + exterior_size.split(' ')[0].split('"')[0] if len(exterior_size.split(' ')[0]) == 2 else '-') + ('.5' if ' 1/2' in exterior_size.split(' ')[0] else ('0.75' if '3/4' in exterior_size.split(' ')[0] else '.0')) +
            #                                         ('-0' + str(exterior_size.split(' ')[1].split('#')[0]) if str(exterior_size.split(' ')[1].split('#')[0]) in ['150', '300', '600', '900'] else '-' + ' ' + str(exterior_size.split(' ')[2])))

            #                 if coded_connection in ['-0.75-0150', '-0.75-0300', '01-0150', '01-0300', '1.5-0150']:
            #                     drawing_path_1 = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\N-Nivel\V-Visuales\V-Valvulas\B-Bridas\B-220.260\D-Desbaste\NVVBBD-F Forja.pdf"
            #                 else:
            #                     drawing_path_1 = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\N-Nivel\V-Visuales\V-Valvulas\B-Bridas\B-220.260\D-Desbaste\NVVBBD-B-{coded_connection}.pdf"
            #                 drawing_path_2 = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\N-Nivel\V-Visuales\V-Valvulas\C-Conjuntos\F-Forja\B-220.260\N-260.70.80\X-Comunes\NVVCFBNX-1.0 DesbPCCuerpoVlvBrd.pdf"
            #                 drawing_path_3 = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\N-Nivel\V-Visuales\V-Valvulas\C-Conjuntos\F-Forja\B-220.260\N-260.70.80\X-Comunes\NVVCFBNX-1.1 MecCuerpoVlvBrd.pdf"
            #                 drawing_path_4 = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\N-Nivel\V-Visuales\V-Valvulas\B-Bridas\B-220.260\A-Acabado\{'RF-RaisedFace' if exterior_size.split(' ')[2] == 'RF' else 'RTJ-RingTypeJoint'}\NVVBBA{'RF' if exterior_size.split(' ')[2] == 'RF' else 'RTJ'}{coded_connection}.pdf"
            #                 if 'BP' in self.client:
            #                     drawing_path_5 = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\X-Comunes\TP-Tapones Purgadores\{'XTP-01.2 TaponPrg 0.50-AISI304L.pdf' if material == '316' else 'XTP-01.3 TaponPrg 0.50-A105 forjado.pdf'}"
            #                 else:
            #                     drawing_path_5 = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\X-Comunes\TP-Tapones Purgadores\{'XTP-01.2 TaponPrg 0.50-AISI304L.pdf' if material == '316' else 'XTP-01.4 TaponPrg 0.50-A105 de barra.pdf'}"
            #                 drawing_path_6 = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\X-Comunes\TP-Tapones Purgadores\XTP-02 TornilloTaponPrg.pdf"
                            
            #                 description_1 = 'Bridas de desgaste PC ' + exterior_size
            #                 description_2 = 'Cuerpos Válvula 2V260 ' + material
            #                 description_3 = 'Mecanizado conjunto brida-cuerpo ' + material
            #                 description_4 = 'Plano acabado brida ' + exterior_size + ' ' + material
            #                 description_5 = 'Tapones Purgadores ' + material
            #                 description_6 = 'Tornillos Purgadores 304'

            #                 drawings_dict.update({drawing_path_1: description_1,
            #                                     drawing_path_2: description_2,
            #                                     drawing_path_3: description_3,
            #                                     drawing_path_4: description_4,
            #                                     drawing_path_5: description_5,
            #                                     drawing_path_6: description_6})

            #                 if connection_3 == 'Flanged':
            #                     dim_drawing = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\N-Nivel\V-Visuales\V-Valvulas\C-Conjuntos\F-Forja\B-220.260\N-260.70.80\E-260 Estandar\NVVCFBNE-1 Cnj V-260 Brid.pdf"
            #                 else:
            #                     dim_drawing = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\N-Nivel\V-Visuales\V-Valvulas\C-Conjuntos\F-Forja\B-220.260\N-260.70.80\E-260 Estandar\NVVCFBNE-2 Cnj V-260 Boqt.pdf"
            #                 description_dim = str(total_count) + ' válvulas ' + item
            #                 dim_drawing_number = row['dim_drawing']

            #             # Write equipment data
            #                 writer = PdfWriter()
            #                 reader = PdfReader(dim_drawing)
            #                 page_overlay = PdfReader(loose_valves_dwg_dim(self.numorder, material, connection_1, connection_2, exterior_size, zip(row["count"]))).pages[0]
            #                 reader.pages[0].merge_page(page2=page_overlay)
            #                 writer.add_page(reader.pages[0])
            #                 writer.write(f"{output_path_M}DIM-{dim_drawing_number[:2]}.pdf")

            #             # Write Drawing data
            #                 writer = PdfWriter()
            #                 reader = PdfReader(f"{output_path_M}DIM-{dim_drawing_number[:2]}.pdf")
            #                 page_overlay = PdfReader(drawing_number(self.numorder, [dim_drawing_number[:2], description_dim, total_count], 1)).pages[0]
            #                 reader.pages[0].merge_page(page2=page_overlay)
            #                 writer.add_page(reader.pages[0])

            #                 writer.write(f"{output_path_M}DIM-{dim_drawing_number[:2]}.pdf")

            #                 query_update_drawing = ("""
            #                     UPDATE verification.workshop_dim_drawings 
            #                     SET drawing_description= %s, printed_date= %s, printed_state= %s
            #                     WHERE num_order = %s AND drawing_number = %s
            #                     """)

            #                 try:
            #                     with Database_Connection(config_database()) as conn:
            #                         with conn.cursor() as cur:
            #                             cur.execute(query_update_drawing,(description_dim, str(datetime.today().strftime('%d/%m/%Y')), 'Realizado por Julio' if self.username == 'j.zofio' else 'Realizado por Jose Alberto', self.numorder, '01/01'))
            #                         conn.commit()
            #                 except (Exception, psycopg2.DatabaseError) as error:
            #                     MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
            #                                 + str(error), "critical")

            #                 for drawing, description in drawings_dict.items():
            #                     counter_drawings += 1
            #                     with open(drawing, 'rb') as f:
            #                         writer = PdfWriter()
            #                         reader = PdfReader(f)
            #                         base_page = reader.pages[0]

            #                         if counter_drawings in [2, 3]:
            #                             pdf_buffer = dwg_m_landscape(self.numorder, zip(row["count"]), material)
            #                         elif counter_drawings in [1, 4, 5]:
            #                             pdf_buffer = general_dwg_m(self.numorder, zip(row["count"]))
            #                         else:
            #                             pdf_buffer = general_dwg_m(self.numorder, zip(row["count"]), '304')

            #                         page_overlay = PdfReader(pdf_buffer).pages[0]
                                    
            #                         base_page.merge_page(page2=page_overlay)
            #                         writer.add_page(base_page)

            #                         writer.write(str(output_path_M / f"M-{counter_drawings:02d}.pdf"))
            #                         dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", str(sum(row['count'])) + " " + description, sum(row['count'])]

            #         elif 'CN-32218-A1' in item:
            #             df_selected_final = df_selected[df_selected['description'].str.contains('CN-32218-A1')].copy()

            #             df_grouped = df_selected_final.groupby(['description', 'dim_drawing']).size().reset_index(name="count")
            #             grouped_equipment = df_grouped.groupby(['description', 'dim_drawing']).agg({"count": list}).reset_index()
            #             total_count = grouped_equipment['count'].explode().sum()

            #             dim_drawing = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\T-Temperatura\V-Vainas\M- Multiples\TU-Tipo Tubo\A-CN32218-A1\TVMTUA-0.0 Cnj CN-32218-A1.pdf"
            #             dim_description = str(total_count) + ' Vainas Múltiples Tubo 3" CN-32218'
            #             dim_drawing_number = grouped_equipment.iloc[0]['dim_drawing']

            #             dict_drawings_M = self.drawings_tw_32218(total_count)

            #         # Write equipment data
            #             writer = PdfWriter()
            #             reader = PdfReader(dim_drawing)
            #             page_overlay = PdfReader(dwg_dim_32218_32219(self.numorder, '321', zip(str(total_count)))).pages[0]

            #             base_page = reader.pages[0]

            #             base_page.merge_page(page2=page_overlay)
            #             writer.add_page(reader.pages[0])
            #             writer.write(str(output_path_Dim / f"{dim_drawing_number[:2]}.pdf"))

            #         # Write Drawing data
            #             writer = PdfWriter()
            #             reader = PdfReader(str(output_path_Dim / f"{dim_drawing_number[:2]}.pdf"))
            #             page_overlay = PdfReader(drawing_number_landscape(self.numorder, [dim_drawing_number[:2], dim_description, total_count], 1)).pages[0]
            #             reader.pages[0].merge_page(page2=page_overlay)
            #             writer.add_page(reader.pages[0])

            #             writer.write(str(output_path_Dim / f"{dim_drawing_number[:2]}.pdf"))

            #             query_update_drawing = ("""
            #                 UPDATE verification.workshop_dim_drawings 
            #                 SET printed_date= %s, printed_state= %s
            #                 WHERE num_order = %s AND drawing_number = %s
            #                 """)

            #             try:
            #                 with Database_Connection(config_database()) as conn:
            #                     with conn.cursor() as cur:
            #                         cur.execute(query_update_drawing,(str(datetime.today().strftime('%d/%m/%Y')), 'Realizado por Julio' if self.username == 'j.zofio' else 'Realizado por Jose Alberto', self.numorder, dim_drawing_number))
            #                     conn.commit()

            #             except (Exception, psycopg2.DatabaseError) as error:
            #                 MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
            #                             + str(error), "critical")

            #             for drawing, description in dict_drawings_M.items():
            #                 counter_drawings += 1
            #                 with open(drawing, 'rb') as f:
            #                     writer = PdfWriter()
            #                     reader = PdfReader(f)
            #                     base_page = reader.pages[0]

            #                     if counter_drawings == 1:
            #                         pdf_buffer = dwg_m_welding_32218_32219(self.numorder, '321', zip(str(total_count)))
            #                     else:
            #                         pdf_buffer = dwg_m_32218_32219(self.numorder, '321', zip(str(3*int(total_count)))) if any(code in drawing for code in ['TVMTUA-1.3', 'TVMTUX-3', 'TVMTUX-1']) else dwg_m_32218_32219(self.numorder, '321', zip(str(total_count)))

            #                     page_overlay = PdfReader(pdf_buffer).pages[0]
                                
            #                     base_page.merge_page(page2=page_overlay)
            #                     writer.add_page(base_page)

            #                     writer.write(str(output_path_M / f"M-{counter_drawings:02d}.pdf"))
            #                     dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", description, str(total_count)]

            #         elif 'CN-32219-A1' in item:
            #             df_selected_final = df_selected[df_selected['description'].str.contains('CN-32219-A1')].copy()

            #             df_grouped = df_selected_final.groupby(['description', 'dim_drawing']).size().reset_index(name="count")
            #             grouped_equipment = df_grouped.groupby(['description', 'dim_drawing']).agg({"count": list}).reset_index()
            #             total_count = grouped_equipment['count'].explode().sum()

            #             dim_drawing = rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\T-Temperatura\V-Vainas\M- Multiples\TU-Tipo Tubo\B-CN32219-A1\TVMTUB-0.0 Cnj CN-32219-A1.pdf"
            #             dim_description = str(total_count) + ' Vainas Múltiples Tubo 3"'
            #             dim_drawing_number = grouped_equipment.iloc[0]['dim_drawing']

            #             dict_drawings_M = self.drawings_tw_32219(total_count)

            #         # Write equipment data
            #             writer = PdfWriter()
            #             reader = PdfReader(dim_drawing)
            #             page_overlay = PdfReader(dwg_dim_32218_32219(self.numorder, '321', zip(str(total_count)))).pages[0]

            #             base_page = reader.pages[0]

            #             base_page.merge_page(page2=page_overlay)
            #             writer.add_page(reader.pages[0])
            #             writer.write(str(output_path_Dim / f"{dim_drawing_number[:2]}.pdf"))

            #         # Write Drawing data
            #             writer = PdfWriter()
            #             reader = PdfReader(str(output_path_Dim / f"{dim_drawing_number[:2]}.pdf"))
            #             page_overlay = PdfReader(drawing_number_landscape(self.numorder, [dim_drawing_number[:2], dim_description, total_count], 1)).pages[0]
            #             reader.pages[0].merge_page(page2=page_overlay)
            #             writer.add_page(reader.pages[0])

            #             writer.write(str(output_path_Dim / f"{dim_drawing_number[:2]}.pdf"))

            #             query_update_drawing = ("""
            #                 UPDATE verification.workshop_dim_drawings 
            #                 SET printed_date= %s, printed_state= %s
            #                 WHERE num_order = %s AND drawing_number = %s
            #                 """)

            #             try:
            #                 with Database_Connection(config_database()) as conn:
            #                     with conn.cursor() as cur:
            #                         cur.execute(query_update_drawing,(str(datetime.today().strftime('%d/%m/%Y')), 'Realizado por Julio' if self.username == 'j.zofio' else 'Realizado por Jose Alberto', self.numorder, dim_drawing_number))
            #                     conn.commit()

            #             except (Exception, psycopg2.DatabaseError) as error:
            #                 MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
            #                             + str(error), "critical")

            #             for drawing, description in dict_drawings_M.items():
            #                 counter_drawings += 1
            #                 with open(drawing, 'rb') as f:
            #                     writer = PdfWriter()
            #                     reader = PdfReader(f)
            #                     base_page = reader.pages[0]

            #                     if counter_drawings == 1:
            #                         pdf_buffer = dwg_m_welding_32218_32219(self.numorder, '321', zip(str(total_count)))
            #                     else:
            #                         pdf_buffer = dwg_m_32218_32219(self.numorder, '321', zip(str(3*int(total_count)))) if any(code in drawing for code in ['TVMTUB-1.3', 'TVMTUX-3', 'TVMTUX-1']) else dwg_m_32218_32219(self.numorder, '321', zip(str(total_count)))

            #                     page_overlay = PdfReader(pdf_buffer).pages[0]
                                
            #                     base_page.merge_page(page2=page_overlay)
            #                     writer.add_page(base_page)

            #                     writer.write(str(output_path_M / f"M-{counter_drawings:02d}.pdf"))
            #                     dict_drawings[str(output_path_M / f"M-{counter_drawings:02d}.pdf")] = [f"M-{counter_drawings:02d}.pdf", description, str(total_count)]

            # # Loop to add the drawing number and insert into the database
            #     for key, value in dict_drawings.items():
            #         if os.path.exists(key):
            #             writer = PdfWriter()
            #             reader = PdfReader(key)
            #             if any(term in value[1] for term in ['2V260', 'conjunto brida-cuerpo', 'Mapa Soldaduras']):
            #                 page_overlay = PdfReader(drawing_number_landscape(self.numorder, value, counter_drawings)).pages[0]
            #             else:
            #                 page_overlay = PdfReader(drawing_number(self.numorder, value, counter_drawings)).pages[0]
            #             reader.pages[0].merge_page(page2=page_overlay)
            #             writer.add_page(reader.pages[0])

            #             writer.write(key)

            #         query_insert_drawing = ("""
            #             INSERT INTO verification."m_drawing_verification" (num_order, drawing_number, drawing_description, printed_date, printed_state)
            #             VALUES (%s, %s, %s, %s, %s)
            #             """)

            #         try:
            #             with Database_Connection(config_database()) as conn:
            #                 with conn.cursor() as cur:
            #                     cur.execute(query_insert_drawing,(self.numorder,value[0][:4] + f"/{counter_drawings:02d}", value[1], str(datetime.today().strftime('%d/%m/%Y')), 'Realizado por Julio' if self.username == 'j.zofio' else 'Realizado por Jose Alberto'))
            #                 conn.commit()

            #         except (Exception, psycopg2.DatabaseError) as error:
            #             MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
            #                         + str(error), "critical")

            MessageHelper.show_message("Planos Generados", "info")

        except (Exception, psycopg2.DatabaseError) as error:
            print(error)
            MessageHelper.show_message("Ha ocurrido un error:\n"
                        "Los planos no se han podido generar", "critical")

    def create_df_orifice_flanges(self, dataframe):
        df_flanges = dataframe.copy()

        df_flanges.loc[df_flanges['gasket'].str.contains('SPW', na=False), 'gasket'] = 'SPW'
        df_flanges.loc[df_flanges['gasket'].str.contains('Flat', na=False), 'gasket'] = 'Flat'
        df_flanges.loc[df_flanges['gasket'].str.contains('RTJ', na=False), 'gasket'] = 'RTJ'

        df_flanges['drawing_code'] = df_flanges.apply(
        lambda row: 'CBWNO' + str(row['facing']) + ('TH' if str(row['flange_type']) == 'TH' else ('SW' if str(row['flange_type']) == 'SW' else '')) +
                    ('-0' if len(str(row['size'])) == 2 else '-') + str(row['size']).split('"')[0] + ('.5' if ' 1/2' in str(row['size']) else '.0') +
                    ('-0' + str(row['rating']) if str(row['rating']) in ['150', '300', '600', '900'] else '-' + str(row['rating'])) + ('-SA' if int(row['size'].split('"')[0])> 24 else ''),
        axis=1)

        df_flanges['connection'] = df_flanges.apply(
        lambda row: str(row['size']) + " " + str(row['rating']) + "#" + str(row['facing']),
        axis=1)

        df_flanges['drawing_path'] = df_flanges.apply(
        lambda row: rf"""\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\C-Caudal\B-Bridas\WN-WeldNeck\O-Orificio\{'RF-RaisedFace' if str(row['facing']) == 'RF' else ('FF-FlatFace' if str(row['facing']) == 'FF' else 'RTJ-RingTypeJoint')}\{'' if str(row['flange_type']) in ['WN','16.47-A'] else ('TH-Roscadas' if str(row['flange_type']) == 'TH' else 'SW-SocketWeld')}\{str(row['drawing_code'])}.pdf""",
        axis=1)

        df_grouped = df_flanges.groupby(['drawing_path', 'connection', 'type', 'schedule', 'material', 'tapping_size', 'tapping_num', 'tapping_orientation','gasket', 'flange_type', 'pipe_int_diam']).size().reset_index(name="count")
        grouped_flanges = df_grouped.groupby(['drawing_path', 'connection','type','schedule','material','tapping_size', 'tapping_num', 'tapping_orientation', 'gasket', 'flange_type']).agg({"pipe_int_diam": list, "count": list}).reset_index()

        return grouped_flanges

    def create_df_orifice_plates(self, dataframe):
        df_plates = dataframe.copy()
        df_plates = df_plates.fillna('')

        df_plates['connection'] = df_plates.apply(
        lambda row: row['line_size'] + " " + row['rating'] + "# " + row['facing'],
        axis=1)

        df_plates['w_diam'] = df_plates.apply(
        lambda row: str(0.5 + float(row['dv_diam'].split('=')[1].replace(',','.')) / 2) if str(row['dv_diam']) not in ('None', '', 'N/A') else '',
        axis=1)

        df_grouped = df_plates.groupby(['of_drawing_path', 'connection', 'of_drawing', 'of_drawing_date', 'plate_ext_diam', 'plate_c_dim', 'handle_height', 'handle_width',
        'tag', 'line_size', 'rating', 'facing', 'schedule', 'element_material',
        'pipe_int_diam', 'orif_diam', 'plate_thk', 'dv_diam', 'w_diam', 'nace'],dropna=False).size().reset_index(name="count")

        grouped_plates = df_grouped.groupby(['of_drawing_path', 'connection', 'of_drawing', 'of_drawing_date', 'plate_ext_diam', 'plate_c_dim', 'handle_height', 'handle_width']).agg(
            {"tag": list, "line_size": list, "rating": list, "facing": list, "schedule": list, "element_material": list, "pipe_int_diam": list,
            "orif_diam": list, "plate_thk": list, "dv_diam": list, "w_diam": list, "nace": list, "count": list}
            ).reset_index()

        return grouped_plates



    def calculate_tw_base_diam(row, is_repsol, is_cepsa_group):
        root = float(str(row['root_diam']).replace(",", "."))
        tip = float(str(row['tip_diam']).replace(",", "."))

        if is_repsol:
            if root < 33:
                return 35
            elif root < tip + 3:
                return min(STANDARD_TW_DIAMS, key=lambda x: abs(x - (tip + 3)))
            return min(STANDARD_TW_DIAMS, key=lambda x: abs(x - (root)))

        if is_cepsa_group:
            if root < 32:
                return 32
            elif root < tip + 3:
                return min(STANDARD_TW_DIAMS, key=lambda x: abs(x - (tip + 3)))
            return min(STANDARD_TW_DIAMS, key=lambda x: abs(x - (root)))

        if root < 30:
            return 30
        if root < 32:
            return 32
        if root < 35:
            return 35
        return 38

# Functions to create dataframes for items drawings
    def create_df_flanges_flanged_tw(self, dataframe):
        dataframe['drawing_code'] = dataframe.apply(
        lambda row: 'TBPC' + ('RF' if str(row['facing']) == 'FF' else str(row['facing'])) +
                    '-0' + str(row['size'])[0] + ('.5' if '1/2' in str(row['size']) else '.0') +
                    ('-0' + str(row['rating']) if str(row['rating']) in ['150', '300', '600', '900'] else '-' + str(row['rating'])),
        axis=1)

        dataframe['connection'] = dataframe.apply(
        lambda row: str(row['size']) + " " + str(row['rating']) + "#" + str(row['facing']),
        axis=1)
        
        dataframe['drawing_path'] = dataframe.apply(
        lambda row: rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\T-Temperatura\B-Bridas\PC-Penetracion Completa\{'RTJ-RingTypeJoint'if str(row['facing']) == 'RTJ' else 'RF-RaisedFace'}\{str(row['drawing_code'])}.pdf",
        axis=1)

        client_upper = ' '.join(c.upper() for c in [self.client, self.final_client] if c)

        is_repsol = 'REPSOL' in client_upper

        is_cepsa_group = (any(term in client_upper for term in ['CEPSA', 'MOEVE', 'BP OIL ESPAÑA'])
                            or dataframe['std_tw'].str.upper().str.contains('CEPSA').any())

        dataframe['base_diam'] = dataframe.apply(self.calculate_tw_base_diam, axis=1, args=(is_repsol, is_cepsa_group))

        dataframe = dataframe[~dataframe['notes_tw'].str.contains('FORJADA', case=False, na=False)].copy()
        df_grouped = dataframe.groupby(['drawing_path','connection','base_diam','material']).size().reset_index(name='count')
        grouped_flanges = df_grouped.groupby(['drawing_path','connection','base_diam','material']).agg({"count": list}).reset_index()

        return grouped_flanges

    def create_df_bars_flanged_tw(self, dataframe):
        dataframe['bore_diameter'] = dataframe.apply(lambda row: row['dim_tw'].split('//')[0].strip(),axis=1)

        client_upper = ' '.join(c.upper() for c in [self.client, self.final_client] if c)

        is_repsol = 'REPSOL' in client_upper

        is_cepsa_group = (any(term in client_upper for term in ['CEPSA', 'MOEVE', 'BP OIL ESPAÑA'])
                            or dataframe['std_tw'].str.upper().str.contains('CEPSA').any())

        dataframe['base_diam'] = dataframe.apply(self.calculate_tw_base_diam, axis=1, args=(is_repsol, is_cepsa_group))

        # For thermowell with base below 35 mm, p_lenght is 3 mm shorter
        dataframe['p_length'] = dataframe.apply(lambda row: int(row['std_length']) - float(row['dim_tw'].split('//')[1].strip()) - 3,axis=1)

        dataframe['drawing_code'] = dataframe.apply(
        lambda row: 'TVSCP-Ø' + str(int(row['base_diam'])) + ' Corte-Taladro',
        axis=1)

        dataframe['drawing_path'] = dataframe.apply(
        lambda row: rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\T-Temperatura\V-Vainas\S-Soldadas\C-Cilindricas\P-Preparación\{str(row['drawing_code'])}.pdf",
        axis=1)

        dataframe = dataframe[~dataframe['notes_tw'].str.contains('FORJADA', case=False, na=False)].copy()
        df_grouped = dataframe.groupby(["drawing_path",'base_diam','material', "bore_diameter", "std_length","p_length"]).size().reset_index(name="count")
        grouped_bars = df_grouped.groupby(['drawing_path','base_diam','material']).agg({"bore_diameter":list, "std_length": list, "p_length": list, "count": list}).reset_index()

        return grouped_bars

    def create_df_not_flanged_tw(self, dataframe, item):
        dataframe['bore_diameter'] = dataframe.apply(lambda row: row['dim_tw'].split('//')[0].strip(),axis=1)

        map_repsol = {
            '3/4"': 35,
            '1"': 35,
            '1-1/4"': 45,
            '1-1/2"': 50
        }
        map_default = {
            '3/4"': 30,
            '1"': 35,
            '1-1/4"': 45,
            '1-1/2"': 50
        }

        if any('REPSOL' in c.upper() for c in [self.client, self.final_client]):
            dataframe['base_diam'] = dataframe['size'].map(map_repsol).fillna(65)
        else:
            dataframe['base_diam'] = dataframe['size'].map(map_default).fillna(65)

        # For thermowell with base below 35 mm, p_lenght is 3 mm shorter
        dataframe['p_length'] = dataframe.apply(lambda row: int(row['std_length']) - float(row['dim_tw'].split('//')[1].strip()) - 1,axis=1)

        dataframe['drawing_code'] = dataframe.apply(
        lambda row: 'TVSCP-Ø' + str(row['base_diam']) + ' Corte-Taladro' if float(row['base_diam']) <= 40 else 'TVSCP-ØSuperiores Corte-Taladro',
        axis=1)

        dataframe['drawing_path'] = dataframe.apply(
        lambda row: rf"\\ERP-EIPSA-DATOS\Comunes\TALLER\Taller24\T-Temperatura\V-Vainas\S-Soldadas\C-Cilindricas\P-Preparación\{str(row['drawing_code'])}.pdf",
        axis=1)

        dataframe = dataframe[~dataframe['notes_tw'].str.contains('FORJADA', case=False, na=False)].copy()
        df_grouped = dataframe.groupby(["drawing_path",'base_diam','material', "bore_diameter", "std_length", "p_length"]).size().reset_index(name="count")
        grouped_bars = df_grouped.groupby(['drawing_path','base_diam','material']).agg({"bore_diameter":list, "std_length": list, "p_length": list, "count": list}).reset_index()

        return grouped_bars





if __name__ == "__main__":
    import sys
    import os

    ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    if ROOT not in sys.path:
        sys.path.insert(0, ROOT)
    app = QtWidgets.QApplication(sys.argv)
    dbparam = config_database()
    user_database = dbparam["user"]
    password_database = dbparam["password"]

    db = Create_DBconnection(user_database, password_database)
    if not db:
        sys.exit()

    EditTagsTechnical_Window = Ui_EditTags_Technical_Window('j.martinez',db)
    EditTagsTechnical_Window.show()
    sys.exit(app.exec())




    # try:
    #     writer = PdfWriter()
    #     with open(r'M:\Comunes\EIPSA-ERP\4 PLANOS AUTOMATICOS\DIMENSIONALES\F+P\RF\2 TOMAS\BIDIRECCIONAL\F+P-RF-2-8 bidireccional sin dibujo placa.pdf', 'rb') as f:
    #         reader = PdfReader(f)
    #         base_page = reader.pages[0]

    #         page_overlay = PdfReader(r'M:\Comunes\EIPSA-ERP\4 PLANOS AUTOMATICOS\DIMENSIONALES\F+P\RF\2 TOMAS\BIDIRECCIONAL\F+P-RF-2-8 bidireccional corte 2.pdf').pages[0]
            
    #         base_page.merge_page(page2=page_overlay)
    #         writer.add_page(base_page)

    #         writer.write("M:/Comunes/EIPSA-ERP/4 PLANOS AUTOMATICOS/DIMENSIONALES/F+P/RF/2 TOMAS/BIDIRECCIONAL/output.pdf")
    # except Exception as e:
    #     print(e)