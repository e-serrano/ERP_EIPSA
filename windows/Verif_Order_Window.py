# Form implementation generated from reading ui file 'Verif_Order_Window.ui'
#
# Created by: PySide6 UI code generator 6.4.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PySide6 import QtCore, QtGui, QtWidgets
from config.config_functions import config_database, get_path
import psycopg2
import os
from datetime import *
import locale
import fnmatch
from utils.Database_Manager import Database_Connection
from utils.Show_Message import MessageHelper


def imagen_to_base64(imagen):
    """
    Converts an image in PNG format to a base64 encoded string.

    Args:
        imagen: An instance of QImage or QPixmap to be converted.
    Return:
        A base64 encoded string representing the image in PNG format.
    """
    buffer = QtCore.QBuffer()
    buffer.open(QtCore.QIODevice.OpenModeFlag.WriteOnly)
    imagen.save(buffer, ".png")
    base64_data = buffer.data().toBase64().data().decode()
    return base64_data

class AlignDelegate(QtWidgets.QStyledItemDelegate):
    """
    A custom item delegate for aligning cell content in a QTableView or QTableWidget to the center.

    Inherits from:
        QtWidgets.QStyledItemDelegate: Provides custom rendering and editing for table items.

    """
    def initStyleOption(self, option, index):
        """
        Initializes the style option for the item, setting its display alignment to center.

        Args:
            option (QtWidgets.QStyleOptionViewItem): The style option to initialize.
            index (QtCore.QModelIndex): The model index of the item.
        """
        super(AlignDelegate, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

    def paint(self, painter, option, index):
        """
        Custom paint method to render the cell content and apply background colors
        based on specific conditions for a column's value.

        Args:
            painter (QPainter): The painter used to render the cell.
            option (QStyleOptionViewItem): The style options for the cell.
            index (QModelIndex): The index of the cell being painted.
        """
        super().paint(painter, option, index)

        if index.column() == 1:  # Column to paint
            state_column_index = index.sibling(index.row(), 3) # Index for column to check text
            value_check = str(state_column_index.data()).upper() # Text for checking
            painter.setPen(QtGui.QColor("black"))

            if 'AVISADO' in value_check:
                start_color = QtGui.QColor(25, 200, 100)  # Yellow
                end_color = QtGui.QColor(25, 200, 100)  # Yellow

                rect_top = option.rect.adjusted(0, 0, 0, -option.rect.height() // 2)
                rect_bottom = option.rect.adjusted(0, option.rect.height() // 2, 0, 0)

                painter.fillRect(rect_top, start_color)
                painter.fillRect(rect_bottom, end_color)

                textRect = painter.boundingRect(option.rect.adjusted(0, 0, 0, -option.rect.height() // 2), QtCore.Qt.TextFlag.TextDontClip | QtCore.Qt.AlignmentFlag.AlignCenter, 'EXP',)
                verticalPosition = int(option.rect.adjusted(0, 0, 0, -option.rect.height() // 2).y() + (option.rect.adjusted(0, 0, 0, -option.rect.height() // 2).height() + textRect.height() + 8) / 2)
                horizontalPosition = int(option.rect.adjusted(0, 0, 0, -option.rect.height() // 2).x() + (option.rect.adjusted(0, 0, 0, -option.rect.height() // 2).width() - textRect.width()) / 2)
                painter.drawText(horizontalPosition, verticalPosition, 'EXP')

class CustomTableWidget_Tags(QtWidgets.QTableWidget):
    """
    Custom QTableWidget that supports filtering and sorting features.

    Attributes:
        list_filters (list): Stores filters applied to the table.
        column_filters (dict): Maps column indices to sets of applied filters.
        column_actions (dict): Maps column indices to actions related to columns.
        checkbox_states (dict): Stores the state of checkboxes for filtering.
        rows_hidden (dict): Maps column indices to sets of hidden row indices.
        general_rows_to_hide (set): Set of row indices that are hidden across the table.
    """
    def __init__(self, parent=None):
        """
        Initializes the CustomTableWidget.

        Sets up the initial state of the widget, including filters, checkbox states,
        and hidden rows.

        Args:
            parent (QWidget, optional): The parent widget of this table. Defaults to None.
        """
        super().__init__(parent)
        self.list_filters=[]
        self.column_filters = {}
        self.column_actions = {}
        self.checkbox_states = {}
        self.rows_hidden = {}
        self.general_rows_to_hide = set()

# Function to show the menu
    def show_unique_values_menu(self, column_index, header_pos, header_height):
        """
        Displays a context menu for unique values in a specified column.

        The menu includes options to remove filters, sort the column, and filter by text.
        It also allows the user to select/unselect unique values via checkboxes.

        Args:
            column_index (int): The index of the column for which the menu is displayed.
            header_pos (QPoint): The position of the header in the viewport.
            header_height (int): The height of the header.
        """
        menu = QtWidgets.QMenu(self)
        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro")
        actionDeleteFilterColumn.triggered.connect(lambda: self.delete_filter(column_index))
        menu.addAction(actionDeleteFilterColumn)
        menu.addSeparator()
        actionOrderAsc = menu.addAction("Ordenar Ascendente")
        actionOrderAsc.triggered.connect(lambda: self.sort_column(column_index, QtCore.Qt.SortOrder.AscendingOrder))
        actionOrderDesc = menu.addAction("Ordenar Descendente")
        actionOrderDesc.triggered.connect(lambda: self.sort_column(column_index, QtCore.Qt.SortOrder.DescendingOrder))
        menu.addSeparator()
        actionFilterByText = menu.addAction("Buscar Texto")
        actionFilterByText.triggered.connect(lambda: self.filter_by_text(column_index))
        menu.addSeparator()

        menu.setStyleSheet("QMenu::item:selected { background-color: #33bdef; }"
                        "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

        if column_index not in self.column_filters:
            self.column_filters[column_index] = set()

        scroll_menu = QtWidgets.QScrollArea()
        scroll_menu.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget(scroll_menu)
        scroll_menu.setWidget(scroll_widget)
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        checkboxes = []

        select_all_checkbox = QtWidgets.QCheckBox("Seleccionar todo")
        if column_index in self.checkbox_states:
            select_all_checkbox.setCheckState(QtCore.Qt.CheckState(self.checkbox_states[column_index].get("Seleccionar todo", QtCore.Qt.CheckState(2))))
        else:
            select_all_checkbox.setCheckState(QtCore.Qt.CheckState(2))
        scroll_layout.addWidget(select_all_checkbox)
        checkboxes.append(select_all_checkbox)

        unique_values = self.get_unique_values(column_index)
        filtered_values = self.get_filtered_values()

        for value in sorted(unique_values):
            checkbox = QtWidgets.QCheckBox(value)
            if select_all_checkbox.isChecked():
                checkbox.setCheckState(QtCore.Qt.CheckState(2))
            else:
                if column_index in self.checkbox_states and value in self.checkbox_states[column_index]:
                    checkbox.setCheckState(QtCore.Qt.CheckState(self.checkbox_states[column_index][value]))
                elif filtered_values is None or value in filtered_values[column_index]:
                    checkbox.setCheckState(QtCore.Qt.CheckState(2))
                else:
                    checkbox.setCheckState(QtCore.Qt.CheckState(0))
            scroll_layout.addWidget(checkbox)
            checkboxes.append(checkbox)

        select_all_checkbox.stateChanged.connect(lambda state: self.set_all_checkboxes_state(checkboxes, state, column_index))

        for value, checkbox in zip(sorted(unique_values), checkboxes[1:]):
            checkbox.stateChanged.connect(lambda checked, value=value, checkbox=checkbox: self.apply_filter(column_index, value, checked))

    # Action for drop down menu and adding scroll area as widget
        action_scroll_menu = QtWidgets.QWidgetAction(menu)
        action_scroll_menu.setDefaultWidget(scroll_menu)
        menu.addAction(action_scroll_menu)

        menu.exec(header_pos - QtCore.QPoint(0, header_height))


# Function to delete filter on selected column
    def delete_filter(self,column_index):
        """
        Removes the filter applied to the specified column.

        Unhides previously hidden rows and resets the checkbox state for the column.

        Args:
            column_index (int): The index of the column from which to delete the filter.
        """
        if column_index in self.column_filters:
            del self.column_filters[column_index]
        if column_index in self.checkbox_states:
            del self.checkbox_states[column_index]
        if column_index in self.rows_hidden:
            for item in self.rows_hidden[column_index]:
                self.setRowHidden(item, False)
                if item in self.general_rows_to_hide:
                    self.general_rows_to_hide.remove(item)
            del self.rows_hidden[column_index]
        header_item = self.horizontalHeaderItem(column_index)
        header_item.setIcon(QtGui.QIcon())


# Function to set all checkboxes state
    def set_all_checkboxes_state(self, checkboxes, state, column_index):
        """
        Sets the state of all checkboxes in the filter menu for a specific column.

        Args:
            checkboxes (list): List of checkboxes to update.
            state (Qt.CheckState): The desired state for the checkboxes.
            column_index (int): The index of the column for which the checkboxes are set.
        """
        if column_index not in self.checkbox_states:
            self.checkbox_states[column_index] = {}

        for checkbox in checkboxes:
            checkbox.setCheckState(QtCore.Qt.CheckState(state))

        self.checkbox_states[column_index]["Seleccionar todo"] = state


# Function to apply filters to table
    def apply_filter(self, column_index, value, checked, text_filter=None, filter_dialog=None):
        """
        Applies a filter to the specified column based on the checkbox state and optional text filter.

        Args:
            column_index (int): The index of the column to filter.
            value (str): The value to filter by.
            checked (bool): Indicates if the filter should be applied (True) or removed (False).
            text_filter (str, optional): Additional text filter for filtering items. Defaults to None.
            filter_dialog (QDialog, optional): The dialog used for the text filter. Defaults to None.
        """
        if column_index not in self.column_filters:
            self.column_filters[column_index] = set()

        if text_filter is None:
            if value is None:
                self.column_filters[column_index] = set()
            elif checked:
                self.column_filters[column_index].add(value)
            elif value in self.column_filters[column_index]:
                self.column_filters[column_index].remove(value)

        rows_to_hide = set()
        for row in range(self.rowCount()):
            show_row = True

            # Check filters for all columns
            for col, filters in self.column_filters.items():
                item = self.item(row, col)
                if item:
                    item_value = item.text()
                    if text_filter is None:
                        if filters and item_value not in filters:
                            show_row = False
                            break

        # Filtering by text
            if text_filter is not None:
                filter_dialog.accept()
                item = self.item(row, column_index)
                if item:
                    if text_filter.upper() in item.text().upper():
                        self.column_filters[column_index].add(item.text())
                    else:
                        show_row = False

            if not show_row:
                if row not in self.general_rows_to_hide:
                    self.general_rows_to_hide.add(row)
                    rows_to_hide.add(row)
            else:
                if row in self.general_rows_to_hide:
                    self.general_rows_to_hide.remove(row)

        # Update hidden rows for this column depending on checkboxes
        if checked and text_filter is None:
            if column_index not in self.rows_hidden:
                self.rows_hidden[column_index] = set(rows_to_hide)
            else:
                self.rows_hidden[column_index].update(rows_to_hide)

        # Update hidden rows for this column depending on filtered text
        if text_filter is not None and value is None:
            if column_index not in self.rows_hidden:
                self.rows_hidden[column_index] = set(rows_to_hide)
            else:
                self.rows_hidden[column_index].update(rows_to_hide)

        # Iterate over all rows to hide them as necessary
        for row in range(self.rowCount()):
            self.setRowHidden(row, row in self.general_rows_to_hide)

        header_item = self.horizontalHeaderItem(column_index)
        if len(self.general_rows_to_hide) > 0:
            header_item.setIcon(QtGui.QIcon(str(get_path("Resources", "Iconos", "Filter_Active.png"))))
        else:
            header_item.setIcon(QtGui.QIcon())

# Function to apply filters to table based on a desired text
    def filter_by_text(self, column_index):
        """
        Opens a dialog for filtering the specified column by text input.

        Args:
            column_index (int): The index of the column to filter.
        """
        filter_dialog = QtWidgets.QDialog(self)
        filter_dialog.setWindowTitle("Filtrar por texto")

        label = QtWidgets.QLabel("Texto a filtrar:")
        text_input = QtWidgets.QLineEdit()

        filter_button = QtWidgets.QPushButton("Filtrar")
        filter_button.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 2px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        filter_button.clicked.connect(lambda: self.apply_filter(column_index, None, False, text_input.text(), filter_dialog))

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(label)
        layout.addWidget(text_input)
        layout.addWidget(filter_button)

        filter_dialog.setLayout(layout)
        filter_dialog.exec()


# Function to obtain the unique matching applied filters
    def get_unique_values(self, column_index):
        """
        Retrieves unique values from the specified column, taking into account any active filters on other columns.

        Args:
            column_index (int): The index of the column from which to retrieve unique values.

        Returns:
            set: A set of unique values from the specified column that are visible based on the current filters.
        """
        unique_values = set()
        for row in range(self.rowCount()):
            show_row = True
            for col, filters in self.column_filters.items():
                if col != column_index:
                    item = self.item(row, col)
                    if item:
                        item_value = item.text()
                        if filters and item_value not in filters:
                            show_row = False
                            break
            if show_row:
                item = self.item(row, column_index)
                if item:
                    unique_values.add(item.text())
        return unique_values

# Function to get values filtered by all columns
    def get_filtered_values(self):
        """
        Gets the current filter values for all columns.

        Returns:
            dict: A dictionary where each key is a column index and the value is a set of filters applied to that column.
        """
        filtered_values = {}
        for col, filters in self.column_filters.items():
            filtered_values[col] = filters
        return filtered_values

# Function to sort column
    def sort_column(self, column_index, sortOrder):
        """
        Sorts the specified column based on the given order. If the column is a date column, a custom sort method is used.

        Args:
            column_index (int): The index of the column to sort.
            sortOrder (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        if column_index in [6, 11]:
            self.custom_sort_date(column_index, sortOrder)
        elif self.horizontalHeaderItem(column_index).text() == 'Cantidad':
            self.custom_sort_int(column_index, sortOrder)
        else:
            self.sortByColumn(column_index, sortOrder)


    def custom_sort_date(self, column, order):
        """
        Custom sorting method for date columns. Sorts the specified column based on date values.

        Args:
            column (int): The index of the column to sort.
            order (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        row_count = self.rowCount()

        indexes = list(range(row_count))
        indexes.sort(key=lambda i: QtCore.QDateTime.fromString(self.item(i, column).text(), "dd-MM-yyyy"))

        if order == QtCore.Qt.SortOrder.DescendingOrder:
            indexes.reverse()

        hidden_rows = [row for row in range(row_count) if self.isRowHidden(row)]

        rows = self.rowCount()
        for i in range(rows):
            self.insertRow(i)

        for new_row, old_row in enumerate(indexes):
            for col in range(self.columnCount()):
                item = self.takeItem(old_row + rows, col)
                self.setItem(new_row, col, item)

        for i in range(rows):
            self.removeRow(rows)

        for row in hidden_rows:
            self.setRowHidden(row, True)

    def custom_sort_int(self, column, order):
        """
        Custom sorting method for integer columns. Sorts the specified column based on integer values.

        Args:
            column (int): The index of the column to sort.
            order (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        row_count = self.rowCount()

        indexes = list(range(row_count))
        indexes.sort(key=lambda i: int(self.item(i, column).text()))

        if order == QtCore.Qt.SortOrder.DescendingOrder:
            indexes.reverse()

        hidden_rows = [row for row in range(row_count) if self.isRowHidden(row)]

        rows = self.rowCount()
        for i in range(rows):
            self.insertRow(i)

        for new_row, old_row in enumerate(indexes):
            for col in range(self.columnCount()):
                item = self.takeItem(old_row + rows, col)
                self.setItem(new_row, col, item)

        for i in range(rows):
            self.removeRow(rows)

        for row in hidden_rows:
            self.setRowHidden(row, True)

# Function with the menu configuration
    def contextMenuEvent(self, event):
        """
        Handles the context menu event for the table. Shows a menu for filtering unique values when the header is right-clicked.

        Args:
            event (QEvent): The event triggered by the context menu action.
        """
        if self.horizontalHeader().visualIndexAt(event.pos().x()) >= 0:
            logical_index = self.horizontalHeader().logicalIndexAt(event.pos().x())
            header_pos = self.mapToGlobal(self.horizontalHeader().pos())
            header_height = self.horizontalHeader().height()
            self.show_unique_values_menu(logical_index, header_pos, header_height)
        else:
            super().contextMenuEvent(event)

class CustomTableWidget_Drawings(QtWidgets.QTableWidget):
    """
    Custom QTableWidget that supports filtering and sorting features.

    Attributes:
        list_filters (list): Stores filters applied to the table.
        column_filters (dict): Maps column indices to sets of applied filters.
        column_actions (dict): Maps column indices to actions related to columns.
        checkbox_states (dict): Stores the state of checkboxes for filtering.
        rows_hidden (dict): Maps column indices to sets of hidden row indices.
        general_rows_to_hide (set): Set of row indices that are hidden across the table.
    """
    def __init__(self, parent=None):
        """
        Initializes the CustomTableWidget.

        Sets up the initial state of the widget, including filters, checkbox states,
        and hidden rows.

        Args:
            parent (QWidget, optional): The parent widget of this table. Defaults to None.
        """
        super().__init__(parent)
        self.list_filters=[]
        self.column_filters = {}
        self.column_actions = {}
        self.checkbox_states = {}
        self.rows_hidden = {}
        self.general_rows_to_hide = set()

# Function to show the menu
    def show_unique_values_menu(self, column_index, header_pos, header_height):
        """
        Displays a context menu for unique values in a specified column.

        The menu includes options to remove filters, sort the column, and filter by text.
        It also allows the user to select/unselect unique values via checkboxes.

        Args:
            column_index (int): The index of the column for which the menu is displayed.
            header_pos (QPoint): The position of the header in the viewport.
            header_height (int): The height of the header.
        """
        menu = QtWidgets.QMenu(self)
        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro")
        actionDeleteFilterColumn.triggered.connect(lambda: self.delete_filter(column_index))
        menu.addAction(actionDeleteFilterColumn)
        menu.addSeparator()
        actionOrderAsc = menu.addAction("Ordenar Ascendente")
        actionOrderAsc.triggered.connect(lambda: self.sort_column(column_index, QtCore.Qt.SortOrder.AscendingOrder))
        actionOrderDesc = menu.addAction("Ordenar Descendente")
        actionOrderDesc.triggered.connect(lambda: self.sort_column(column_index, QtCore.Qt.SortOrder.DescendingOrder))
        menu.addSeparator()
        actionFilterByText = menu.addAction("Buscar Texto")
        actionFilterByText.triggered.connect(lambda: self.filter_by_text(column_index))
        menu.addSeparator()

        menu.setStyleSheet("QMenu::item:selected { background-color: #33bdef; }"
                        "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

        if column_index not in self.column_filters:
            self.column_filters[column_index] = set()

        scroll_menu = QtWidgets.QScrollArea()
        scroll_menu.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget(scroll_menu)
        scroll_menu.setWidget(scroll_widget)
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        checkboxes = []

        select_all_checkbox = QtWidgets.QCheckBox("Seleccionar todo")
        if column_index in self.checkbox_states:
            select_all_checkbox.setCheckState(QtCore.Qt.CheckState(self.checkbox_states[column_index].get("Seleccionar todo", QtCore.Qt.CheckState(2))))
        else:
            select_all_checkbox.setCheckState(QtCore.Qt.CheckState(2))
        scroll_layout.addWidget(select_all_checkbox)
        checkboxes.append(select_all_checkbox)

        unique_values = self.get_unique_values(column_index)
        filtered_values = self.get_filtered_values()

        for value in sorted(unique_values):
            checkbox = QtWidgets.QCheckBox(value)
            if select_all_checkbox.isChecked():
                checkbox.setCheckState(QtCore.Qt.CheckState(2))
            else:
                if column_index in self.checkbox_states and value in self.checkbox_states[column_index]:
                    checkbox.setCheckState(QtCore.Qt.CheckState(self.checkbox_states[column_index][value]))
                elif filtered_values is None or value in filtered_values[column_index]:
                    checkbox.setCheckState(QtCore.Qt.CheckState(2))
                else:
                    checkbox.setCheckState(QtCore.Qt.CheckState(0))
            scroll_layout.addWidget(checkbox)
            checkboxes.append(checkbox)

        select_all_checkbox.stateChanged.connect(lambda state: self.set_all_checkboxes_state(checkboxes, state, column_index))

        for value, checkbox in zip(sorted(unique_values), checkboxes[1:]):
            checkbox.stateChanged.connect(lambda checked, value=value, checkbox=checkbox: self.apply_filter(column_index, value, checked))

    # Action for drop down menu and adding scroll area as widget
        action_scroll_menu = QtWidgets.QWidgetAction(menu)
        action_scroll_menu.setDefaultWidget(scroll_menu)
        menu.addAction(action_scroll_menu)

        menu.exec(header_pos - QtCore.QPoint(0, header_height))


# Function to delete filter on selected column
    def delete_filter(self,column_index):
        """
        Removes the filter applied to the specified column.

        Unhides previously hidden rows and resets the checkbox state for the column.

        Args:
            column_index (int): The index of the column from which to delete the filter.
        """
        if column_index in self.column_filters:
            del self.column_filters[column_index]
        if column_index in self.checkbox_states:
            del self.checkbox_states[column_index]
        if column_index in self.rows_hidden:
            for item in self.rows_hidden[column_index]:
                self.setRowHidden(item, False)
                if item in self.general_rows_to_hide:
                    self.general_rows_to_hide.remove(item)
            del self.rows_hidden[column_index]
        header_item = self.horizontalHeaderItem(column_index)
        header_item.setIcon(QtGui.QIcon())


# Function to set all checkboxes state
    def set_all_checkboxes_state(self, checkboxes, state, column_index):
        """
        Sets the state of all checkboxes in the filter menu for a specific column.

        Args:
            checkboxes (list): List of checkboxes to update.
            state (Qt.CheckState): The desired state for the checkboxes.
            column_index (int): The index of the column for which the checkboxes are set.
        """
        if column_index not in self.checkbox_states:
            self.checkbox_states[column_index] = {}

        for checkbox in checkboxes:
            checkbox.setCheckState(QtCore.Qt.CheckState(state))

        self.checkbox_states[column_index]["Seleccionar todo"] = state


# Function to apply filters to table
    def apply_filter(self, column_index, value, checked, text_filter=None, filter_dialog=None):
        """
        Applies a filter to the specified column based on the checkbox state and optional text filter.

        Args:
            column_index (int): The index of the column to filter.
            value (str): The value to filter by.
            checked (bool): Indicates if the filter should be applied (True) or removed (False).
            text_filter (str, optional): Additional text filter for filtering items. Defaults to None.
            filter_dialog (QDialog, optional): The dialog used for the text filter. Defaults to None.
        """
        if column_index not in self.column_filters:
            self.column_filters[column_index] = set()

        if text_filter is None:
            if value is None:
                self.column_filters[column_index] = set()
            elif checked:
                self.column_filters[column_index].add(value)
            elif value in self.column_filters[column_index]:
                self.column_filters[column_index].remove(value)

        rows_to_hide = set()
        for row in range(self.rowCount()):
            show_row = True

            # Check filters for all columns
            for col, filters in self.column_filters.items():
                item = self.item(row, col)
                if item:
                    item_value = item.text()
                    if text_filter is None:
                        if filters and item_value not in filters:
                            show_row = False
                            break

        # Filtering by text
            if text_filter is not None:
                filter_dialog.accept()
                item = self.item(row, column_index)
                if item:
                    if text_filter.upper() in item.text().upper():
                        self.column_filters[column_index].add(item.text())
                    else:
                        show_row = False

            if not show_row:
                if row not in self.general_rows_to_hide:
                    self.general_rows_to_hide.add(row)
                    rows_to_hide.add(row)
            else:
                if row in self.general_rows_to_hide:
                    self.general_rows_to_hide.remove(row)

        # Update hidden rows for this column depending on checkboxes
        if checked and text_filter is None:
            if column_index not in self.rows_hidden:
                self.rows_hidden[column_index] = set(rows_to_hide)
            else:
                self.rows_hidden[column_index].update(rows_to_hide)

        # Update hidden rows for this column depending on filtered text
        if text_filter is not None and value is None:
            if column_index not in self.rows_hidden:
                self.rows_hidden[column_index] = set(rows_to_hide)
            else:
                self.rows_hidden[column_index].update(rows_to_hide)

        # Iterate over all rows to hide them as necessary
        for row in range(self.rowCount()):
            self.setRowHidden(row, row in self.general_rows_to_hide)

        header_item = self.horizontalHeaderItem(column_index)
        if len(self.general_rows_to_hide) > 0:
            header_item.setIcon(QtGui.QIcon(str(get_path("Resources", "Iconos", "Filter_Active.png"))))
        else:
            header_item.setIcon(QtGui.QIcon())

# Function to apply filters to table based on a desired text
    def filter_by_text(self, column_index):
        """
        Opens a dialog for filtering the specified column by text input.

        Args:
            column_index (int): The index of the column to filter.
        """
        filter_dialog = QtWidgets.QDialog(self)
        filter_dialog.setWindowTitle("Filtrar por texto")

        label = QtWidgets.QLabel("Texto a filtrar:")
        text_input = QtWidgets.QLineEdit()

        filter_button = QtWidgets.QPushButton("Filtrar")
        filter_button.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 2px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        filter_button.clicked.connect(lambda: self.apply_filter(column_index, None, False, text_input.text(), filter_dialog))

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(label)
        layout.addWidget(text_input)
        layout.addWidget(filter_button)

        filter_dialog.setLayout(layout)
        filter_dialog.exec()


# Function to obtain the unique matching applied filters
    def get_unique_values(self, column_index):
        """
        Retrieves unique values from the specified column, taking into account any active filters on other columns.

        Args:
            column_index (int): The index of the column from which to retrieve unique values.

        Returns:
            set: A set of unique values from the specified column that are visible based on the current filters.
        """
        unique_values = set()
        for row in range(self.rowCount()):
            show_row = True
            for col, filters in self.column_filters.items():
                if col != column_index:
                    item = self.item(row, col)
                    if item:
                        item_value = item.text()
                        if filters and item_value not in filters:
                            show_row = False
                            break
            if show_row:
                item = self.item(row, column_index)
                if item:
                    unique_values.add(item.text())
        return unique_values

# Function to get values filtered by all columns
    def get_filtered_values(self):
        """
        Gets the current filter values for all columns.

        Returns:
            dict: A dictionary where each key is a column index and the value is a set of filters applied to that column.
        """
        filtered_values = {}
        for col, filters in self.column_filters.items():
            filtered_values[col] = filters
        return filtered_values

# Function to sort column
    def sort_column(self, column_index, sortOrder):
        """
        Sorts the specified column based on the given order. If the column is a date column, a custom sort method is used.

        Args:
            column_index (int): The index of the column to sort.
            sortOrder (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        if self.horizontalHeaderItem(column_index).text() == 'Fecha':
            self.custom_sort_date(column_index, sortOrder)
        elif self.horizontalHeaderItem(column_index).text() == 'Cantidad':
            self.custom_sort_int(column_index, sortOrder)
        else:
            self.sortByColumn(column_index, sortOrder)


    def custom_sort_date(self, column, order):
        """
        Custom sorting method for date columns. Sorts the specified column based on date values.

        Args:
            column (int): The index of the column to sort.
            order (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        row_count = self.rowCount()

        indexes = list(range(row_count))
        indexes.sort(key=lambda i: QtCore.QDateTime.fromString(self.item(i, column).text(), "dd-MM-yyyy"))

        if order == QtCore.Qt.SortOrder.DescendingOrder:
            indexes.reverse()

        hidden_rows = [row for row in range(row_count) if self.isRowHidden(row)]

        rows = self.rowCount()
        for i in range(rows):
            self.insertRow(i)

        for new_row, old_row in enumerate(indexes):
            for col in range(self.columnCount()):
                item = self.takeItem(old_row + rows, col)
                self.setItem(new_row, col, item)

        for i in range(rows):
            self.removeRow(rows)

        for row in hidden_rows:
            self.setRowHidden(row, True)

    def custom_sort_int(self, column, order):
        """
        Custom sorting method for integer columns. Sorts the specified column based on integer values.

        Args:
            column (int): The index of the column to sort.
            order (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        row_count = self.rowCount()

        indexes = list(range(row_count))
        indexes.sort(key=lambda i: int(self.item(i, column).text()))

        if order == QtCore.Qt.SortOrder.DescendingOrder:
            indexes.reverse()

        hidden_rows = [row for row in range(row_count) if self.isRowHidden(row)]

        rows = self.rowCount()
        for i in range(rows):
            self.insertRow(i)

        for new_row, old_row in enumerate(indexes):
            for col in range(self.columnCount()):
                item = self.takeItem(old_row + rows, col)
                self.setItem(new_row, col, item)

        for i in range(rows):
            self.removeRow(rows)

        for row in hidden_rows:
            self.setRowHidden(row, True)

# Function with the menu configuration
    def contextMenuEvent(self, event):
        """
        Handles the context menu event for the table. Shows a menu for filtering unique values when the header is right-clicked.

        Args:
            event (QEvent): The event triggered by the context menu action.
        """
        if self.horizontalHeader().visualIndexAt(event.pos().x()) >= 0:
            logical_index = self.horizontalHeader().logicalIndexAt(event.pos().x())
            header_pos = self.mapToGlobal(self.horizontalHeader().pos())
            header_height = self.horizontalHeader().height()
            self.show_unique_values_menu(logical_index, header_pos, header_height)
        else:
            super().contextMenuEvent(event)

class CustomTableWidget_Calibration(QtWidgets.QTableWidget):
    """
    Custom QTableWidget that supports filtering and sorting features.

    Attributes:
        list_filters (list): Stores filters applied to the table.
        column_filters (dict): Maps column indices to sets of applied filters.
        column_actions (dict): Maps column indices to actions related to columns.
        checkbox_states (dict): Stores the state of checkboxes for filtering.
        rows_hidden (dict): Maps column indices to sets of hidden row indices.
        general_rows_to_hide (set): Set of row indices that are hidden across the table.
    """
    def __init__(self, parent=None):
        """
        Initializes the CustomTableWidget.

        Sets up the initial state of the widget, including filters, checkbox states,
        and hidden rows.

        Args:
            parent (QWidget, optional): The parent widget of this table. Defaults to None.
        """
        super().__init__(parent)
        self.list_filters=[]
        self.column_filters = {}
        self.column_actions = {}
        self.checkbox_states = {}
        self.rows_hidden = {}
        self.general_rows_to_hide = set()

# Function to show the menu
    def show_unique_values_menu(self, column_index, header_pos, header_height):
        """
        Displays a context menu for unique values in a specified column.

        The menu includes options to remove filters, sort the column, and filter by text.
        It also allows the user to select/unselect unique values via checkboxes.

        Args:
            column_index (int): The index of the column for which the menu is displayed.
            header_pos (QPoint): The position of the header in the viewport.
            header_height (int): The height of the header.
        """
        menu = QtWidgets.QMenu(self)
        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro")
        actionDeleteFilterColumn.triggered.connect(lambda: self.delete_filter(column_index))
        menu.addAction(actionDeleteFilterColumn)
        menu.addSeparator()
        actionOrderAsc = menu.addAction("Ordenar Ascendente")
        actionOrderAsc.triggered.connect(lambda: self.sort_column(column_index, QtCore.Qt.SortOrder.AscendingOrder))
        actionOrderDesc = menu.addAction("Ordenar Descendente")
        actionOrderDesc.triggered.connect(lambda: self.sort_column(column_index, QtCore.Qt.SortOrder.DescendingOrder))
        menu.addSeparator()
        actionFilterByText = menu.addAction("Buscar Texto")
        actionFilterByText.triggered.connect(lambda: self.filter_by_text(column_index))
        menu.addSeparator()

        menu.setStyleSheet("QMenu::item:selected { background-color: #33bdef; }"
                        "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

        if column_index not in self.column_filters:
            self.column_filters[column_index] = set()

        scroll_menu = QtWidgets.QScrollArea()
        scroll_menu.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget(scroll_menu)
        scroll_menu.setWidget(scroll_widget)
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        checkboxes = []

        select_all_checkbox = QtWidgets.QCheckBox("Seleccionar todo")
        if column_index in self.checkbox_states:
            select_all_checkbox.setCheckState(QtCore.Qt.CheckState(self.checkbox_states[column_index].get("Seleccionar todo", QtCore.Qt.CheckState(2))))
        else:
            select_all_checkbox.setCheckState(QtCore.Qt.CheckState(2))
        scroll_layout.addWidget(select_all_checkbox)
        checkboxes.append(select_all_checkbox)

        unique_values = self.get_unique_values(column_index)
        filtered_values = self.get_filtered_values()

        for value in sorted(unique_values):
            checkbox = QtWidgets.QCheckBox(value)
            if select_all_checkbox.isChecked():
                checkbox.setCheckState(QtCore.Qt.CheckState(2))
            else:
                if column_index in self.checkbox_states and value in self.checkbox_states[column_index]:
                    checkbox.setCheckState(QtCore.Qt.CheckState(self.checkbox_states[column_index][value]))
                elif filtered_values is None or value in filtered_values[column_index]:
                    checkbox.setCheckState(QtCore.Qt.CheckState(2))
                else:
                    checkbox.setCheckState(QtCore.Qt.CheckState(0))
            scroll_layout.addWidget(checkbox)
            checkboxes.append(checkbox)

        select_all_checkbox.stateChanged.connect(lambda state: self.set_all_checkboxes_state(checkboxes, state, column_index))

        for value, checkbox in zip(sorted(unique_values), checkboxes[1:]):
            checkbox.stateChanged.connect(lambda checked, value=value, checkbox=checkbox: self.apply_filter(column_index, value, checked))

    # Action for drop down menu and adding scroll area as widget
        action_scroll_menu = QtWidgets.QWidgetAction(menu)
        action_scroll_menu.setDefaultWidget(scroll_menu)
        menu.addAction(action_scroll_menu)

        menu.exec(header_pos - QtCore.QPoint(0, header_height))


# Function to delete filter on selected column
    def delete_filter(self,column_index):
        """
        Removes the filter applied to the specified column.

        Unhides previously hidden rows and resets the checkbox state for the column.

        Args:
            column_index (int): The index of the column from which to delete the filter.
        """
        if column_index in self.column_filters:
            del self.column_filters[column_index]
        if column_index in self.checkbox_states:
            del self.checkbox_states[column_index]
        if column_index in self.rows_hidden:
            for item in self.rows_hidden[column_index]:
                self.setRowHidden(item, False)
                if item in self.general_rows_to_hide:
                    self.general_rows_to_hide.remove(item)
            del self.rows_hidden[column_index]
        header_item = self.horizontalHeaderItem(column_index)
        header_item.setIcon(QtGui.QIcon())


# Function to set all checkboxes state
    def set_all_checkboxes_state(self, checkboxes, state, column_index):
        """
        Sets the state of all checkboxes in the filter menu for a specific column.

        Args:
            checkboxes (list): List of checkboxes to update.
            state (Qt.CheckState): The desired state for the checkboxes.
            column_index (int): The index of the column for which the checkboxes are set.
        """
        if column_index not in self.checkbox_states:
            self.checkbox_states[column_index] = {}

        for checkbox in checkboxes:
            checkbox.setCheckState(QtCore.Qt.CheckState(state))

        self.checkbox_states[column_index]["Seleccionar todo"] = state


# Function to apply filters to table
    def apply_filter(self, column_index, value, checked, text_filter=None, filter_dialog=None):
        """
        Applies a filter to the specified column based on the checkbox state and optional text filter.

        Args:
            column_index (int): The index of the column to filter.
            value (str): The value to filter by.
            checked (bool): Indicates if the filter should be applied (True) or removed (False).
            text_filter (str, optional): Additional text filter for filtering items. Defaults to None.
            filter_dialog (QDialog, optional): The dialog used for the text filter. Defaults to None.
        """
        if column_index not in self.column_filters:
            self.column_filters[column_index] = set()

        if text_filter is None:
            if value is None:
                self.column_filters[column_index] = set()
            elif checked:
                self.column_filters[column_index].add(value)
            elif value in self.column_filters[column_index]:
                self.column_filters[column_index].remove(value)

        rows_to_hide = set()
        for row in range(self.rowCount()):
            show_row = True

            # Check filters for all columns
            for col, filters in self.column_filters.items():
                item = self.item(row, col)
                if item:
                    item_value = item.text()
                    if text_filter is None:
                        if filters and item_value not in filters:
                            show_row = False
                            break

        # Filtering by text
            if text_filter is not None:
                filter_dialog.accept()
                item = self.item(row, column_index)
                if item:
                    if text_filter.upper() in item.text().upper():
                        self.column_filters[column_index].add(item.text())
                    else:
                        show_row = False

            if not show_row:
                if row not in self.general_rows_to_hide:
                    self.general_rows_to_hide.add(row)
                    rows_to_hide.add(row)
            else:
                if row in self.general_rows_to_hide:
                    self.general_rows_to_hide.remove(row)

        # Update hidden rows for this column depending on checkboxes
        if checked and text_filter is None:
            if column_index not in self.rows_hidden:
                self.rows_hidden[column_index] = set(rows_to_hide)
            else:
                self.rows_hidden[column_index].update(rows_to_hide)

        # Update hidden rows for this column depending on filtered text
        if text_filter is not None and value is None:
            if column_index not in self.rows_hidden:
                self.rows_hidden[column_index] = set(rows_to_hide)
            else:
                self.rows_hidden[column_index].update(rows_to_hide)

        # Iterate over all rows to hide them as necessary
        for row in range(self.rowCount()):
            self.setRowHidden(row, row in self.general_rows_to_hide)

        header_item = self.horizontalHeaderItem(column_index)
        if len(self.general_rows_to_hide) > 0:
            header_item.setIcon(QtGui.QIcon(str(get_path("Resources", "Iconos", "Filter_Active.png"))))
        else:
            header_item.setIcon(QtGui.QIcon())

# Function to apply filters to table based on a desired text
    def filter_by_text(self, column_index):
        """
        Opens a dialog for filtering the specified column by text input.

        Args:
            column_index (int): The index of the column to filter.
        """
        filter_dialog = QtWidgets.QDialog(self)
        filter_dialog.setWindowTitle("Filtrar por texto")

        label = QtWidgets.QLabel("Texto a filtrar:")
        text_input = QtWidgets.QLineEdit()

        filter_button = QtWidgets.QPushButton("Filtrar")
        filter_button.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 2px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        filter_button.clicked.connect(lambda: self.apply_filter(column_index, None, False, text_input.text(), filter_dialog))

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(label)
        layout.addWidget(text_input)
        layout.addWidget(filter_button)

        filter_dialog.setLayout(layout)
        filter_dialog.exec()


# Function to obtain the unique matching applied filters
    def get_unique_values(self, column_index):
        """
        Retrieves unique values from the specified column, taking into account any active filters on other columns.

        Args:
            column_index (int): The index of the column from which to retrieve unique values.

        Returns:
            set: A set of unique values from the specified column that are visible based on the current filters.
        """
        unique_values = set()
        for row in range(self.rowCount()):
            show_row = True
            for col, filters in self.column_filters.items():
                if col != column_index:
                    item = self.item(row, col)
                    if item:
                        item_value = item.text()
                        if filters and item_value not in filters:
                            show_row = False
                            break
            if show_row:
                item = self.item(row, column_index)
                if item:
                    unique_values.add(item.text())
        return unique_values

# Function to get values filtered by all columns
    def get_filtered_values(self):
        """
        Gets the current filter values for all columns.

        Returns:
            dict: A dictionary where each key is a column index and the value is a set of filters applied to that column.
        """
        filtered_values = {}
        for col, filters in self.column_filters.items():
            filtered_values[col] = filters
        return filtered_values

# Function to sort column
    def sort_column(self, column_index, sortOrder):
        """
        Sorts the specified column based on the given order. If the column is a date column, a custom sort method is used.

        Args:
            column_index (int): The index of the column to sort.
            sortOrder (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        if self.horizontalHeaderItem(column_index).text() == 'Fecha':
            self.custom_sort_date(column_index, sortOrder)
        elif self.horizontalHeaderItem(column_index).text() == 'Cantidad':
            self.custom_sort_int(column_index, sortOrder)
        else:
            self.sortByColumn(column_index, sortOrder)


    def custom_sort_date(self, column, order):
        """
        Custom sorting method for date columns. Sorts the specified column based on date values.

        Args:
            column (int): The index of the column to sort.
            order (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        row_count = self.rowCount()

        indexes = list(range(row_count))
        indexes.sort(key=lambda i: QtCore.QDateTime.fromString(self.item(i, column).text(), "dd-MM-yyyy"))

        if order == QtCore.Qt.SortOrder.DescendingOrder:
            indexes.reverse()

        hidden_rows = [row for row in range(row_count) if self.isRowHidden(row)]

        rows = self.rowCount()
        for i in range(rows):
            self.insertRow(i)

        for new_row, old_row in enumerate(indexes):
            for col in range(self.columnCount()):
                item = self.takeItem(old_row + rows, col)
                self.setItem(new_row, col, item)

        for i in range(rows):
            self.removeRow(rows)

        for row in hidden_rows:
            self.setRowHidden(row, True)

    def custom_sort_int(self, column, order):
        """
        Custom sorting method for integer columns. Sorts the specified column based on integer values.

        Args:
            column (int): The index of the column to sort.
            order (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        row_count = self.rowCount()

        indexes = list(range(row_count))
        indexes.sort(key=lambda i: int(self.item(i, column).text()))

        if order == QtCore.Qt.SortOrder.DescendingOrder:
            indexes.reverse()

        hidden_rows = [row for row in range(row_count) if self.isRowHidden(row)]

        rows = self.rowCount()
        for i in range(rows):
            self.insertRow(i)

        for new_row, old_row in enumerate(indexes):
            for col in range(self.columnCount()):
                item = self.takeItem(old_row + rows, col)
                self.setItem(new_row, col, item)

        for i in range(rows):
            self.removeRow(rows)

        for row in hidden_rows:
            self.setRowHidden(row, True)

# Function with the menu configuration
    def contextMenuEvent(self, event):
        """
        Handles the context menu event for the table. Shows a menu for filtering unique values when the header is right-clicked.

        Args:
            event (QEvent): The event triggered by the context menu action.
        """
        if self.horizontalHeader().visualIndexAt(event.pos().x()) >= 0:
            logical_index = self.horizontalHeader().logicalIndexAt(event.pos().x())
            header_pos = self.mapToGlobal(self.horizontalHeader().pos())
            header_height = self.horizontalHeader().height()
            self.show_unique_values_menu(logical_index, header_pos, header_height)
        else:
            super().contextMenuEvent(event)

class Ui_Verif_Order_Window(QtWidgets.QMainWindow):
    """
    UI class for the Order Verification window.
    """
    def __init__(self, username, numorder):
        """
        Initializes the Ui_New_Offer_Window with the specified username and order number.

        Args:
            username (str): username associated with the window.
            numorder (str): order number associated with the window.
        """
        super().__init__()
        self.username = username
        self.numorder = numorder.upper()
        self.setupUi(self)

    def setupUi(self, Verif_Order_Window):
        """
        Sets up the user interface for the Verif_Order_Window.

        Args:
            Verif_Order_Window (QtWidgets.QMainWindow): The main window for the UI setup.
        """
        Verif_Order_Window.setObjectName("Verif_Order_Window")
        Verif_Order_Window.resize(790, 595)
        Verif_Order_Window.setMinimumSize(QtCore.QSize(790, 595))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        Verif_Order_Window.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(parent=Verif_Order_Window)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_2.setVerticalSpacing(10)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.layout_vertical = QtWidgets.QVBoxLayout()
        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Orientation.Vertical)
        self.frame1 = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame2 = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame3 = QtWidgets.QFrame(parent=self.centralwidget)
        self.gridLayout1 = QtWidgets.QGridLayout(self.frame1)
        self.label1 = QtWidgets.QLabel()
        self.label1.setText('TAGS')
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        self.label1.setFont(font)
        self.table_tags = CustomTableWidget_Tags()
        self.table_tags.setObjectName("table_tags")
        self.table_tags.setColumnCount(18)
        self.table_tags.setRowCount(0)
        for i in range (18):
            item = QtWidgets.QTableWidgetItem()
            font = QtGui.QFont()
            font.setPointSize(10)
            font.setBold(True)
            item.setFont(font)
            self.table_tags.setHorizontalHeaderItem(i, item)
        self.gridLayout1.addWidget(self.label1, 0, 0, 1, 1)
        self.gridLayout1.addWidget(self.table_tags, 1, 0, 1, 6)
        self.label_SumItems_tags = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems_tags.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems_tags.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems_tags.setText("")
        self.label_SumItems_tags.setObjectName("label_SumItems_tags")
        self.gridLayout1.addWidget(self.label_SumItems_tags, 2, 2, 1, 1)
        self.label_SumValue_tags = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue_tags.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue_tags.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue_tags.setText("")
        self.label_SumValue_tags.setObjectName("label_SumValue_tags")
        self.gridLayout1.addWidget(self.label_SumValue_tags, 2, 3, 1, 1)
        self.label_CountItems_tags = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems_tags.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems_tags.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems_tags.setText("")
        self.label_CountItems_tags.setObjectName("label_CountItems_tags")
        self.gridLayout1.addWidget(self.label_CountItems_tags, 2, 4, 1, 1)
        self.label_CountValue_tags = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue_tags.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue_tags.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue_tags.setText("")
        self.label_CountValue_tags.setObjectName("label_CountValue_tags")
        self.gridLayout1.addWidget(self.label_CountValue_tags, 2, 5, 1, 1)
        self.splitter.addWidget(self.frame1)
        self.gridLayout2 = QtWidgets.QGridLayout(self.frame2)
        self.label2 = QtWidgets.QLabel()
        self.label2.setText('Planos, Pruebas, PPI y EXP')
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        self.label2.setFont(font)
        self.table_drawings = CustomTableWidget_Drawings()
        self.table_drawings.setObjectName("table_drawings")
        self.table_drawings.setColumnCount(4)
        self.table_drawings.setRowCount(0)
        for i in range (4):
            item = QtWidgets.QTableWidgetItem()
            font = QtGui.QFont()
            font.setPointSize(10)
            font.setBold(True)
            item.setFont(font)
            self.table_drawings.setHorizontalHeaderItem(i, item)
        self.gridLayout2.addWidget(self.label2, 0, 0, 1, 1)
        self.gridLayout2.addWidget(self.table_drawings, 1, 0, 1, 6)
        self.label_SumItems_drawings = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems_drawings.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems_drawings.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems_drawings.setText("")
        self.label_SumItems_drawings.setObjectName("label_SumItems_drawings")
        self.gridLayout2.addWidget(self.label_SumItems_drawings, 2, 2, 1, 1)
        self.label_SumValue_drawings = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue_drawings.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue_drawings.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue_drawings.setText("")
        self.label_SumValue_drawings.setObjectName("label_SumValue_drawings")
        self.gridLayout2.addWidget(self.label_SumValue_drawings, 2, 3, 1, 1)
        self.label_CountItems_drawings = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems_drawings.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems_drawings.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems_drawings.setText("")
        self.label_CountItems_drawings.setObjectName("label_CountItems_drawings")
        self.gridLayout2.addWidget(self.label_CountItems_drawings, 2, 4, 1, 1)
        self.label_CountValue_drawings = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue_drawings.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue_drawings.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue_drawings.setText("")
        self.label_CountValue_drawings.setObjectName("label_CountValue_drawings")
        self.gridLayout2.addWidget(self.label_CountValue_drawings, 2, 5, 1, 1)
        self.splitter.addWidget(self.frame2)
        self.gridLayout3 = QtWidgets.QGridLayout(self.frame3)
        self.label3 = QtWidgets.QLabel()
        self.label3.setText('Calibraciones')
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        self.label3.setFont(font)
        self.table_calibrations = CustomTableWidget_Calibration()
        self.table_calibrations.setObjectName("table_calibrations")
        self.table_calibrations.setColumnCount(4)
        self.table_calibrations.setRowCount(0)
        for i in range (4):
            item = QtWidgets.QTableWidgetItem()
            font = QtGui.QFont()
            font.setPointSize(10)
            font.setBold(True)
            item.setFont(font)
            self.table_calibrations.setHorizontalHeaderItem(i, item)
        self.gridLayout3.addWidget(self.label3, 0, 0, 1, 1)
        self.gridLayout3.addWidget(self.table_calibrations, 1, 0, 1, 6)
        self.label_SumItems_calibration = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems_calibration.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems_calibration.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems_calibration.setText("")
        self.label_SumItems_calibration.setObjectName("label_SumItems_calibration")
        self.gridLayout3.addWidget(self.label_SumItems_calibration, 2, 2, 1, 1)
        self.label_SumValue_calibration = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue_calibration.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue_calibration.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue_calibration.setText("")
        self.label_SumValue_calibration.setObjectName("label_SumValue_calibration")
        self.gridLayout3.addWidget(self.label_SumValue_calibration, 2, 3, 1, 1)
        self.label_CountItems_calibration = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems_calibration.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems_calibration.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems_calibration.setText("")
        self.label_CountItems_calibration.setObjectName("label_CountItems_calibration")
        self.gridLayout3.addWidget(self.label_CountItems_calibration, 2, 4, 1, 1)
        self.label_CountValue_calibration = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue_calibration.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue_calibration.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue_calibration.setText("")
        self.label_CountValue_calibration.setObjectName("label_CountValue_calibration")
        self.gridLayout3.addWidget(self.label_CountValue_calibration, 2, 5, 1, 1)
        self.splitter.addWidget(self.frame3)
        self.layout_vertical.addWidget(self.splitter)
        self.gridLayout_2.addLayout(self.layout_vertical, 0, 0, 1, 2)
        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 0, 0, 1, 1)
        self.Button_Notify = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Notify.setMinimumSize(QtCore.QSize(100, 35))
        # self.Button_Notify.setMaximumSize(QtCore.QSize(100, 35))
        self.Button_Notify.setObjectName("Button_Notify")
        self.Button_Notify.setStyleSheet("QPushButton {\n"
    "background-color: #33bdef;\n"
    "  border: 1px solid transparent;\n"
    "  border-radius: 3px;\n"
    "  color: #fff;\n"
    "  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
    "  font-size: 15px;\n"
    "  font-weight: 800;\n"
    "  line-height: 1.15385;\n"
    "  margin: 0;\n"
    "  outline: none;\n"
    "  padding: 2px .8em;\n"
    "  text-align: center;\n"
    "  text-decoration: none;\n"
    "  vertical-align: baseline;\n"
    "  white-space: nowrap;\n"
    "}\n"
    "\n"
    "QPushButton:hover {\n"
    "    background-color: #019ad2;\n"
    "    border-color: rgb(0, 0, 0);\n"
    "}\n"
    "\n"
    "QPushButton:pressed {\n"
    "    background-color: rgb(1, 140, 190);\n"
    "    border-color: rgb(255, 255, 255);\n"
    "}")
        self.gridLayout_2.addWidget(self.Button_Notify, 1, 0, 1, 1)
        self.Button_Insert = QtWidgets.QPushButton(parent=self.frame)
        self.Button_Insert.setMinimumSize(QtCore.QSize(100, 35))
        # self.Button_Insert.setMaximumSize(QtCore.QSize(100, 35))
        self.Button_Insert.setObjectName("Button_Insert")
        self.Button_Insert.setStyleSheet("QPushButton {\n"
    "background-color: #33bdef;\n"
    "  border: 1px solid transparent;\n"
    "  border-radius: 3px;\n"
    "  color: #fff;\n"
    "  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
    "  font-size: 15px;\n"
    "  font-weight: 800;\n"
    "  line-height: 1.15385;\n"
    "  margin: 0;\n"
    "  outline: none;\n"
    "  padding: 2px .8em;\n"
    "  text-align: center;\n"
    "  text-decoration: none;\n"
    "  vertical-align: baseline;\n"
    "  white-space: nowrap;\n"
    "}\n"
    "\n"
    "QPushButton:hover {\n"
    "    background-color: #019ad2;\n"
    "    border-color: rgb(0, 0, 0);\n"
    "}\n"
    "\n"
    "QPushButton:pressed {\n"
    "    background-color: rgb(1, 140, 190);\n"
    "    border-color: rgb(255, 255, 255);\n"
    "}")
        self.gridLayout_2.addWidget(self.Button_Insert, 1, 1, 1, 1)
        self.gridLayout.addWidget(self.frame, 0, 0, 1, 1)
        Verif_Order_Window.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=Verif_Order_Window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 790, 22))
        self.menubar.setObjectName("menubar")
        Verif_Order_Window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=Verif_Order_Window)
        self.statusbar.setObjectName("statusbar")
        self.table_tags.horizontalHeader().setStyleSheet("QHeaderView::section {background-color: #33bdef; border: 1px solid black;}")
        self.table_drawings.horizontalHeader().setStyleSheet("QHeaderView::section {background-color: #33bdef; border: 1px solid black;}")
        self.table_calibrations.horizontalHeader().setStyleSheet("QHeaderView::section {background-color: #33bdef; border: 1px solid black;}")

        self.table_tags.setStyleSheet("gridline-color: rgb(128, 128, 128);")
        self.table_tags.horizontalHeader().setStyleSheet("QHeaderView::section {background-color: #33bdef; border: 1px solid; font-weight: bold; font-size: 10pt;}")
        self.table_tags.verticalHeader().setStyleSheet("QHeaderView::section {border: 0.5px solid; font-size: 10pt;}")
        self.table_drawings.setStyleSheet("gridline-color: rgb(128, 128, 128);")
        self.table_drawings.horizontalHeader().setStyleSheet("QHeaderView::section {background-color: #33bdef; border: 1px solid; font-weight: bold; font-size: 10pt;}")
        self.table_drawings.verticalHeader().setStyleSheet("QHeaderView::section {border: 0.5px solid; font-size: 10pt;}")
        self.table_calibrations.setStyleSheet("gridline-color: rgb(128, 128, 128);")
        self.table_calibrations.horizontalHeader().setStyleSheet("QHeaderView::section {background-color: #33bdef; border: 1px solid; font-weight: bold; font-size: 10pt;}")
        self.table_calibrations.verticalHeader().setStyleSheet("QHeaderView::section {border: 0.5px solid; font-size: 10pt;}")
        Verif_Order_Window.setStatusBar(self.statusbar)

        self.retranslateUi(Verif_Order_Window)
        QtCore.QMetaObject.connectSlotsByName(Verif_Order_Window)

        self.table_tags.horizontalHeader().sectionClicked.connect(self.on_header_section_clicked_tags)
        self.table_drawings.horizontalHeader().sectionClicked.connect(self.on_header_section_clicked_drawings)
        self.table_calibrations.horizontalHeader().sectionClicked.connect(self.on_header_section_clicked_calibrations)

        self.table_tags.itemSelectionChanged.connect(self.countSelectedCells_tags)
        self.table_drawings.itemSelectionChanged.connect(self.countSelectedCells_drawings)
        self.table_calibrations.itemSelectionChanged.connect(self.countSelectedCells_calibration)

        self.table_tags.itemDoubleClicked.connect(self.item_double_click)
        self.table_drawings.itemDoubleClicked.connect(self.item_double_click)

        self.Button_Insert.clicked.connect(self.expedition)
        self.Button_Notify.clicked.connect(self.notify)

        self.query_data()

# Function to translate and updates the text of various UI elements
    def retranslateUi(self, Verif_Order_Window):
        """
        Translates and updates the text of various UI elements.
        """
        _translate = QtCore.QCoreApplication.translate
        Verif_Order_Window.setWindowTitle(_translate("Verif_Order_Window", "Verificacin Pedido"))
        item = self.table_tags.horizontalHeaderItem(0)
        item.setText(_translate("TestHydroQuery_Window", "ID Tag"))
        item = self.table_tags.horizontalHeaderItem(1)
        item.setText(_translate("TestHydroQuery_Window", "N Pedido"))
        item = self.table_tags.horizontalHeaderItem(2)
        item.setText(_translate("TestHydroQuery_Window", "TAG"))
        item = self.table_tags.horizontalHeaderItem(3)
        item.setText(_translate("TestHydroQuery_Window", "Descripcin"))
        item = self.table_tags.horizontalHeaderItem(4)
        item.setText(_translate("TestLiquidQuery_Window", "Plano Dim."))
        item = self.table_tags.horizontalHeaderItem(5)
        item.setText(_translate("TestLiquidQuery_Window", "OF Equipo"))
        item = self.table_tags.horizontalHeaderItem(6)
        item.setText(_translate("TestLiquidQuery_Window", "OF Sensor"))
        item = self.table_tags.horizontalHeaderItem(7)
        item.setText(_translate("TestHydroQuery_Window", "PMI"))
        item = self.table_tags.horizontalHeaderItem(8)
        item.setText(_translate("TestHydroQuery_Window", "PH1"))
        item = self.table_tags.horizontalHeaderItem(9)
        item.setText(_translate("TestHydroQuery_Window", "PH2"))
        item = self.table_tags.horizontalHeaderItem(10)
        item.setText(_translate("TestHydroQuery_Window", "LP"))
        item = self.table_tags.horizontalHeaderItem(11)
        item.setText(_translate("TestHydroQuery_Window", "Dureza"))
        item = self.table_tags.horizontalHeaderItem(12)
        item.setText(_translate("TestHydroQuery_Window", "Dim."))
        item = self.table_tags.horizontalHeaderItem(13)
        item.setText(_translate("TestHydroQuery_Window", "OF Eq."))
        item = self.table_tags.horizontalHeaderItem(14)
        item.setText(_translate("TestHydroQuery_Window", "OF Sensor"))
        item = self.table_tags.horizontalHeaderItem(15)
        item.setText(_translate("TestHydroQuery_Window", "Fotos"))
        item = self.table_drawings.horizontalHeaderItem(0)
        item.setText(_translate("TestLiquidQuery_Window", "N Pedido"))
        item = self.table_drawings.horizontalHeaderItem(1)
        item.setText(_translate("TestLiquidQuery_Window", "N Plano"))
        item = self.table_drawings.horizontalHeaderItem(2)
        item.setText(_translate("TestLiquidQuery_Window", "Fecha"))
        item = self.table_calibrations.horizontalHeaderItem(0)
        item.setText(_translate("TestHardQuery_Window", "N Pedido"))
        item = self.table_calibrations.horizontalHeaderItem(1)
        item.setText(_translate("TestHardQuery_Window", "TAG"))
        item = self.table_calibrations.horizontalHeaderItem(2)
        item.setText(_translate("TestHardQuery_Window", "Label"))
        item = self.table_calibrations.horizontalHeaderItem(3)
        item.setText(_translate("TestHardQuery_Window", "Fecha"))
        self.Button_Insert.setText(_translate("TestHardQuery_Window", "Expedir"))
        self.Button_Notify.setText(_translate("TestHardQuery_Window", "Avisar Expedicin"))

# Function to load table and setting in the window
    def query_data(self):
        """
        Queries the database for tags, drawings and calibrations for given order, configures and populates tables with the query results,
        and updates the UI accordingly. Handles potential database errors and updates the UI with appropriate messages.
        """
        query_tags = ("""
                        SELECT id_tag_flow, num_order, tag, item_type, dim_drawing, of_drawing, NULL as of_sensor_drawing, TO_CHAR(pmi_date, 'DD/MM/YYYY'), TO_CHAR(ph1_date, 'DD/MM/YYYY'), TO_CHAR(ph2_date, 'DD/MM/YYYY'), TO_CHAR(lp_date, 'DD/MM/YYYY'), TO_CHAR(hard_date, 'DD/MM/YYYY'), TO_CHAR(final_verif_dim_date, 'DD/MM/YYYY'), TO_CHAR(final_verif_of_eq_date, 'DD/MM/YYYY'), NULL as final_verif_of_sensor_date, tag_images, 'tags_data.tags_flow', 'id_tag_flow' FROM tags_data.tags_flow WHERE num_order LIKE ('%%'||%s||'%%') and tag_state in ('PURCHASED', 'HOLD')
                        UNION
                        SELECT id_tag_temp, num_order, tag, item_type, dim_drawing, of_drawing, of_sensor_drawing, TO_CHAR(pmi_date, 'DD/MM/YYYY'), TO_CHAR(ph1_date, 'DD/MM/YYYY'), TO_CHAR(ph2_date, 'DD/MM/YYYY'), TO_CHAR(lp_date, 'DD/MM/YYYY'), TO_CHAR(hard_date, 'DD/MM/YYYY'), TO_CHAR(final_verif_dim_date, 'DD/MM/YYYY'), TO_CHAR(final_verif_of_eq_date, 'DD/MM/YYYY'), TO_CHAR(final_verif_of_sensor_date, 'DD/MM/YYYY'), tag_images, 'tags_data.tags_temp', 'id_tag_temp' FROM tags_data.tags_temp WHERE num_order LIKE ('%%'||%s||'%%') and tag_state in ('PURCHASED', 'HOLD')
                        UNION
                        SELECT id_tag_level, num_order, tag, item_type, dim_drawing, of_drawing, NULL as of_sensor_drawing, TO_CHAR(pmi_date, 'DD/MM/YYYY'), TO_CHAR(ph1_date, 'DD/MM/YYYY'), TO_CHAR(ph2_date, 'DD/MM/YYYY'), TO_CHAR(lp_date, 'DD/MM/YYYY'), TO_CHAR(hard_date, 'DD/MM/YYYY'), TO_CHAR(final_verif_dim_date, 'DD/MM/YYYY'), TO_CHAR(final_verif_of_eq_date, 'DD/MM/YYYY'), NULL as final_verif_of_sensor_date, tag_images, 'tags_data.tags_level', 'id_tag_level' FROM tags_data.tags_level WHERE num_order LIKE ('%%'||%s||'%%') and tag_state in ('PURCHASED', 'HOLD')
                        UNION
                        SELECT id_tag_others, num_order, tag, description, dim_drawing, of_drawing, NULL as of_sensor_drawing, TO_CHAR(pmi_date, 'DD/MM/YYYY'), TO_CHAR(ph1_date, 'DD/MM/YYYY'), TO_CHAR(ph2_date, 'DD/MM/YYYY'), TO_CHAR(lp_date, 'DD/MM/YYYY'), TO_CHAR(hard_date, 'DD/MM/YYYY'), TO_CHAR(final_verif_dim_date, 'DD/MM/YYYY'), TO_CHAR(final_verif_of_eq_date, 'DD/MM/YYYY'), NULL as final_verif_of_sensor_date, tag_images, 'tags_data.tags_others', 'id_tag_others' FROM tags_data.tags_others WHERE num_order LIKE ('%%'||%s||'%%') and tag_state in ('PURCHASED', 'HOLD')
                        """)

        query_drawings = ("""
                        SELECT num_order, drawing_number, TO_CHAR(verif_dim_drawing_date, 'DD/MM/YYYY'), verif_dim_drawing_obs FROM verification.dim_drawing_verification WHERE num_order LIKE ('%%'||%s||'%%')
                        UNION
                        SELECT num_order, drawing_number, TO_CHAR(verif_of_drawing_date, 'DD/MM/YYYY'), verif_of_drawing_obs FROM verification.of_drawing_verification WHERE num_order LIKE ('%%'||%s||'%%')
                        UNION
                        SELECT num_order, drawing_number, TO_CHAR(verif_m_drawing_date, 'DD/MM/YYYY'), verif_m_drawing_obs FROM verification.m_drawing_verification WHERE num_order LIKE ('%%'||%s||'%%')
                        UNION
                        SELECT num_order, 'PPI' as of_drawing, TO_CHAR(verif_ppi_date, 'DD/MM/YYYY'), verif_ppi_obs FROM verification.ppi_verification WHERE num_order LIKE ('%%'||%s||'%%')
                        UNION
                        SELECT num_order, 'EXP' as of_drawing, TO_CHAR(verif_exp_date, 'DD/MM/YYYY'), verif_exp_obs FROM verification.exp_verification WHERE num_order LIKE ('%%'||%s||'%%')
                        UNION
                        SELECT num_order, test_type, TO_CHAR(test_date, 'DD/MM/YYYY'), 'id' FROM verification.test_others WHERE num_order LIKE ('%%'||%s||'%%')
                        ORDER BY drawing_number
                        """)

        query_calibration = ("""
                        SELECT num_order, tag, label, TO_CHAR(test_date, 'DD/MM/YYYY') FROM verification.calibration_thermoelements WHERE num_order LIKE ('%%'||%s||'%%')
                        """)

        try:
            with Database_Connection(config_database()) as conn:
                with conn.cursor() as cur:
                # execution of commands
                    cur.execute(query_tags, (self.numorder, self.numorder, self.numorder, self.numorder,))
                    results_tags=cur.fetchall()

                    cur.execute(query_drawings, (self.numorder, self.numorder, self.numorder, self.numorder, self.numorder, self.numorder,))
                    results_drawings=cur.fetchall()

                    cur.execute(query_calibration, (self.numorder,))
                    results_calibration=cur.fetchall()

            self.table_tags.setRowCount(len(results_tags))
            tablerow=0

        # fill the Qt Table with the query results
            for row in results_tags:
                for column in range(18):
                    value = row[column]
                    if value is None:
                        value = ''
                    it = QtWidgets.QTableWidgetItem(str(value))
                    it.setFlags(it.flags() & ~QtCore.Qt.ItemFlag.ItemIsEditable)
                    self.table_tags.setItem(tablerow, column, it)

                tablerow+=1

            self.table_tags.setItemDelegate(AlignDelegate(self.table_tags))
            self.table_tags.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
            # self.table_tags.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.Interactive)
            # self.table_tags.setColumnWidth(2, 200)
            self.table_tags.setSortingEnabled(False)
            # self.table_tags.hideColumn(0)
            self.table_tags.custom_sort_date(0, QtCore.Qt.SortOrder.AscendingOrder)
            self.table_tags.hideColumn(0)
            self.table_tags.hideColumn(16)
            self.table_tags.hideColumn(17)

            self.table_drawings.setRowCount(len(results_drawings))
            tablerow=0

        # fill the Qt Table with the query results
            for row in results_drawings:
                for column in range(4):
                    value = row[column]
                    if value is None:
                        value = ''
                    it = QtWidgets.QTableWidgetItem(str(value))
                    it.setFlags(it.flags() & ~QtCore.Qt.ItemFlag.ItemIsEditable)
                    self.table_drawings.setItem(tablerow, column, it)

                tablerow+=1

            self.table_drawings.setItemDelegate(AlignDelegate(self.table_drawings))
            self.table_drawings.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
            # self.table_drawings.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.Interactive)
            # self.table_drawings.setColumnWidth(2, 200)
            self.table_drawings.setSortingEnabled(False)
            self.table_drawings.hideColumn(3)
            self.table_drawings.custom_sort_date(0, QtCore.Qt.SortOrder.AscendingOrder)

            self.table_calibrations.setRowCount(len(results_calibration))
            tablerow=0

        # fill the Qt Table with the query results
            for row in results_calibration:
                for column in range(4):
                    value = row[column]
                    if value is None:
                        value = ''
                    it = QtWidgets.QTableWidgetItem(str(value))
                    it.setFlags(it.flags() & ~QtCore.Qt.ItemFlag.ItemIsEditable)
                    self.table_calibrations.setItem(tablerow, column, it)

                tablerow+=1

            self.table_calibrations.setItemDelegate(AlignDelegate(self.table_calibrations))
            self.table_calibrations.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
            # self.table_calibrations.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.Interactive)
            # self.table_calibrations.setColumnWidth(2, 200)
            self.table_calibrations.setSortingEnabled(False)
            # self.table_calibrations.hideColumn(0)
            self.table_calibrations.custom_sort_date(1, QtCore.Qt.SortOrder.AscendingOrder)

        except (Exception, psycopg2.DatabaseError) as error:
            MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "critical")


# Function when header of different tables is clicked
    def on_header_section_clicked_tags(self, logical_index):
        """
        Handles the click event on the table header.
        Displays a context menu for unique values in the clicked column header.
        """
        header_pos = self.table_tags.horizontalHeader().sectionViewportPosition(logical_index)
        header_height = self.table_tags.horizontalHeader().height()
        popup_pos = self.table_tags.viewport().mapToGlobal(QtCore.QPoint(header_pos, header_height))
        self.table_tags.show_unique_values_menu(logical_index, popup_pos, header_height)

    def on_header_section_clicked_drawings(self, logical_index):
        """
        Handles the click event on the table header.
        Displays a context menu for unique values in the clicked column header.
        """
        header_pos = self.table_drawings.horizontalHeader().sectionViewportPosition(logical_index)
        header_height = self.table_drawings.horizontalHeader().height()
        popup_pos = self.table_drawings.viewport().mapToGlobal(QtCore.QPoint(header_pos, header_height))
        self.table_drawings.show_unique_values_menu(logical_index, popup_pos, header_height)

    def on_header_section_clicked_calibrations(self, logical_index):
        """
        Handles the click event on the table header.
        Displays a context menu for unique values in the clicked column header.
        """
        header_pos = self.table_calibrations.horizontalHeader().sectionViewportPosition(logical_index)
        header_height = self.table_calibrations.horizontalHeader().height()
        popup_pos = self.table_calibrations.viewport().mapToGlobal(QtCore.QPoint(header_pos, header_height))
        self.table_calibrations.show_unique_values_menu(logical_index, popup_pos, header_height)


# Functions to count selected cells of different tables
    def countSelectedCells_tags(self):
        """
        Counts the number of selected cells and sums their values of tags table. Updates the UI labels with the count and sum.
        """
        if len(self.table_tags.selectedIndexes()) > 1:
            locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
            self.label_SumItems_tags.setText("")
            self.label_SumValue_tags.setText("")
            self.label_CountItems_tags.setText("")
            self.label_CountValue_tags.setText("")

            sum_value = sum([(float(ix.data()) if (ix.data() is not None and ix.data().replace(',', '.', 1).replace('.', '', 1).isdigit() and ix.column() == 12) else 0) for ix in self.table_tags.selectedIndexes()])
            count_value = len([ix for ix in self.table_tags.selectedIndexes() if ix.data() != ""])
            if sum_value > 0:
                self.label_SumItems_tags.setText("Suma:")
                self.label_SumValue_tags.setText(locale.format_string("%.2f", sum_value, grouping=True))
            if count_value > 0:
                self.label_CountItems_tags.setText("Recuento:")
                self.label_CountValue_tags.setText(str(count_value))
        else:
            self.label_SumItems_tags.setText("")
            self.label_SumValue_tags.setText("")
            self.label_CountItems_tags.setText("")
            self.label_CountValue_tags.setText("")

    def countSelectedCells_drawings(self):
        """
        Counts the number of selected cells and sums their values of drawings table. Updates the UI labels with the count and sum.
        """
        if len(self.table_drawings.selectedIndexes()) > 1:
            locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
            self.label_SumItems_drawings.setText("")
            self.label_SumValue_drawings.setText("")
            self.label_CountItems_drawings.setText("")
            self.label_CountValue_drawings.setText("")

            sum_value = sum([(float(ix.data()) if (ix.data() is not None and ix.data().replace(',', '.', 1).replace('.', '', 1).isdigit() and ix.column() == 12) else 0) for ix in self.table_drawings.selectedIndexes()])
            count_value = len([ix for ix in self.table_drawings.selectedIndexes() if ix.data() != ""])
            if sum_value > 0:
                self.label_SumItems_drawings.setText("Suma:")
                self.label_SumValue_drawings.setText(locale.format_string("%.2f", sum_value, grouping=True))
            if count_value > 0:
                self.label_CountItems_drawings.setText("Recuento:")
                self.label_CountValue_drawings.setText(str(count_value))
        else:
            self.label_SumItems_drawings.setText("")
            self.label_SumValue_drawings.setText("")
            self.label_CountItems_drawings.setText("")
            self.label_CountValue_drawings.setText("")

    def countSelectedCells_calibration(self):
        """
        Counts the number of selected cells and sums their values of calibration table. Updates the UI labels with the count and sum.
        """
        if len(self.table_calibrations.selectedIndexes()) > 1:
            locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
            self.label_SumItems_calibration.setText("")
            self.label_SumValue_calibration.setText("")
            self.label_CountItems_calibration.setText("")
            self.label_CountValue_calibration.setText("")

            sum_value = sum([(float(ix.data()) if (ix.data() is not None and ix.data().replace(',', '.', 1).replace('.', '', 1).isdigit() and ix.column() == 12) else 0) for ix in self.table_calibrations.selectedIndexes()])
            count_value = len([ix for ix in self.table_calibrations.selectedIndexes() if ix.data() != ""])
            if sum_value > 0:
                self.label_SumItems_calibration.setText("Suma:")
                self.label_SumValue_calibration.setText(locale.format_string("%.2f", sum_value, grouping=True))
            if count_value > 0:
                self.label_CountItems_calibration.setText("Recuento:")
                self.label_CountValue_calibration.setText(str(count_value))
        else:
            self.label_SumItems_calibration.setText("")
            self.label_SumValue_calibration.setText("")
            self.label_CountItems_calibration.setText("")
            self.label_CountValue_calibration.setText("")

# Function to insert expedition data
    def expedition(self):
        """
        Updates the expedition data
        """
        if self.username in ['m.gil', 'e.munez']:
            num_order = self.numorder
            verif_date = date.today().strftime("%d/%m/%Y")
            verif_state = 'Realizado Por Mario'

            if num_order == "" or verif_date == "":
                MessageHelper.show_message("Rellene todos los campos. Solo el campo de observaciones puede quedar vaco", "Verificacin EXP", "warning")

            else:
                commands_select_exp = ("""
                            SELECT verif_exp_date, id
                            FROM verification."exp_verification"
                            WHERE "num_order" LIKE UPPER ('%%'||%s||'%%')
                            """)

                commands_insert_exp = ("""
                            UPDATE verification."exp_verification"
                            SET "verif_exp_date" = %s, "verif_exp_state" = %s, "verif_exp_obs" = %s
                            WHERE "id" = %s
                            """)
                conn = None
                try:
                    with Database_Connection(config_database()) as conn:
                        with conn.cursor() as cur:
                        # execution of commands
                            cur.execute(commands_select_exp, (num_order, ))
                            results = cur.fetchall()

                    if len(results) != 0:
                        if results[0][0] is None:
                            with Database_Connection(config_database()) as conn:
                                with conn.cursor() as cur:
                                    cur.execute(commands_insert_exp, (verif_date, verif_state, "Expedido", results[0][1], ))
                                conn.commit()

                        else:
                            if MessageHelper.ask_yes_no("Ya ha datos existentes en el aviso de expedicin\nDeseas sobreescribirlos?\n", "ERP EIPSA"):
                                with Database_Connection(config_database()) as conn:
                                    with conn.cursor() as cur:
                                        cur.execute(commands_insert_exp, (verif_date, verif_state, results[0][1], ))
                                    conn.commit()

                    else:
                        MessageHelper.show_message("No hay EXP creado para este pedido", "critical")

                except (Exception, psycopg2.DatabaseError) as error:
                    MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                                + str(error), "critical")

            self.query_data()

# Function when item of table is double clicked
    def item_double_click(self, item):
        """
        Opens detailed information when column is double-clicked.
        """
        if item.text() != '':
            if item.column() == 2: # Msgbox for tag
                cell_content = item.text()
                dlg = QtWidgets.QMessageBox()
                new_icon = QtGui.QIcon()
                new_icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                dlg.setWindowIcon(new_icon)
                dlg.setWindowTitle("Verificacin")
                dlg.setText(cell_content)
                dlg.exec()
                del dlg, new_icon

            elif item.column() == 3: # Msgbox for description
                cell_content = item.text()
                dlg = QtWidgets.QMessageBox()
                new_icon = QtGui.QIcon()
                new_icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                dlg.setWindowIcon(new_icon)
                dlg.setWindowTitle("Verificacin")
                dlg.setText(cell_content)
                dlg.exec()
                del dlg, new_icon

            elif item.column() == 15: # Open image
                item_id = self.table_tags.item(item.row(), 0).text()
                table_name = self.table_tags.item(item.row(), 16).text()
                column_id = self.table_tags.item(item.row(), 17).text()

                query_path =f"SELECT tag_images FROM {table_name} WHERE {column_id} = {item_id}"

                try:
                    with Database_Connection(config_database()) as conn:
                        with conn.cursor() as cur:
                        # execution of commands
                            cur.execute(query_path)
                            results=cur.fetchall()

                    file_path = os.path.normpath(results[0][0])
                    os.startfile(file_path)

                except (Exception, psycopg2.DatabaseError) as error:
                    MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "critical")

            elif item.column() == 8: # Msgbox for hydraulic test 1
                item_id = self.table_tags.item(item.row(), 0).text()
                table_name = self.table_tags.item(item.row(), 16).text()
                column_id = self.table_tags.item(item.row(), 17).text()

                query =f"SELECT tag, TO_CHAR(ph1_date, 'DD/MM/YYYY'), ph1_manometer, ph1_pressure, ph1_obs FROM {table_name} WHERE {column_id} = {item_id}"

                try:
                    with Database_Connection(config_database()) as conn:
                        with conn.cursor() as cur:
                        # execution of commands
                            cur.execute(query)
                            results=cur.fetchall()

                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("Prueba Hidrosttica 1")
                    dlg.setText("TAG: " + results[0][0] + "\n"
                                "Fecha: " + results[0][1] + "\n\n"
                                "Manmetro: " + results[0][2] + "\n"
                                "Presin: " + results[0][3] + "\n"
                                "Obs.: " + results[0][4])
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Information)
                    dlg.exec()
                    del dlg, new_icon

                except (Exception, psycopg2.DatabaseError) as error:
                    MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "critical")

            elif item.column() == 9: # Msgbox for hydraulic test 2
                item_id = self.table_tags.item(item.row(), 0).text()
                table_name = self.table_tags.item(item.row(), 16).text()
                column_id = self.table_tags.item(item.row(), 17).text()

                query =f"SELECT tag, TO_CHAR(ph2_date, 'DD/MM/YYYY'), ph2_manometer, ph2_pressure, ph2_obs FROM {table_name} WHERE {column_id} = {item_id}"

                try:
                    with Database_Connection(config_database()) as conn:
                        with conn.cursor() as cur:
                        # execution of commands
                            cur.execute(query)
                            results=cur.fetchall()

                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("Prueba Hidrosttica 2")
                    dlg.setText("TAG: " + results[0][0] + "\n"
                                "Fecha: " + results[0][1] + "\n\n"
                                "Manmetro: " + results[0][2] + "\n"
                                "Presin: " + results[0][3] + "\n"
                                "Obs.: " + results[0][4])
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Information)
                    dlg.exec()
                    del dlg, new_icon

                except (Exception, psycopg2.DatabaseError) as error:
                    MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "critical")

            elif item.column() == 10: # Msgbox for liquid test
                item_id = self.table_tags.item(item.row(), 0).text()
                table_name = self.table_tags.item(item.row(), 16).text()
                column_id = self.table_tags.item(item.row(), 17).text()

                query =f"SELECT tag, TO_CHAR(lp_date, 'DD/MM/YYYY'), lp_hn_liq1, lp_hn_liq2, lp_hn_liq3, lp_obs, lp_state FROM {table_name} WHERE {column_id} = {item_id}"

                conn = None
                try:
                    with Database_Connection(config_database()) as conn:
                        with conn.cursor() as cur:
                        # execution of commands
                            cur.execute(query)
                            results=cur.fetchall()

                    dlg = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(str(get_path("Resources", "Iconos", "icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg.setWindowIcon(new_icon)
                    dlg.setWindowTitle("Lquidos Penetrantes")
                    dlg.setText("TAG: " + results[0][0] + "\n"
                                "Fecha: " + results[0][1] + "\n\n"
                                "9PR5: " + results[0][2] + "\n"
                                "9D1B: " + results[0][3] + "\n"
                                "996PB: " + results[0][4] + "\n"
                                + results[0][6] + "\n"
                                "Obs.: " + results[0][5])
                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Information)
                    dlg.exec()
                    del dlg, new_icon

                except (Exception, psycopg2.DatabaseError) as error:
                    MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "critical")

            elif item.column() == 1 and item.text() == 'PPI':
                self.num_order_value = self.numorder
                order_year = str(datetime.now().year)[:2] + self.num_order_value [self.num_order_value .rfind("/") - 2:self.num_order_value .rfind("/")]

                if self.num_order_value[:2] == 'PA':
                    num_order = self.num_order_value
                    path = "//ERP-EIPSA-DATOS/base de datos de pedidos/Ao " + order_year + "/" + order_year + " Pedidos Almacen"
                    for folder in os.listdir(path):
                        if num_order.replace("/", "-") in folder:
                            folder_path = "//ERP-EIPSA-DATOS/base de datos de pedidos/Ao " + order_year + "/" + order_year + " Pedidos Almacen/" + folder + "/"
                            for root, dirs, files in os.walk(folder_path):
                                for filename in files:
                                    if fnmatch.fnmatch(filename, '*-PPI*'):
                                        file_path = os.path.join(root, filename)
                                        file_path = os.path.normpath(file_path)
                                        os.startfile(file_path)

                elif self.num_order_value[:2] == 'P-':
                    num_order = self.num_order_value[:8]
                    path = "//ERP-EIPSA-DATOS/base de datos de pedidos/Ao " + order_year + "/" + order_year + " Pedidos"
                    for folder in os.listdir(path):
                        if num_order.replace("/", "-") in folder:
                            folder_path = "//ERP-EIPSA-DATOS/base de datos de pedidos/Ao " + order_year + "/" + order_year + " Pedidos/" + folder + "/"
                            for root, dirs, files in os.walk(folder_path):
                                for filename in files:
                                    if fnmatch.fnmatch(filename, '*-PPI*'):
                                        file_path = os.path.join(root, filename)
                                        file_path = os.path.normpath(file_path)
                                        os.startfile(file_path)

# Function to notify
    def notify(self):
        num_order = self.numorder
        actual_date=date.today()
        actual_date= actual_date.strftime("%d/%m/%Y")

        try:
            with Database_Connection(config_database()) as conn:
                with conn.cursor() as cur:
                    commands_notification_neworder = ("""INSERT INTO notifications.notifications_orders (
                                            "username","message","state","date_creation"
                                            )
                                            VALUES (%s,%s,%s,%s)
                                            """)

                    commands_select_exp = ("""
                                    SELECT verif_exp_date, id
                                    FROM verification."exp_verification"
                                    WHERE "num_order" LIKE UPPER ('%%'||%s||'%%')
                                    """)

                    commands_insert_exp = ("""
                                    UPDATE verification."exp_verification"
                                    SET "verif_exp_obs" = %s
                                    WHERE "id" = %s
                                    """)

                    data = ('m.sahuquillo', "Pedido " + self.numorder + " Completado\nGenerar Expedicin", "Pendiente", actual_date)
                    cur.execute(commands_notification_neworder, data)

                    data_2 = ('m.gil', "Pedido " + self.numorder + " Completado\nExpedicin Avisada", "Pendiente", actual_date)
                    cur.execute(commands_notification_neworder, data_2)

                    cur.execute(commands_select_exp, (num_order, ))
                    results = cur.fetchall()

                    if len(results) != 0:
                        if results[0][0] is None:
                            cur.execute(commands_insert_exp, ("Avisado", results[0][1], ))

            # commit the changes
                conn.commit()

            MessageHelper.show_message("Aviso Enviado", "info")

        except (Exception, psycopg2.DatabaseError) as error:
            MessageHelper.show_message("Ha ocurrido el siguiente error:\n"
                        + str(error), "critical")


if __name__ == "__main__":
    import sys
    import os

    ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    if ROOT not in sys.path:
        sys.path.insert(0, ROOT)
    app = QtWidgets.QApplication(sys.argv)
    Verif_Order_Window = Ui_Verif_Order_Window('m.gil','PA-25/049')
    Verif_Order_Window.show()
    sys.exit(app.exec())
