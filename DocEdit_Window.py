# Form implementation generated from reading ui file 'EditDocs_Commercial_Window.ui'
#
# Created by: PyQt6 UI code generator 6.4.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6 import QtSql
import re
import configparser
import locale
from utils.Database_Manager import Create_DBconnection
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QKeySequence, QTextDocument, QTextCursor
from PyQt6.QtWidgets import QApplication
import os
from config import config
import pandas as pd
import psycopg2
from tkinter.filedialog import askopenfilename

basedir = r"\\ERP-EIPSA-DATOS\DATOS\Comunes\EIPSA-ERP"


def imagen_to_base64(imagen):
    """
    Converts an image in PNG format to a base64 encoded string.

    Args:
        imagen: An instance of QImage or QPixmap to be converted.
    Return: 
        A base64 encoded string representing the image in PNG format.
    """
    buffer = QtCore.QBuffer()
    buffer.open(QtCore.QIODevice.OpenModeFlag.WriteOnly)
    imagen.save(buffer, ".png")
    base64_data = buffer.data().toBase64().data().decode()
    return base64_data

class AlignDelegate(QtWidgets.QStyledItemDelegate):
    """
    A custom item delegate for aligning cell content in a QTableView or QTableWidget to the center.

    Inherits from:
        QtWidgets.QStyledItemDelegate: Provides custom rendering and editing for table items.

    """
    def initStyleOption(self, option, index):
        """
        Initializes the style option for the item, setting its display alignment to center.

        Args:
            option (QtWidgets.QStyleOptionViewItem): The style option to initialize.
            index (QtCore.QModelIndex): The model index of the item.
        """
        super(AlignDelegate, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

class EditableComboBoxDelegate(QtWidgets.QStyledItemDelegate):
    """
    A delegate for editing combobox items in a view.

    Attributes:
        options (list): List of options to populate the combobox.
    """
    def __init__(self, parent=None, options=None):
        """
        Initializes the EditableComboBoxDelegate with the specified options.

        Args:
            parent (QtWidgets.QWidget, optional): Parent widget.
            options (list, optional): List of options for the combobox.
        """
        super().__init__(parent)
        self.options = options

    def createEditor(self, parent, option, index):
        """
        Creates an editor for the combobox.

        Args:
            parent (QtWidgets.QWidget): Parent widget.
            option (QtWidgets.QStyleOptionViewItem): Style options for the item.
            index (QtCore.QModelIndex): Index of the item in the model.

        Returns:
            QtWidgets.QComboBox: The created combobox editor.
        """
        editor = QtWidgets.QComboBox(parent)
        editor.setEditable(True)
        return editor

    def setEditorData(self, editor, index):
        """
        Sets the data for the combobox editor.

        Args:
            editor (QtWidgets.QComboBox): The combobox editor.
            index (QtCore.QModelIndex): Index of the item in the model.
        """
        text = index.data(Qt.ItemDataRole.DisplayRole)
        editor.addItems(self.options)
        editor.setEditText(text)

    def setModelData(self, editor, model, index):
        """
        Updates the model with the data from the combobox editor.

        Args:
            editor (QtWidgets.QComboBox): The combobox editor.
            model (QtGui.QAbstractItemModel): The model to update.
            index (QtCore.QModelIndex): Index of the item in the model.
        """
        model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)

    def paint(self, painter, option, index):
        """
        Custom paint method to render the cell content and apply background colors 
        based on specific conditions for a column's value.

        Args:
            painter (QPainter): The painter used to render the cell.
            option (QStyleOptionViewItem): The style options for the cell.
            index (QModelIndex): The index of the cell being painted.
        """
        text = index.data(Qt.ItemDataRole.DisplayRole)

        if text in ["Eliminado", "Rechazado"]:
            background_color = QtGui.QColor(255, 0, 0)  # Red
        elif text == "Aprobado":
            background_color = QtGui.QColor(0, 176, 80)  # Green
        else:
            background_color = QtGui.QColor(255, 255, 255)  # White

        painter.fillRect(option.rect, background_color)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter
        super().paint(painter, option, index)

# class CustomProxyModel(QtCore.QSortFilterProxyModel):
#     """
#     A custom proxy model that filters table rows based on expressions set for specific columns.

#     Attributes:
#         _filters (dict): A dictionary to store filter expressions for columns.
#         header_names (dict): A dictionary to store header names for the table.

#     Properties:
#         filters: Getter for the current filter dictionary.

#     """
#     def __init__(self, parent=None):
#         """
#         Get the current filter expressions applied to columns.

#         Returns:
#             dict: Dictionary of column filters.
#         """
#         super().__init__(parent)
#         self._filters = dict()
#         self.header_names = {}

#     @property
#     def filters(self):
#         """
#         Get the current filter expressions applied to columns.

#         Returns:
#             dict: Dictionary of column filters.
#         """
#         return self._filters

#     def setFilter(self, list_expresions, column, action_name=None):
#         """
#         Apply a filter expression to a specific column, or remove it if necessary.

#         Args:
#             expresion (str): The filter expression.
#             column (int): The index of the column to apply the filter to.
#             action_name (str, optional): Name of the action, can be empty. Defaults to None.
#         """
#         for expresion in list_expresions:
#             if expresion or expresion == '':
#                 if column in self.filters:
#                     if action_name or action_name == '':
#                         self.filters[column].remove(expresion)
#                     else:
#                         self.filters[column].append(expresion)
#                 else:
#                     self.filters[column] = [expresion]
#             elif column in self.filters:
#                 if action_name or action_name == '':
#                     self.filters[column].remove(expresion)
#                     if not self.filters[column]:
#                         del self.filters[column]
#                 else:
#                     del self.filters[column]
#         self.invalidateFilter()


#     def filterAcceptsRow(self, source_row, source_parent):
#         """
#         Check if a row passes the filter criteria based on the column filters.

#         Args:
#             source_row (int): The row number in the source model.
#             source_parent (QModelIndex): The parent index of the row.

#         Returns:
#             bool: True if the row meets the filter criteria, False otherwise.
#         """
#         for column, expresions in self.filters.items():
#             text = self.sourceModel().index(source_row, column, source_parent).data()

#             if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
#                 text = text.toString("yyyy-MM-dd")

#             for expresion in expresions:
#                 if expresion == '':  # Si la expresión es vacía, coincidir con celdas vacías
#                     if text == '':
#                         break

#                 elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', str(expresion)):
#                     expresion = QtCore.QDate.fromString(expresion, "dd/MM/yyyy")
#                     expresion = expresion.toString("yyyy-MM-dd")
#                     regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
#                     if regex.match(str(text)).hasMatch():
#                         break

#                 else:
#                     regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
#                     if regex.match(str(text)).hasMatch():
#                         break
#             else:
#                 return False
#         return True

# class EditableTableModel(QtSql.QSqlTableModel):
#     """
#     A custom SQL table model that supports editable columns, headers, and special flagging behavior based on user permissions.

#     Signals:
#         updateFailed (str): Signal emitted when an update to the model fails.
#     """
#     updateFailed = QtCore.pyqtSignal(str)
#     def __init__(self, parent=None):
#         """
#         Initialize the model with user permissions
#         """
#         super().__init__(parent)
#         self.originalData = {}
#         self.relations={}

#     def setAllColumnHeaders(self, headers):
#         """
#         Set headers for all columns in the model.

#         Args:
#             headers (list): A list of header names.
#         """
#         for column, header in enumerate(headers):
#             self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

#     def setIndividualColumnHeader(self, column, header):
#         """
#         Set the header for a specific column.

#         Args:
#             column (int): The column index.
#             header (str): The header name.
#         """
#         self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

#     def setIconColumnHeader(self, column, icon):
#         """
#         Set an icon in the header for a specific column.

#         Args:
#             column (int): The column index.
#             icon (QIcon): The icon to display in the header.
#         """
#         self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

#     def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
#         """
#         Retrieve the header data for a specific section of the model.

#         Args:
#             section (int): The section index (column or row).
#             orientation (Qt.Orientation): The orientation (horizontal or vertical).
#             role (Qt.ItemDataRole, optional): The role for the header data. Defaults to DisplayRole.

#         Returns:
#             QVariant: The header data for the specified section.
#         """
#         if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
#             return super().headerData(section, orientation, role)
#         return super().headerData(section, orientation, role)

#     def flags(self, index):
#         """
#         Get the item flags for a given index, controlling editability and selection based on user permissions.

#         Args:
#             index (QModelIndex): The index of the item.

#         Returns:
#             Qt.ItemFlags: The flags for the specified item.
#         """
#         flags = super().flags(index)
#         return flags | QtCore.Qt.ItemFlag.ItemIsEditable

class CustomProxyModel(QtCore.QSortFilterProxyModel):
    """
    A custom proxy model that filters table rows based on expressions set for specific columns.
    """
    def __init__(self, column_display_mapping, parent=None):
        super().__init__(parent)
        self.column_display_mapping = column_display_mapping 
        self._filters = dict()
        self.header_names = {}

    @property
    def filters(self):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        return self._filters

    def setFilter(self, expresion, column, action_name=None, exact_match=False):
        """
        Apply a filter expression to a specific column, or remove it if necessary.

        Args:
            expresion (str): The filter expression.
            column (int): The index of the column to apply the filter to.
            action_name (str, optional): Name of the action, can be empty. Defaults to None.
            exact_match (bool, optional): If True, use exact matching for the filter. Defaults to False.
        """
        if expresion or expresion == '':
            if column in self.filters:
                if action_name or action_name == '':
                    self.filters[column].remove(expresion)
                else:
                    self.filters[column].append((expresion, exact_match))
            else:
                self.filters[column] = [(expresion, exact_match)]
        elif column in self.filters:
            if action_name or action_name == '':
                self.filters[column].remove(expresion)
                if not self.filters[column]:
                    del self.filters[column]
            else:
                del self.filters[column]
        self.invalidateFilter()


    def filterAcceptsRow(self, source_row, source_parent):
        """
        Check if a row passes the filter criteria based on the column filters.

        Args:
            source_row (int): The row number in the source model.
            source_parent (QModelIndex): The parent index of the row.

        Returns:
            bool: True if the row meets the filter criteria, False otherwise.
        """
        for column, expresions in self.filters.items():
            text = self.sourceModel().index(source_row, column, source_parent).data()

            if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
                text = text.toString("yyyy-MM-dd")

            match_found = False 

            for expresion, exact_match in expresions:
                if expresion == '':  # If expression is empty, match empty cells
                    if text == '':
                        break

                if exact_match:
                    if re.fullmatch(r'^\d{4}([\-/.])(0[1-9]|1[0-2])\1(3[01]|[12][0-9]|0[1-9])$', text):
                        text = QtCore.QDate.fromString(text, "yyyy-MM-dd")
                        text = text.toString("dd/MM/yyyy")

                    if text in expresion:  # Verificar si `text` está en la lista `expresion`
                        match_found = True
                        break
                
                elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', expresion[0]):
                    expresion = QtCore.QDate.fromString(expresion[0], "dd/MM/yyyy")
                    expresion = expresion.toString("yyyy-MM-dd")
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

                else:
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion[0]))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        match_found = True
                        break

            if not match_found:
                return False
        return True


    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        """
        Override the data method to handle relational columns correctly when using a QSortFilterProxyModel.

        Args:
            index (QModelIndex): The index in the source model.
            role (Qt.ItemDataRole): The role for which data is requested.

        Returns:
            QVariant: The data for the given role and index, with support for relational columns.
        """
        # Get the source model (assumed to be QSqlRelationalTableModel)
        source_model = self.sourceModel()

        if isinstance(source_model, QtSql.QSqlRelationalTableModel):
            # Check if the column has a relation
            relation = source_model.relation(index.column())
            if relation.isValid() and role == Qt.ItemDataRole.DisplayRole:
                # Get the related model for the column
                related_model = source_model.relationModel(index.column())

                # Get the related index using the value from the source model's column
                related_value = source_model.data(source_model.index(index.row(), index.column()), Qt.ItemDataRole.EditRole)

                # Get the column index to display from the mapping
                display_column_index = self.column_display_mapping.get(index.column())

                if display_column_index is not None:
                    # Look up the related display value using the mapped display_column_index
                    related_index = related_model.match(
                        related_model.index(0, 0),  # Match the first column (id column)
                        Qt.ItemDataRole.EditRole, 
                        related_value, 
                        1,  # Only one match expected
                        QtCore.Qt.MatchFlag.MatchExactly
                    )

                    if related_index:
                        return related_model.data(related_model.index(related_index[0].row(), display_column_index), role)

        # Fall back to the default behavior if it's not a relational column
        return super().data(index, role)


class EditableTableModel(QtSql.QSqlRelationalTableModel):
    """
    A custom SQL table model that supports editable columns, headers, and special flagging behavior based on user permissions.

    Signals:
        updateFailed (str): Signal emitted when an update to the model fails.
    """
    updateFailed = QtCore.pyqtSignal(str)

    def __init__(self, parent=None, column_range=None, database=None):
        """
        Initialize the model with user permissions and optional database and column range.

        Args:
            parent (QObject, optional): Parent object for the model. Defaults to None.
            column_range (list, optional): A list specifying the range of columns. Defaults to None.
        """
        super().__init__(parent, database)
        self.column_range = column_range

    def setQuery(self, query):
        """
        Set the SQL query for the model.

        Args:
            query (QSqlQuery): The query to populate the model.
        """
        super().setQuery(query)

    def setAllColumnHeaders(self, headers):
        """
        Set headers for all columns in the model.

        Args:
            headers (list): A list of header names.
        """
        for column, header in enumerate(headers):
            self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIndividualColumnHeader(self, column, header):
        """
        Set the header for a specific column.

        Args:
            column (int): The column index.
            header (str): The header name.
        """
        self.setHeaderData(column, Qt.Orientation.Horizontal, header, Qt.ItemDataRole.DisplayRole)

    def setIconColumnHeader(self, column, icon):
        """
        Set an icon in the header for a specific column.

        Args:
            column (int): The column index.
            icon (QIcon): The icon to display in the header.
        """
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, Qt.ItemDataRole.DecorationRole)

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        """
        Retrieve the header data for a specific section of the model.

        Args:
            section (int): The section index (column or row).
            orientation (Qt.Orientation): The orientation (horizontal or vertical).
            role (Qt.ItemDataRole, optional): The role for the header data. Defaults to DisplayRole.

        Returns:
            QVariant: The header data for the specified section.
        """
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return super().headerData(section, orientation, role)
        return super().headerData(section, orientation, role)

    def flags(self, index):
        """
        Get the item flags for a given index, controlling editability and selection based on user permissions.

        Args:
            index (QModelIndex): The index of the item.

        Returns:
            Qt.ItemFlags: The flags for the specified item.
        """
        flags = super().flags(index)
        if index.column() in [0]:
                flags &= ~Qt.ItemFlag.ItemIsEditable
                return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        else:
            return flags | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsEditable

    def getColumnHeaders(self, visible_columns):
        """
        Retrieve the headers for the specified visible columns.

        Args:
            visible_columns (list): List of column indices that are visible.

        Returns:
            list: A list of column headers for the visible columns.
        """
        column_headers = [self.headerData(col, Qt.Orientation.Horizontal) for col in visible_columns]
        return column_headers


class ComboBoxDelegate_Relational(QtSql.QSqlRelationalDelegate):
    def __init__(self, column_to_display, parent=None):
        """
        Initializes the delegate with index column to be displayed in QComboBox

        Args:
            column_to_display (int): Index column to be displayed in QComboBox
            parent (QWidget, optional): Parent Widget. Defaults to None.
        """
        super().__init__(parent)
        self.column_to_display = column_to_display

    def createEditor(self, parent, option, index):
        """
        Create the editor for a relational column, typically a QComboBox.

        Args:
            parent (QWidget): The parent widget.
            option (QStyleOptionViewItem): The option for the item.
            index (QModelIndex): The index of the item being edited.

        Returns:
            QWidget: The editor widget, a QComboBox for relational columns.
        """
        combo_box = QtWidgets.QComboBox(parent)

        # Obtain model from index
        source_model = index.model().sourceModel()
        
        # Checking relational model
        if isinstance(source_model, QtSql.QSqlRelationalTableModel):
            # Establish relational model
            relation_model = source_model.relationModel(index.column())
            if relation_model:
                # Fill combobox
                for row in range(relation_model.rowCount()):
                    combo_box.addItem(relation_model.data(relation_model.index(row, self.column_to_display)),  # display name
                    relation_model.data(relation_model.index(row, 0)))  # Store ID

        return combo_box

    def setModelData(self, editor, model, index):
        """
        Set the model data from the editor.

        Args:
            editor (QWidget): The editor widget (QComboBox for relational columns).
            model (QAbstractItemModel): The model to update.
            index (QModelIndex): The index in the model to update.
        """
        # Get the source model from the proxy
        if isinstance(model, QtCore.QSortFilterProxyModel):
            source_index = model.mapToSource(index)  # Mapea al índice fuente
            source_model = model.sourceModel()
        else:
            source_index = index
            source_model = model

        selected_foreign_key = editor.currentData()

        # Update source model
        success = source_model.setData(source_index, selected_foreign_key, Qt.ItemDataRole.EditRole)

        # Confirm changes
        if isinstance(source_model, QtSql.QSqlRelationalTableModel):
            if source_model.submitAll():
                print("Changes saved to database")
            else:
                print("Failed to save changes to database")

        # Invalidate filter to update view
        if isinstance(model, QtCore.QSortFilterProxyModel):
            model.invalidateFilter()

class Ui_EditDoc_Window(QtWidgets.QMainWindow):
    """
    A window for editing technical tags in the application.

    Attributes:
        model (EditableTableModel): The data model for the table.
        proxy (CustomProxyModel): The proxy model for filtering and sorting.
        db (object): Database connection.
        checkbox_states (dict): States of checkboxes.
        dict_valuesuniques (dict): Unique values for columns.
        dict_ordersort (dict): Sorting order for columns.
        hiddencolumns (list): List of hidden column indices.
        action_checkbox_map (dict): Map of actions to checkboxes.
        checkbox_filters (dict): Filters based on checkbox states.
    """
    def __init__(self, db):
        """
        Initializes the Ui_EditDoc_Window with the specified name and database connection.

        Args:
            db (object): Database connection.
        """
        super().__init__()
        self.db = db
        self.column_display_mapping = {4: 1}
        self.model = EditableTableModel(database=db)
        self.proxy = CustomProxyModel(self.column_display_mapping,self)
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.action_checkbox_map = {}
        self.checkbox_filters = {}
        self.hiddencolumns = []
        self.model.dataChanged.connect(self.saveChanges)
        self.setupUi(self)

    def closeEvent(self, event):
        """
        Handles the event triggered when the window is closed. Ensures models are cleared and database connections are closed.

        Args:
            event (QCloseEvent): The close event triggered when the window is about to close.
        """
        if self.model:
            self.model.clear()
        self.closeConnection()

    def closeConnection(self):
        """
        Closes the database connection and clears any references to the models.
        Also removes the 'drawing_index' database connection from Qt's connection list if it exists.
        """
        self.tableEditDocs.setModel(None)
        del self.model
        if self.db:
            self.db.close()
            del self.db
            if QtSql.QSqlDatabase.contains("qt_sql_default_connection"):
                QtSql.QSqlDatabase.removeDatabase("qt_sql_default_connection")

    def setupUi(self, EditDocs_Window):
        """
        Sets up the user interface for the EditDocs_Window.

        Args:
            EditDocs_Window (QtWidgets.QMainWindow): The main window for the UI setup.
        """
        EditDocs_Window.setObjectName("EditDocs_Window")
        EditDocs_Window.resize(790, 595)
        EditDocs_Window.setMinimumSize(QtCore.QSize(900, 595))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        EditDocs_Window.setWindowIcon(icon)
        EditDocs_Window.setStyleSheet(
".QFrame {\n"
"    border: 2px solid black;\n"
"}")
        self.centralwidget = QtWidgets.QWidget(parent=EditDocs_Window)
        self.centralwidget.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_2.setVerticalSpacing(10)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.hcab=QtWidgets.QHBoxLayout()
        self.hcab.setObjectName("hcab")
        self.toolDeleteFilter = QtWidgets.QToolButton(self.frame)
        self.toolDeleteFilter.setObjectName("Delete_Filters")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Delete.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolDeleteFilter.setIcon(icon)
        self.toolDeleteFilter.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolDeleteFilter)
        self.hcabspacer3=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer3)
        self.toolShow = QtWidgets.QToolButton(self.frame)
        self.toolShow.setObjectName("Show_Button")
        self.toolShow.setToolTip("Mostrar columnas")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Eye.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolShow.setIcon(icon)
        self.toolShow.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolShow)
        self.hcabspacer4=QtWidgets.QSpacerItem(10, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer4)
        self.toolUpdateExcel = QtWidgets.QToolButton(self.frame)
        self.toolUpdateExcel.setObjectName("Update_Excel")
        self.toolUpdateExcel.setToolTip("Actualizar con Excel")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Update_Excel.png"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        self.toolUpdateExcel.setIcon(icon)
        self.toolUpdateExcel.setIconSize(QtCore.QSize(25, 25))
        self.hcab.addWidget(self.toolUpdateExcel)
        self.hcabspacer2=QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hcab.addItem(self.hcabspacer2)
        self.gridLayout_2.addLayout(self.hcab, 0, 0, 1, 1)
        self.hLayout = QtWidgets.QHBoxLayout()
        self.hLayout.setObjectName("hLayout")
        self.Button_All = QtWidgets.QPushButton(parent=self.frame)
        self.Button_All.setMinimumSize(QtCore.QSize(150, 35))
        self.Button_All.setMaximumSize(QtCore.QSize(150, 35))
        self.Button_All.setFocusPolicy(QtCore.Qt.FocusPolicy.NoFocus)
        self.Button_All.setObjectName("Button_All")
        self.Button_All.setStyleSheet("QPushButton{\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 8px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        self.hLayout.addWidget(self.Button_All)
        self.gridLayout_2.addLayout(self.hLayout, 1, 0, 1, 1)
        self.tableEditDocs=QtWidgets.QTableView(parent=self.frame)
        self.tableEditDocs.setObjectName("tableEditDocs")
        self.gridLayout_2.addWidget(self.tableEditDocs, 2, 0, 1, 1)
        self.hLayout3 = QtWidgets.QHBoxLayout()
        self.hLayout3.setObjectName("hLayout3")
        spacerItem2 = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.hLayout3.addItem(spacerItem2)
        self.label_SumItems = QtWidgets.QLabel(parent=self.frame)
        self.label_SumItems.setMinimumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setMaximumSize(QtCore.QSize(40, 10))
        self.label_SumItems.setText("")
        self.label_SumItems.setObjectName("label_SumItems")
        self.hLayout3.addWidget(self.label_SumItems)
        self.label_SumValue = QtWidgets.QLabel(parent=self.frame)
        self.label_SumValue.setMinimumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setMaximumSize(QtCore.QSize(80, 20))
        self.label_SumValue.setText("")
        self.label_SumValue.setObjectName("label_SumValue")
        self.hLayout3.addWidget(self.label_SumValue)
        self.label_CountItems = QtWidgets.QLabel(parent=self.frame)
        self.label_CountItems.setMinimumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setMaximumSize(QtCore.QSize(60, 10))
        self.label_CountItems.setText("")
        self.label_CountItems.setObjectName("label_CountItems")
        self.hLayout3.addWidget(self.label_CountItems)
        self.label_CountValue = QtWidgets.QLabel(parent=self.frame)
        self.label_CountValue.setMinimumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setMaximumSize(QtCore.QSize(80, 10))
        self.label_CountValue.setText("")
        self.label_CountValue.setObjectName("label_CountValue")
        self.hLayout3.addWidget(self.label_CountValue)
        self.gridLayout_2.addLayout(self.hLayout3, 4, 0, 1, 1)
        spacerItem = QtWidgets.QSpacerItem(20, 10, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 0, 0, 1, 1)
        self.gridLayout.addWidget(self.frame, 0, 0, 1, 1)
        EditDocs_Window.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=EditDocs_Window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 790, 22))
        self.menubar.setObjectName("menubar")
        EditDocs_Window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=EditDocs_Window)
        self.statusbar.setObjectName("statusbar")
        EditDocs_Window.setStatusBar(self.statusbar)

        self.retranslateUi(EditDocs_Window)
        QtCore.QMetaObject.connectSlotsByName(EditDocs_Window)

        self.model.dataChanged.connect(self.saveChanges)
        self.query_documents()
        self.toolDeleteFilter.clicked.connect(self.delete_allFilters)
        self.toolShow.clicked.connect(self.show_columns)
        self.toolUpdateExcel.clicked.connect(self.update_documents)
        self.Button_All.clicked.connect(self.query_all_documents)

        self.createContextMenu()

# Function to translate and updates the text of various UI elements
    def retranslateUi(self, EditDocs_Window):
        """
        Translates and updates the text of various UI elements.
        """
        _translate = QtCore.QCoreApplication.translate
        self.Button_All.setText(_translate("EditDocs_Window", "Ver Todos"))
        EditDocs_Window.setWindowTitle(_translate("EditDocs_Window", "Editar Documentos"))
        self.tableEditDocs.setSortingEnabled(True)

# Function to delete all filters when tool button is clicked
    def delete_allFilters(self):
        """
        Resets all filters and updates the table model with unique values for each column.
        """
        columns_number=self.model.columnCount()
        for index in range(columns_number):
            if index in self.proxy.filters:
                del self.proxy.filters[index]
            self.model.setIconColumnHeader(index, '')

        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.checkbox_filters = {}

        self.proxy.invalidateFilter()
        # self.tableEditDocs.setModel(None)
        self.tableEditDocs.setModel(self.proxy)

        # Getting the unique values for each column of the model
        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            if column not in self.checkbox_states:
                self.checkbox_states[column] = {}
                self.checkbox_states[column]['Seleccionar todo'] = True
                for row in range(self.model.rowCount()):
                    value = self.model.record(row).value(column)
                    if value not in list_valuesUnique:
                        if isinstance(value, QtCore.QDate):
                            value=value.toString("dd/MM/yyyy")
                        list_valuesUnique.append(str(value))
                        self.checkbox_states[column][value] = True
                self.dict_valuesuniques[column] = list_valuesUnique

        self.tableEditDocs.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(1,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function to save changes into database
    def saveChanges(self, topLeft, bottomRight):
        """
        Saves changes made to the data models and updates unique values for each column.
        """
        if topLeft == bottomRight:
            # self.model.submitAll()
            self.model.submit()

            for column in range(self.model.columnCount()):
                list_valuesUnique = []
                for row in range(self.model.rowCount()):
                    value = self.model.record(row).value(column)
                    if value not in list_valuesUnique:
                        if isinstance(value, QtCore.QDate):
                            value=value.toString("dd/MM/yyyy")
                        list_valuesUnique.append(str(value))
                        if value not in self.checkbox_states[column]:
                            self.checkbox_states[column][value] = True
                self.dict_valuesuniques[column] = list_valuesUnique

# Function to query documents data into table
    def query_documents(self):
        """
        Queries the database for filtered documents, configures and populates tables with the query results, 
        and updates the UI accordingly. Handles potential database errors and updates the UI with appropriate messages.
        """
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.action_checkbox_map = {}
        self.checkbox_filters = {}
        self.hiddencolumns = []

        self.model.dataChanged.disconnect(self.saveChanges)
        self.model.clear()
        self.model.setTable("documentation")
        self.tableEditDocs.setModel(None)
        self.model.setFilter(f"state NOT IN ('Aprobado', 'Eliminado')")
        self.model.setRelation(4, QtSql.QSqlRelation("document_type", "id", "doc_type"))
        self.model.select()

        self.proxy.setSourceModel(self.model)
        self.tableEditDocs.setModel(self.proxy)

        # self.tableEditDocs.verticalHeader().hide()
        self.tableEditDocs.setItemDelegate(AlignDelegate(self.tableEditDocs))
        self.tableEditDocs.setItemDelegateForColumn(4,ComboBoxDelegate_Relational(1,self.tableEditDocs))
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(1,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)
        self.tableEditDocs.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")
        self.tableEditDocs.setObjectName("tableEditDocs")
        self.gridLayout_2.addWidget(self.tableEditDocs, 3, 0, 1, 1)
        self.tableEditDocs.setSortingEnabled(False)
        self.tableEditDocs.horizontalHeader().sectionClicked.connect(self.on_view_horizontalHeader_sectionClicked)

        # Change all column names
        headers = ["Nº Doc. EIPSA", "Nº Doc. Cliente", "Nº Pedido", "Título", "Tipo Doc.", "Crítico", "Nº Revisión", "Fecha Estado", "Estado", "Seguimiento", "Fecha Primera Rev", "Info/Review", "Doc. Resp.", "Días"]
        self.model.setAllColumnHeaders(headers)

        self.combo_itemtype = EditableComboBoxDelegate(self.tableEditDocs, sorted(['Aprobado','Comentado','Com. Mayores','Com. Menores','Eliminado','Enviado','HOLD', 'Información', 'Rechazado']))
        self.tableEditDocs.setItemDelegateForColumn(8, self.combo_itemtype)

    # Getting the unique values for each column of the model
        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            if column not in self.checkbox_states:
                self.checkbox_states[column] = {}
                self.checkbox_states[column]['Seleccionar todo'] = True
                for row in range(self.model.rowCount()):
                    value = self.model.record(row).value(column)
                    if value not in list_valuesUnique:
                        if isinstance(value, QtCore.QDate):
                            value=value.toString("dd/MM/yyyy")
                        list_valuesUnique.append(str(value))
                        self.checkbox_states[column][value] = True
                self.dict_valuesuniques[column] = list_valuesUnique

        self.model.dataChanged.connect(self.saveChanges)
        self.selection_model = self.tableEditDocs.selectionModel()
        self.selection_model.selectionChanged.connect(self.countSelectedCells)

        self.tableEditDocs.horizontalHeader().customContextMenuRequested.connect(self.showColumnContextMenu)
        self.tableEditDocs.horizontalHeader().setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)

# Function to query alldocuments data into table
    def query_all_documents(self):
        """
        Queries the database for all documents, configures and populates tables with the query results, 
        and updates the UI accordingly. Handles potential database errors and updates the UI with appropriate messages.
        """
        self.model.dataChanged.disconnect(self.saveChanges)
        self.delete_allFilters()
        self.model.clear()
        self.model.setTable("documentation")
        self.tableEditDocs.setModel(None)
        # self.model.setFilter(f"state NOT IN ('Enviado', 'Comentado')")
        self.model.setRelation(4, QtSql.QSqlRelation("document_type", "id", "doc_type"))
        self.model.select()

        column_names = ["doc_type_id"] # Hidding column by name
        for column_index in range(self.model.columnCount(),-1,-1):
            column_name = self.model.record().fieldName(column_index)
            if column_name in column_names:
                self.model.removeColumn(column_index)

        self.proxy.setSourceModel(self.model)
        self.tableEditDocs.setModel(self.proxy)

        # self.tableEditDocs.verticalHeader().hide()
        self.tableEditDocs.setItemDelegate(AlignDelegate(self.tableEditDocs))
        self.tableEditDocs.setItemDelegateForColumn(4,ComboBoxDelegate_Relational(1,self.tableEditDocs))
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(1,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)
        self.tableEditDocs.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")
        self.tableEditDocs.setObjectName("tableEditDocs")
        self.gridLayout_2.addWidget(self.tableEditDocs, 3, 0, 1, 1)
        self.tableEditDocs.setSortingEnabled(False)
        self.tableEditDocs.horizontalHeader().sectionClicked.connect(self.on_view_horizontalHeader_sectionClicked)

        # Change all column names
        headers = ["Nº Doc. EIPSA", "Nº Doc. Cliente", "Nº Pedido", "Título", "Tipo Doc.", "Crítico", "Nº Revisión", "Fecha Estado", "Estado", "Seguimiento"]
        self.model.setAllColumnHeaders(headers)

        self.combo_itemtype = EditableComboBoxDelegate(self.tableEditDocs, sorted(['Aprobado','Comentado','Com. Mayores','Com. Menores','Eliminado','Enviado','Rechazado']))
        self.tableEditDocs.setItemDelegateForColumn(8, self.combo_itemtype)

    # Getting the unique values for each column of the model
        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            if column not in self.checkbox_states:
                self.checkbox_states[column] = {}
                self.checkbox_states[column]['Seleccionar todo'] = True
                for row in range(self.model.rowCount()):
                    value = self.model.record(row).value(column)
                    if value not in list_valuesUnique:
                        if isinstance(value, QtCore.QDate):
                            value=value.toString("dd/MM/yyyy")
                        list_valuesUnique.append(str(value))
                        self.checkbox_states[column][value] = True
                self.dict_valuesuniques[column] = list_valuesUnique

        self.model.dataChanged.connect(self.saveChanges)
        self.selection_model = self.tableEditDocs.selectionModel()
        self.selection_model.selectionChanged.connect(self.countSelectedCells)

# Function when header is clicked
    def on_view_horizontalHeader_sectionClicked(self, logicalIndex):
        """
        Displays a menu when a column header is clicked. The menu includes options for sorting, filtering, and managing column visibility.
        
        Args:
            logicalIndex (int): Index of the clicked column.
        """
        self.logicalIndex = logicalIndex
        self.menuValues = QtWidgets.QMenu(self)
        self.signalMapper = QtCore.QSignalMapper(self.tableEditDocs)

        valuesUnique_view = []
        for row in range(self.tableEditDocs.model().rowCount()):
            index = self.tableEditDocs.model().index(row, self.logicalIndex)
            value = index.data(Qt.ItemDataRole.DisplayRole)
            if value not in valuesUnique_view:
                if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
                valuesUnique_view.append(value)

        actionSortAscending = QtGui.QAction("Ordenar Ascendente", self.tableEditDocs)
        actionSortAscending.triggered.connect(self.on_actionSortAscending_triggered)
        self.menuValues.addAction(actionSortAscending)
        actionSortDescending = QtGui.QAction("Ordenar Descendente", self.tableEditDocs)
        actionSortDescending.triggered.connect(self.on_actionSortDescending_triggered)
        self.menuValues.addAction(actionSortDescending)
        self.menuValues.addSeparator()

        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro", self.tableEditDocs)
        actionDeleteFilterColumn.triggered.connect(self.on_actionDeleteFilterColumn_triggered)
        self.menuValues.addAction(actionDeleteFilterColumn)
        self.menuValues.addSeparator()

        actionTextFilter = QtGui.QAction("Buscar...", self.tableEditDocs)
        actionTextFilter.triggered.connect(self.on_actionTextFilter_triggered)
        self.menuValues.addAction(actionTextFilter)
        self.menuValues.addSeparator()

        scroll_menu = QtWidgets.QScrollArea()
        scroll_menu.setStyleSheet("background-color: rgb(255, 255, 255)")
        scroll_menu.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget(scroll_menu)
        scroll_menu.setWidget(scroll_widget)
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        checkbox_all_widget = QtWidgets.QCheckBox('Seleccionar todo')

        if not self.checkbox_states[self.logicalIndex]['Seleccionar todo'] == True:
            checkbox_all_widget.setChecked(False)
        else:
            checkbox_all_widget.setChecked(True)
        
        checkbox_all_widget.toggled.connect(lambda checked, name='Seleccionar todo': self.on_select_all_toggled(checked, name))

        scroll_layout.addWidget(checkbox_all_widget)
        self.action_checkbox_map['Seleccionar todo'] = checkbox_all_widget

        if len(self.dict_ordersort) != 0 and self.logicalIndex in self.dict_ordersort:
            list_uniquevalues = sorted(list(set(self.dict_valuesuniques[self.logicalIndex])))
        else:
            list_uniquevalues = sorted(list(set(valuesUnique_view)))

        for actionName in list_uniquevalues:
            checkbox_widget = QtWidgets.QCheckBox(str(actionName))

            if self.logicalIndex not in self.checkbox_filters:
                checkbox_widget.setChecked(True)
            elif actionName not in self.checkbox_filters[self.logicalIndex]:
                checkbox_widget.setChecked(False)
            else:
                checkbox_widget.setChecked(True)

            checkbox_widget.toggled.connect(lambda checked, name=actionName: self.on_checkbox_toggled(checked, name))

            scroll_layout.addWidget(checkbox_widget)
            self.action_checkbox_map[actionName] = checkbox_widget

        action_scroll_menu = QtWidgets.QWidgetAction(self.menuValues)
        action_scroll_menu.setDefaultWidget(scroll_menu)
        self.menuValues.addAction(action_scroll_menu)

        self.menuValues.addSeparator()

        accept_button = QtGui.QAction("ACEPTAR", self.tableEditDocs)
        accept_button.triggered.connect(self.menu_acceptbutton_triggered)

        cancel_button = QtGui.QAction("CANCELAR", self.tableEditDocs)
        cancel_button.triggered.connect(self.menu_cancelbutton_triggered)

        self.menuValues.addAction(accept_button)
        self.menuValues.addAction(cancel_button)

        self.menuValues.setStyleSheet("QMenu { color: black; }"
                                        "QMenu { background-color: rgb(255, 255, 255); }"
                                        "QMenu::item:selected { background-color: #33bdef; }"
                                        "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

        headerPos = self.tableEditDocs.mapToGlobal(self.tableEditDocs.horizontalHeader().pos())        

        posY = headerPos.y() + self.tableEditDocs.horizontalHeader().height()
        scrollX = self.tableEditDocs.horizontalScrollBar().value()
        xInView = self.tableEditDocs.horizontalHeader().sectionViewportPosition(logicalIndex)
        posX = headerPos.x() + xInView - scrollX

        self.menuValues.exec(QtCore.QPoint(posX, posY))

# Function when cancel button of menu is clicked
    def menu_cancelbutton_triggered(self):
        """
        Hides the menu when the cancel button is clicked.
        """
        self.menuValues.hide()

# Function when accept button of menu is clicked
    def menu_acceptbutton_triggered(self):
        """
        Applies the selected filters and updates the table model with the new filters.
        """
        for column, filters in self.checkbox_filters.items():
            if filters:
                self.proxy.setFilter(filters, column, exact_match=True)
            else:
                self.proxy.setFilter(None, column)

        self.tableEditDocs.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(1,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function when select all checkbox is clicked
    def on_select_all_toggled(self, checked, action_name):
        """
        Toggles the state of all checkboxes in the filter menu when the 'Select All' checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the 'Select All' checkbox.
            action_name (str): The name of the action (usually 'Select All').
        """
        filterColumn = self.logicalIndex
        imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
                checkbox_widget.setChecked(checked)
                self.checkbox_states[self.logicalIndex][checkbox_name] = checked

            if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
                self.model.setIconColumnHeader(filterColumn, icono)
            else:
                self.model.setIconColumnHeader(filterColumn, '')
        
        else:
            for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
                checkbox_widget.setChecked(checked)
                self.checkbox_states[self.logicalIndex][checkbox_widget.text()] = checked

# Function when checkbox of header menu is clicked
    def on_checkbox_toggled(self, checked, action_name):
        """
        Updates the filter state when an individual checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the checkbox.
            action_name (str): The name of the checkbox.
        """
        filterColumn = self.logicalIndex
        imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            if filterColumn not in self.checkbox_filters:
                self.checkbox_filters[filterColumn] = [action_name]
            else:
                if action_name not in self.checkbox_filters[filterColumn]:
                    self.checkbox_filters[filterColumn].append(action_name)
        else:
            if filterColumn in self.checkbox_filters and action_name in self.checkbox_filters[filterColumn]:
                self.checkbox_filters[filterColumn].remove(action_name)

        if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
            self.model.setIconColumnHeader(filterColumn, '')
        else:
            self.model.setIconColumnHeader(filterColumn, icono)

# Function to delete individual column filter
    def on_actionDeleteFilterColumn_triggered(self):
        """
        Removes the filter from the selected column and updates the table model.
        """
        filterColumn = self.logicalIndex
        if filterColumn in self.proxy.filters:
            del self.proxy.filters[filterColumn]
        self.model.setIconColumnHeader(filterColumn, '')
        self.proxy.invalidateFilter()

        self.tableEditDocs.setModel(None)
        self.tableEditDocs.setModel(self.proxy)

        if filterColumn in self.checkbox_filters:
            del self.checkbox_filters[filterColumn]

        self.checkbox_states[self.logicalIndex].clear()
        self.checkbox_states[self.logicalIndex]['Seleccionar todo'] = True
        for row in range(self.tableEditDocs.model().rowCount()):
            value = self.model.record(row).value(filterColumn)
            if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
            self.checkbox_states[self.logicalIndex][str(value)] = True

        self.tableEditDocs.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(1,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableEditDocs.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function to order column ascending
    def on_actionSortAscending_triggered(self):
        """
        Sorts the selected column in ascending order.
        """
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.AscendingOrder
        self.tableEditDocs.sortByColumn(sortColumn, sortOrder)

# Function to order column descending
    def on_actionSortDescending_triggered(self):
        """
        Sorts the selected column in descending order.
        """
        sortColumn = self.logicalIndex
        sortOrder = Qt.SortOrder.DescendingOrder
        self.tableEditDocs.sortByColumn(sortColumn, sortOrder)

# Function when text is searched
    def on_actionTextFilter_triggered(self):
        """
        Opens a dialog to enter a text filter and applies it to the selected column.
        """
        filterColumn = self.logicalIndex
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle('Buscar')
        clickedButton=dlg.exec()

        if clickedButton == 1:
            stringAction = dlg.textValue()
            if re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', stringAction):
                stringAction=QtCore.QDate.fromString(stringAction,"dd/MM/yyyy")
                stringAction=stringAction.toString("yyyy-MM-dd")

            filterString = QtCore.QRegularExpression(stringAction, QtCore.QRegularExpression.PatternOption(0))
            # del self.proxy.filters[filterColumn]
            self.proxy.setFilter([stringAction], filterColumn, None)

            imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
            icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
            self.model.setIconColumnHeader(filterColumn, icono)

# Function to enable copy and paste cells
    def keyPressEvent(self, event):
        """
        Handles custom key events for cell operations in the table.

        Args:
            event (QtGui.QKeyEvent): The key event to handle.
        """
        if event.matches(QKeySequence.StandardKey.Copy):
            selected_indexes = self.tableEditDocs.selectionModel().selectedIndexes()
            if not selected_indexes:
                return

            mime_data = QtCore.QMimeData()
            data = bytearray()

            if self.proxy.filters:
                for index in selected_indexes:
                    source_index = self.proxy.mapToSource(index)
                    data += str(self.proxy.sourceModel().data(source_index) if not isinstance(self.proxy.sourceModel().data(source_index), QtCore.QDate) else self.proxy.sourceModel().data(source_index).toString("dd/MM/yyyy")).encode('utf-8') + b'\t'
            else:
                for index in selected_indexes:
                    data += str(self.model.data(index) if not isinstance(self.model.data(index), QtCore.QDate) else self.model.data(index).toString("dd/MM/yyyy")).encode('utf-8') + b'\t'

            mime_data.setData("text/plain", data)

            clipboard = QApplication.clipboard()
            clipboard.setMimeData(mime_data)

        elif event.matches(QKeySequence.StandardKey.Paste):
            if self.tableEditDocs.selectionModel() != None:

                clipboard = QApplication.clipboard()
                mime_data = clipboard.mimeData()

                if not mime_data.hasFormat("text/plain"):
                    return

                data = mime_data.data("text/plain").data()
                values = data.split(b'\t')

                selected_indexes = self.tableEditDocs.selectionModel().selectedIndexes()
                if not selected_indexes:
                    return

                if self.proxy.filters:
                    print('a')
                    model_indexes = [self.proxy.mapToSource(index) for index in selected_indexes]
                    if len(values) == 2:
                        for index in model_indexes:
                            self.proxy.sourceModel().setData(index, values[0].decode('utf-8'))
                    else:
                        for index, value in zip(model_indexes, values):
                            self.proxy.sourceModel().setData(index, value.decode('utf-8'))
                else:
                    print('b')
                    model_indexes = selected_indexes
                    if len(values) == 2:
                        for index in model_indexes:
                            self.model.setData(index, values[0].decode('utf-8'))
                    else:
                        for index, value in zip(model_indexes, values):
                            self.model.setData(index, value.decode('utf-8'))
                self.model.submitAll()

        super().keyPressEvent(event)

# Function to get the text of the selected cells
    def get_selected_text(self, indexes):
        """
        Retrieves the text from the selected cells and returns it as a plain text string.

        Args:
            indexes (list of QModelIndex): A list of QModelIndex objects representing the selected cells.
        
        Returns:
            str: A string containing the text from the selected cells.
        """
        if len(indexes) == 1:  # For only one cell selected
            index = indexes[0]
            cell_data = index.data(Qt.ItemDataRole.DisplayRole)
            return cell_data
        else:
            rows = set()
            cols = set()
            for index in indexes:
                rows.add(index.row())
                cols.add(index.column())

            text_doc = QTextDocument()
            cursor = QTextCursor(text_doc)

            for row in sorted(rows):
                for col in sorted(cols):
                    index = self.model.index(row, col)  
                    cell_data = index.data(Qt.ItemDataRole.DisplayRole)
                    cursor.insertText(str(cell_data))
                    cursor.insertText('\t')
                cursor.insertText('\n')

            return text_doc.toPlainText()

# Function to count selected cells and sum its values
    def countSelectedCells(self):
        """
        Counts the number of selected cells and sums their values. Updates the UI labels with the count and sum.
        """
        if len(self.tableEditDocs.selectedIndexes()) > 1:
            locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

            sum_value = sum([self.euro_string_to_float(str(ix.data())) if re.match(r'^[\d.,]+\sÇ$', str(ix.data())) else float(str(ix.data()).replace(',', '.')) if str(ix.data()).replace(',', '.').replace('.', '', 1).isdigit() else 0 for ix in self.tableEditDocs.selectedIndexes()])

            count_value = len([ix for ix in self.tableEditDocs.selectedIndexes() if ix.data() != ""])
            if sum_value > 0:
                self.label_SumItems.setText("Suma:")
                self.label_SumValue.setText(locale.format_string("%.2f", sum_value, grouping=True))
            if count_value > 0:
                self.label_CountItems.setText("Recuento:")
                self.label_CountValue.setText(str(count_value))
        else:
            self.label_SumItems.setText("")
            self.label_SumValue.setText("")
            self.label_CountItems.setText("")
            self.label_CountValue.setText("")

# Function to format money string values
    def euro_string_to_float(self, euro_str):
        """
        Converts a string representing an amount in euros to a float.

        Args:
            euro_str (str): A string representing the amount in euros (e.g., "1.234,56 €").
        
        Returns:
            float: The numeric value of the amount as a float.
        """
        match = re.match(r'^([\d.,]+)\s€$', euro_str)
        if match:
            number_str = match.group(1)
            number_str = number_str.replace('.', '').replace(',', '.')
            return float(number_str)
        else:
            return 0.0

# Function for creating context menu
    def createContextMenu(self):
        """
        Creates a context menu with options for hiding selected columns.
        """
        self.context_menu = QtWidgets.QMenu(self)
        hide_columns_action = self.context_menu.addAction("Ocultar Columnas")
        hide_columns_action.triggered.connect(self.hideSelectedColumns)

# Function to show context menu when right-click
    def showColumnContextMenu(self, pos):
        """
        Displays the context menu at the specified position for column operations.

        Args:
            pos (QPoint): The position at which to display the context menu.
        """
        header = self.tableEditDocs.horizontalHeader()
        column = header.logicalIndexAt(pos)
        self.context_menu.exec(self.tableEditDocs.mapToGlobal(pos))

# Function to hide selected columns
    def hideSelectedColumns(self):
        """
        Hides the currently selected columns in the table and updates the list of hidden columns.
        """
        selected_columns = set()
        header = self.tableEditDocs.horizontalHeader()
        for index in header.selectionModel().selectedColumns():
            selected_columns.add(index.column())

        for column in selected_columns:
            self.tableEditDocs.setColumnHidden(column, True)
            self.hiddencolumns.append(column)

        self.context_menu.close()

# Function to show all hidden columns
    def show_columns(self):
        """
        Makes all previously hidden columns visible in the table and clears the list of hidden columns.
        """
        for column in self.hiddencolumns:
            self.tableEditDocs.setColumnHidden(column, False)
        self.hiddencolumns.clear()

# Function to update documents with an excel
    def update_documents(self):
        """
        Updates document information by importing an excel file with the data
        """
        fname = askopenfilename(filetypes=[("Archivos de Excel", "*.xlsx")],
                            title="Seleccionar archivo Excel")
        if fname:

            params = config()
            conn = psycopg2.connect(**params)
            cursor = conn.cursor()
            table_name = 'public.documentation'

        #Importing excel file into dataframe
            df_table = pd.read_excel(fname, na_values=['N/A'], keep_default_na=False)
            df_table = df_table.astype(str)
            df_table.replace('nan', 'N/A', inplace=True)

            df_table['state_date'] = df_table['state_date'].apply(self.format_date)
            df_table = df_table.drop(columns=['XX','ESTADOS POSIBLES'])

            try:
        # Loop through each row of the DataFrame and insert the data into the table
                for index, row in df_table.iterrows():
                    if "num_doc_eipsa" in row:
                        id_value = row["num_doc_eipsa"]
                    # Create a list of pairs (column_name, column_value) for each column with value
                        columns_values = [(column, row[column]) for column in df_table.columns if not pd.isnull(row[column])]

                    # Creating string for columns names
                        columns = ', '.join([column for column, _ in columns_values])

                    # Creating string for columns values. For money/amount values, dots are replaced for commas to avoid insertion problems
                        values = ', '.join(['NULL' if value == '' and column in ['revision','state_date']
                                            else (f"'{value}'" if column in ['state','state_date'] else "'{}'".format(value.replace('\'', '\'\''))) for column, value in columns_values])

                        set_clause = ", ".join([f"{column} = {value}" for column, value in zip(columns.split(", ")[1:], values.split(", ")[1:])])

                        where_clause = f"num_doc_eipsa = {id_value}"

                    # Creating the update query and executing it after checking existing tags and id
                        sql_update = f'UPDATE {table_name} SET {set_clause} WHERE {where_clause}'
                        cursor.execute(sql_update)
                        conn.commit()

                cursor.close()

                dlg = QtWidgets.QMessageBox()
                new_icon = QtGui.QIcon()
                new_icon.addPixmap(QtGui.QPixmap("//ERP-EIPSA-DATOS/DATOS/Comunes/EIPSA-ERP/Iconos/icon.ico"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                dlg.setWindowIcon(new_icon)
                dlg.setWindowTitle("ERP EIPSA")
                dlg.setText("Datos importados con éxito")
                dlg.setIcon(QtWidgets.QMessageBox.Icon.Information)
                dlg.exec()
                del dlg, new_icon

            except (Exception, psycopg2.DatabaseError) as error:
                print(error)
            finally:
                if conn is not None:
                    conn.close()

# Function to format values to date
    def format_date(self, value):
        """
        Formats to date the specified value.

        Args:
            name (str): Value to format
        """
        if value == '' or value is None:  # If value is empty, return 'NULL'
            return ''
        try:
            # Try to convert value to date
            date = pd.to_datetime(value, errors='raise')
            return date.strftime('%Y-%m-%d')  # Apply format if it is a date
        except (ValueError, TypeError):
            return value # If it is not valid, return value




if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    config_obj = configparser.ConfigParser()
    config_obj.read(r"C:\Program Files\ERP EIPSA\database.ini")
    dbparam = config_obj["postgresql"]
    # set your parameters for the database connection URI using the keys from the configfile.ini
    user_database = dbparam["user"]
    password_database = dbparam["password"]

    db = Create_DBconnection(user_database, password_database)
    if not db:
        sys.exit()

    EditDocs_Window = Ui_EditDoc_Window(db)
    EditDocs_Window.show()
    sys.exit(app.exec())