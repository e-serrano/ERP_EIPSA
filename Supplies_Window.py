# Form implementation generated from reading ui file 'Supplies_Window.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets, QtSql
from Database_Connection import createConnection
from config import config
import configparser
import psycopg2
import os
import re

basedir = r"\\nas01\DATOS\Comunes\EIPSA-ERP"


class CustomTableWidget(QtWidgets.QTableWidget):
    """
    Custom QTableWidget that supports filtering and sorting features.

    Attributes:
        list_filters (list): Stores filters applied to the table.
        column_filters (dict): Maps column indices to sets of applied filters.
        column_actions (dict): Maps column indices to actions related to columns.
        checkbox_states (dict): Stores the state of checkboxes for filtering.
        rows_hidden (dict): Maps column indices to sets of hidden row indices.
        general_rows_to_hide (set): Set of row indices that are hidden across the table.
    """
    def __init__(self, parent=None):
        """
        Initializes the CustomTableWidget.

        Sets up the initial state of the widget, including filters, checkbox states, 
        and hidden rows.

        Args:
            parent (QWidget, optional): The parent widget of this table. Defaults to None.
        """
        super().__init__(parent)
        self.list_filters=[]
        self.column_filters = {}
        self.column_actions = {}
        self.checkbox_states = {}
        self.rows_hidden = {}
        self.general_rows_to_hide = set()

# Function to show the menu
    def show_unique_values_menu(self, column_index, header_pos, header_height):
        """
        Displays a context menu for unique values in a specified column.

        The menu includes options to remove filters, sort the column, and filter by text. 
        It also allows the user to select/unselect unique values via checkboxes.

        Args:
            column_index (int): The index of the column for which the menu is displayed.
            header_pos (QPoint): The position of the header in the viewport.
            header_height (int): The height of the header.
        """
        menu = QtWidgets.QMenu(self)
        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro")
        actionDeleteFilterColumn.triggered.connect(lambda: self.delete_filter(column_index))
        menu.addAction(actionDeleteFilterColumn)
        menu.addSeparator()
        actionOrderAsc = menu.addAction("Ordenar Ascendente")
        actionOrderAsc.triggered.connect(lambda: self.sort_column(column_index, QtCore.Qt.SortOrder.AscendingOrder))
        actionOrderDesc = menu.addAction("Ordenar Descendente")
        actionOrderDesc.triggered.connect(lambda: self.sort_column(column_index, QtCore.Qt.SortOrder.DescendingOrder))
        menu.addSeparator()
        actionFilterByText = menu.addAction("Buscar Texto")
        actionFilterByText.triggered.connect(lambda: self.filter_by_text(column_index))
        menu.addSeparator()

        menu.setStyleSheet("QMenu::item:selected { background-color: #33bdef; }"
                        "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

        if column_index not in self.column_filters:
            self.column_filters[column_index] = set()

        scroll_menu = QtWidgets.QScrollArea()
        scroll_menu.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget(scroll_menu)
        scroll_menu.setWidget(scroll_widget)
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        checkboxes = []

        select_all_checkbox = QtWidgets.QCheckBox("Seleccionar todo")
        if column_index in self.checkbox_states:
            select_all_checkbox.setCheckState(QtCore.Qt.CheckState(self.checkbox_states[column_index].get("Seleccionar todo", QtCore.Qt.CheckState(2))))
        else:
            select_all_checkbox.setCheckState(QtCore.Qt.CheckState(2))
        scroll_layout.addWidget(select_all_checkbox)
        checkboxes.append(select_all_checkbox)

        unique_values = self.get_unique_values(column_index)
        filtered_values = self.get_filtered_values()

        for value in sorted(unique_values):
            checkbox = QtWidgets.QCheckBox(value)
            if select_all_checkbox.isChecked(): 
                checkbox.setCheckState(QtCore.Qt.CheckState(2))
            else:
                if column_index in self.checkbox_states and value in self.checkbox_states[column_index]:
                    checkbox.setCheckState(QtCore.Qt.CheckState(self.checkbox_states[column_index][value]))
                elif filtered_values is None or value in filtered_values[column_index]:
                    checkbox.setCheckState(QtCore.Qt.CheckState(2))
                else:
                    checkbox.setCheckState(QtCore.Qt.CheckState(0))
            scroll_layout.addWidget(checkbox)
            checkboxes.append(checkbox)

        select_all_checkbox.stateChanged.connect(lambda state: self.set_all_checkboxes_state(checkboxes, state, column_index))

        for value, checkbox in zip(sorted(unique_values), checkboxes[1:]):
            checkbox.stateChanged.connect(lambda checked, value=value, checkbox=checkbox: self.apply_filter(column_index, value, checked))

    # Action for drop down menu and adding scroll area as widget
        action_scroll_menu = QtWidgets.QWidgetAction(menu)
        action_scroll_menu.setDefaultWidget(scroll_menu)
        menu.addAction(action_scroll_menu)

        menu.exec(header_pos - QtCore.QPoint(0, header_height))


# Function to delete filter on selected column
    def delete_filter(self,column_index):
        """
        Removes the filter applied to the specified column.

        Unhides previously hidden rows and resets the checkbox state for the column.

        Args:
            column_index (int): The index of the column from which to delete the filter.
        """
        if column_index in self.column_filters:
            del self.column_filters[column_index]
        if column_index in self.checkbox_states:
            del self.checkbox_states[column_index]
        if column_index in self.rows_hidden:
            for item in self.rows_hidden[column_index]:
                self.setRowHidden(item, False)
                if item in self.general_rows_to_hide:
                    self.general_rows_to_hide.remove(item)
            del self.rows_hidden[column_index]
        header_item = self.horizontalHeaderItem(column_index)
        header_item.setIcon(QtGui.QIcon())


# Function to set all checkboxes state
    def set_all_checkboxes_state(self, checkboxes, state, column_index):
        """
        Sets the state of all checkboxes in the filter menu for a specific column.

        Args:
            checkboxes (list): List of checkboxes to update.
            state (Qt.CheckState): The desired state for the checkboxes.
            column_index (int): The index of the column for which the checkboxes are set.
        """
        if column_index not in self.checkbox_states:
            self.checkbox_states[column_index] = {}

        for checkbox in checkboxes:
            checkbox.setCheckState(QtCore.Qt.CheckState(state))

        self.checkbox_states[column_index]["Seleccionar todo"] = state


# Function to apply filters to table
    def apply_filter(self, column_index, value, checked, text_filter=None, filter_dialog=None):
        """
        Applies a filter to the specified column based on the checkbox state and optional text filter.

        Args:
            column_index (int): The index of the column to filter.
            value (str): The value to filter by.
            checked (bool): Indicates if the filter should be applied (True) or removed (False).
            text_filter (str, optional): Additional text filter for filtering items. Defaults to None.
            filter_dialog (QDialog, optional): The dialog used for the text filter. Defaults to None.
        """
        if column_index not in self.column_filters:
            self.column_filters[column_index] = set()

        if text_filter is None:
            if value is None:
                self.column_filters[column_index] = set()
            elif checked:
                self.column_filters[column_index].add(value)
            elif value in self.column_filters[column_index]:
                self.column_filters[column_index].remove(value)

        rows_to_hide = set()
        for row in range(self.rowCount()):
            show_row = True

            # Check filters for all columns
            for col, filters in self.column_filters.items():
                item = self.item(row, col)
                if item:
                    item_value = item.text()
                    if text_filter is None:
                        if filters and item_value not in filters:
                            show_row = False
                            break

        # Filtering by text
            if text_filter is not None:
                filter_dialog.accept()
                item = self.item(row, column_index)
                if item:
                    if text_filter.upper() in item.text().upper():
                        self.column_filters[column_index].add(item.text())
                    else:
                        show_row = False

            if not show_row:
                if row not in self.general_rows_to_hide:
                    self.general_rows_to_hide.add(row)
                    rows_to_hide.add(row)
            else:
                if row in self.general_rows_to_hide:
                    self.general_rows_to_hide.remove(row)

        # Update hidden rows for this column depending on checkboxes
        if checked and text_filter is None:
            if column_index not in self.rows_hidden:
                self.rows_hidden[column_index] = set(rows_to_hide)
            else:
                self.rows_hidden[column_index].update(rows_to_hide)

        # Update hidden rows for this column depending on filtered text
        if text_filter is not None and value is None:
            if column_index not in self.rows_hidden:
                self.rows_hidden[column_index] = set(rows_to_hide)
            else:
                self.rows_hidden[column_index].update(rows_to_hide)

        # Iterate over all rows to hide them as necessary
        for row in range(self.rowCount()):
            self.setRowHidden(row, row in self.general_rows_to_hide)

        header_item = self.horizontalHeaderItem(column_index)
        if len(self.general_rows_to_hide) > 0:
            header_item.setIcon(QtGui.QIcon(os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))))
        else:
            header_item.setIcon(QtGui.QIcon())

# Function to apply filters to table based on a desired text
    def filter_by_text(self, column_index):
        """
        Opens a dialog for filtering the specified column by text input.

        Args:
            column_index (int): The index of the column to filter.
        """
        filter_dialog = QtWidgets.QDialog(self)
        filter_dialog.setWindowTitle("Filtrar por texto")
        
        label = QtWidgets.QLabel("Texto a filtrar:")
        text_input = QtWidgets.QLineEdit()
        
        filter_button = QtWidgets.QPushButton("Filtrar")
        filter_button.setStyleSheet("QPushButton {\n"
"background-color: #33bdef;\n"
"  border: 1px solid transparent;\n"
"  border-radius: 3px;\n"
"  color: #fff;\n"
"  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
"  font-size: 15px;\n"
"  font-weight: 800;\n"
"  line-height: 1.15385;\n"
"  margin: 0;\n"
"  outline: none;\n"
"  padding: 2px .8em;\n"
"  text-align: center;\n"
"  text-decoration: none;\n"
"  vertical-align: baseline;\n"
"  white-space: nowrap;\n"
"}\n"
"\n"
"QPushButton:hover {\n"
"    background-color: #019ad2;\n"
"    border-color: rgb(0, 0, 0);\n"
"}\n"
"\n"
"QPushButton:pressed {\n"
"    background-color: rgb(1, 140, 190);\n"
"    border-color: rgb(255, 255, 255);\n"
"}")
        filter_button.clicked.connect(lambda: self.apply_filter(column_index, None, False, text_input.text(), filter_dialog))

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(label)
        layout.addWidget(text_input)
        layout.addWidget(filter_button)

        filter_dialog.setLayout(layout)
        filter_dialog.exec()


# Function to obtain the unique matching applied filters 
    def get_unique_values(self, column_index):
        """
        Retrieves unique values from the specified column, taking into account any active filters on other columns.

        Args:
            column_index (int): The index of the column from which to retrieve unique values.

        Returns:
            set: A set of unique values from the specified column that are visible based on the current filters.
        """
        unique_values = set()
        for row in range(self.rowCount()):
            show_row = True
            for col, filters in self.column_filters.items():
                if col != column_index:
                    item = self.item(row, col)
                    if item:
                        item_value = item.text()
                        if filters and item_value not in filters:
                            show_row = False
                            break
            if show_row:
                item = self.item(row, column_index)
                if item:
                    unique_values.add(item.text())
        return unique_values

# Function to get values filtered by all columns
    def get_filtered_values(self):
        """
        Gets the current filter values for all columns.

        Returns:
            dict: A dictionary where each key is a column index and the value is a set of filters applied to that column.
        """
        filtered_values = {}
        for col, filters in self.column_filters.items():
            filtered_values[col] = filters
        return filtered_values

# Function to sort column
    def sort_column(self, column_index, sortOrder):
        """
        Sorts the specified column based on the given order. If the column is a date column, a custom sort method is used.

        Args:
            column_index (int): The index of the column to sort.
            sortOrder (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        self.sortByColumn(column_index, sortOrder)

# Function to sort column based on special datatypes
    def custom_sort(self, column, order):
        """
        Custom sorting method for date columns. Sorts the specified column based on date values.

        Args:
            column (int): The index of the column to sort.
            order (Qt.SortOrder): The order to sort the column (ascending or descending).
        """
        row_count = self.rowCount()

        indexes = list(range(row_count))
        indexes.sort(key=lambda i: QtCore.QDateTime.fromString(self.item(i, column).text(), "dd-MM-yyyy"))

        if order == QtCore.Qt.SortOrder.DescendingOrder:
            indexes.reverse()

        hidden_rows = [row for row in range(row_count) if self.isRowHidden(row)]

        rows = self.rowCount()
        for i in range(rows):
            self.insertRow(i)

        for new_row, old_row in enumerate(indexes):
            for col in range(self.columnCount()):
                item = self.takeItem(old_row + rows, col)
                self.setItem(new_row, col, item)

        for i in range(rows):
            self.removeRow(rows)

        for row in hidden_rows:
            self.setRowHidden(row, True)

# Function with the menu configuration
    def contextMenuEvent(self, event):
        """
        Handles the context menu event for the table. Shows a menu for filtering unique values when the header is right-clicked.

        Args:
            event (QEvent): The event triggered by the context menu action.
        """
        if self.horizontalHeader().visualIndexAt(event.pos().x()) >= 0:
            logical_index = self.horizontalHeader().logicalIndexAt(event.pos().x())
            header_pos = self.mapToGlobal(self.horizontalHeader().pos())
            header_height = self.horizontalHeader().height()
            self.show_unique_values_menu(logical_index, header_pos, header_height)
        else:
            super().contextMenuEvent(event)

class AlignDelegate(QtWidgets.QStyledItemDelegate):
    """
    A custom item delegate for aligning cell content in a QTableView or QTableWidget to the center.

    Inherits from:
        QtWidgets.QStyledItemDelegate: Provides custom rendering and editing for table items.

    """
    def initStyleOption(self, option, index):
        """
        Initializes the style option for the item, setting its display alignment to center.

        Args:
            option (QtWidgets.QStyleOptionViewItem): The style option to initialize.
            index (QtCore.QModelIndex): The model index of the item.
        """
        super(AlignDelegate, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

class NumericDelegate(QtWidgets.QStyledItemDelegate):
    """
    A delegate for displaying numeric values in a QTableView.

    Attributes:
        decimals (int): The number of decimal places to display.
    """
    def __init__(self, decimals=3, parent=None):
        """
        Initializes a NumericDelegate instance.

        Args:
            decimals (int): The number of decimal places to format. Defaults to 3.
            parent (QWidget, optional): The parent widget for the delegate.
        """
        super(NumericDelegate, self).__init__(parent)
        self.decimals = decimals

    def displayText(self, value, locale):
        """
        Formats the numeric value for display in the table.

        Args:
            value (Any): The value to format for display.
            locale (QLocale): The locale used for formatting.

        Returns:
            str: The formatted value as a string.
        """
        try:
            float_value = float(value)
            return f"{float_value:.{self.decimals}f}"
        except ValueError:
            return str(value)

class AlignDelegate_records(QtWidgets.QStyledItemDelegate):
    """
    A custom item delegate for aligning cell content in a QTableView or QTableWidget to the center.

    Inherits from:
        QtWidgets.QStyledItemDelegate: Provides custom rendering and editing for table items.

    """
    def initStyleOption(self, option, index):
        """
        Initializes the style option for the item, setting its display alignment to center.

        Args:
            option (QtWidgets.QStyleOptionViewItem): The style option to initialize.
            index (QtCore.QModelIndex): The model index of the item.
        """
        super(AlignDelegate_records, self).initStyleOption(option, index)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

        if index.column() == 6:  # Check column and paint if apply
            value = index.data()

            if value != '' :
                if float(value) < 0:  
                    color = QtGui.QColor(255, 124, 128)  # Red if lower than 0
                else:
                    color = QtGui.QColor(24, 24, 24)
            else:
                color = QtGui.QColor(24, 24, 24)

            option.backgroundBrush = color

class ColorDelegate(QtWidgets.QItemDelegate):
    """
    A custom item delegate for applying background colors to cells in a QTableView or QTableWidget.

    Inherits from:
        QtWidgets.QItemDelegate: Provides custom rendering for table items.
    """
    def __init__(self, parent=None):
        """
        Initializes the ColorDelegate, setting up the color mapping from the database.

        Args:
            parent (QtWidgets.QWidget, optional): The parent widget. Defaults to None.
        """
        super().__init__(parent)

    def paint(self, painter, option, index: QtCore.QModelIndex):
        """
        Paints the background color of the item based on its column and value.

        Args:
            painter (QtGui.QPainter): The painter used for painting.
            option (QtWidgets.QStyleOptionViewItem): The style option for the item.
            index (QtCore.QModelIndex): The model index of the item.
        """
        background_color = QtGui.QColor(255, 0, 0, 0) #Transparent
        id_supply = str(index.sibling(index.row(), 0).data()).upper()
        commands_queryquotations = ("""
                        SELECT purch_fact.quotation_details."value"
                        FROM purch_fact.quotation_details
                        LEFT JOIN purch_fact.quotation_header ON (purch_fact.quotation_header."id" = purch_fact.quotation_details."quot_header_id")
                        WHERE purch_fact.quotation_details.supply_id = %s
                        ORDER BY purch_fact.quotation_header.quot_date DESC
                        """)
        conn = None
        try:
        # read the connection parameters
            params = config()
        # connect to the PostgreSQL server
            conn = psycopg2.connect(**params)
            cur = conn.cursor()
        # execution of commands one by one
            cur.execute(commands_queryquotations,(id_supply,))
            results_quotations=cur.fetchall()
        # close communication with the PostgreSQL database server
            cur.close()
        # commit the changes
            conn.commit()
        except (Exception, psycopg2.DatabaseError) as error:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("Ha ocurrido el siguiente error:\n"
                        + str(error))
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
            dlg.exec()
            del dlg, new_icon
        finally:
            if conn is not None:
                conn.close()

        original_text = index.data()  # Text of cell to be painted
        value_check = results_quotations[0][0].replace(" €","").replace(".","").replace(",",".") if len(results_quotations) > 0 else None  # Text for checking

        if value_check is not None and float(original_text) != float(value_check):
            background_color = QtGui.QColor(255, 0, 0) #Red

        index.model().setData(index, background_color, QtCore.Qt.ItemDataRole.BackgroundRole)
        painter.fillRect(option.rect, background_color)
        option.displayAlignment = QtCore.Qt.AlignmentFlag.AlignCenter

        super().paint(painter, option, index)

class EditableComboBoxDelegate(QtWidgets.QStyledItemDelegate):
    """
    A delegate for editing combobox items in a view.

    Attributes:
        options (list): List of options to populate the combobox.
    """
    def __init__(self, parent=None, options=None):
        """
        Initializes the EditableComboBoxDelegate with the specified options.

        Args:
            parent (QtWidgets.QWidget, optional): Parent widget.
            options (list, optional): List of options for the combobox.
        """
        super().__init__(parent)
        self.options = options

    def createEditor(self, parent, option, index):
        """
        Creates an editor for the combobox.

        Args:
            parent (QtWidgets.QWidget): Parent widget.
            option (QtWidgets.QStyleOptionViewItem): Style options for the item.
            index (QtCore.QModelIndex): Index of the item in the model.

        Returns:
            QtWidgets.QComboBox: The created combobox editor.
        """
        editor = QtWidgets.QComboBox(parent)
        editor.setEditable(True)
        return editor

    def setEditorData(self, editor, index):
        """
        Sets the data for the combobox editor.

        Args:
            editor (QtWidgets.QComboBox): The combobox editor.
            index (QtCore.QModelIndex): Index of the item in the model.
        """
        text = index.data(QtCore.Qt.ItemDataRole.DisplayRole)
        editor.addItems(self.options)
        editor.setEditText(text)

    def setModelData(self, editor, model, index):
        """
        Updates the model with the data from the combobox editor.

        Args:
            editor (QtWidgets.QComboBox): The combobox editor.
            model (QtGui.QAbstractItemModel): The model to update.
            index (QtCore.QModelIndex): Index of the item in the model.
        """
        model.setData(index, editor.currentText(), QtCore.Qt.ItemDataRole.EditRole)

class CustomProxyModel(QtCore.QSortFilterProxyModel):
    """
    A custom proxy model that filters table rows based on expressions set for specific columns.

    Attributes:
        _filters (dict): A dictionary to store filter expressions for columns.
        header_names (dict): A dictionary to store header names for the table.

    Properties:
        filters: Getter for the current filter dictionary.

    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self._filters = dict()
        self.header_names = {}
        self._background_color_filter = None

    @property
    def filters(self):
        """
        Get the current filter expressions applied to columns.

        Returns:
            dict: Dictionary of column filters.
        """
        return self._filters

    def setBackgroundColorFilter(self, color):
        self._background_color_filter = color
        self.invalidateFilter()

    def setFilter(self, expresion, column, action_name=None):
        """
        Apply a filter expression to a specific column, or remove it if necessary.

        Args:
            expresion (str): The filter expression.
            column (int): The index of the column to apply the filter to.
            action_name (str, optional): Name of the action, can be empty. Defaults to None.
        """
        if expresion or expresion == '':
            if column in self.filters:
                if action_name or action_name == '':
                    self.filters[column].remove(expresion)
                else:
                    self.filters[column].append(expresion)
            else:
                self.filters[column] = [expresion]
        elif column in self.filters:
            if action_name or action_name == '':
                self.filters[column].remove(expresion)
                if not self.filters[column]:
                    del self.filters[column]
            else:
                del self.filters[column]
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        """
        Check if a row passes the filter criteria based on the column filters.

        Args:
            source_row (int): The row number in the source model.
            source_parent (QModelIndex): The parent index of the row.

        Returns:
            bool: True if the row meets the filter criteria, False otherwise.
        """
        for column, expresions in self.filters.items():
            text = self.sourceModel().index(source_row, column, source_parent).data()

            if isinstance(text, QtCore.QDate): #Check if filters are QDate. If True, convert to text
                text = text.toString("yyyy-MM-dd")
            elif isinstance(text, float):
                text = str(text)

            for expresion in expresions[0]:
                if expresion == '':  # If expression is empty, match empty cells
                    if text == '':
                        break

                elif re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', str(expresion)):
                    expresion = QtCore.QDate.fromString(expresion, "dd/MM/yyyy")
                    expresion = expresion.toString("yyyy-MM-dd")
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        break

                else:
                    regex = QtCore.QRegularExpression(f".*{re.escape(str(expresion))}.*", QtCore.QRegularExpression.PatternOption.CaseInsensitiveOption)
                    if regex.match(str(text)).hasMatch():
                        break
            else:
                return False

        if self._background_color_filter:
            for column in range(self.sourceModel().columnCount()):
                index = self.sourceModel().index(source_row, column, source_parent)
                background_color = index.data(QtCore.Qt.ItemDataRole.BackgroundRole)
                if background_color != self._background_color_filter:
                    return False

        return True

class EditableTableModel(QtSql.QSqlTableModel):
    """
    A custom SQL table model that supports editable columns, headers, and special flagging behavior based on user permissions.

    Signals:
        updateFailed (str): Signal emitted when an update to the model fails.
    """
    updateFailed = QtCore.pyqtSignal(str)

    def __init__(self, parent=None, column_range=None):
        """
        Initialize the model with user permissions and optional database and column range.

        Args:
            username (str): The username for permission-based actions.
            parent (QObject, optional): Parent object for the model. Defaults to None.
            column_range (list, optional): A list specifying the range of columns. Defaults to None.
        """
        super().__init__(parent)
        self.column_range = column_range

    def setAllColumnHeaders(self, headers):
        """
        Set headers for all columns in the model.

        Args:
            headers (list): A list of header names.
        """
        for column, header in enumerate(headers):
            self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, header, QtCore.Qt.ItemDataRole.DisplayRole)

    def setIndividualColumnHeader(self, column, header):
        """
        Set the header for a specific column.

        Args:
            column (int): The column index.
            header (str): The header name.
        """
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, header, QtCore.Qt.ItemDataRole.DisplayRole)

    def setIconColumnHeader(self, column, icon):
        """
        Set an icon in the header for a specific column.

        Args:
            column (int): The column index.
            icon (QIcon): The icon to display in the header.
        """
        self.setHeaderData(column, QtCore.Qt.Orientation.Horizontal, icon, QtCore.Qt.ItemDataRole.DecorationRole)

    def headerData(self, section, orientation, role=QtCore.Qt.ItemDataRole.DisplayRole):
        """
        Retrieve the header data for a specific section of the model.

        Args:
            section (int): The section index (column or row).
            orientation (Qt.Orientation): The orientation (horizontal or vertical).
            role (Qt.ItemDataRole, optional): The role for the header data. Defaults to DisplayRole.

        Returns:
            QVariant: The header data for the specified section.
        """
        if role == QtCore.Qt.ItemDataRole.DisplayRole and orientation == QtCore.Qt.Orientation.Horizontal:
            return super().headerData(section, orientation, role)
        return super().headerData(section, orientation, role)

    def flags(self, index):
        """
        Get the item flags for a given index, controlling editability and selection based on user permissions.

        Args:
            index (QModelIndex): The index of the item.

        Returns:
            Qt.ItemFlags: The flags for the specified item.
        """
        flags = super().flags(index)
        if index.column() in [0, 3, 4]:
            flags &= ~QtCore.Qt.ItemFlag.ItemIsEditable
            return flags | QtCore.Qt.ItemFlag.ItemIsSelectable | QtCore.Qt.ItemFlag.ItemIsEnabled
        else:
            return flags | QtCore.Qt.ItemFlag.ItemIsSelectable | QtCore.Qt.ItemFlag.ItemIsEnabled | QtCore.Qt.ItemFlag.ItemIsEditable

    def getColumnHeaders(self, visible_columns):
        """
        Retrieve the headers for the specified visible columns.

        Args:
            visible_columns (list): List of column indices that are visible.

        Returns:
            list: A list of column headers for the visible columns.
        """
        column_headers = [self.headerData(col, QtCore.Qt.Orientation.Horizontal) for col in visible_columns]
        return column_headers


class Ui_Supplies_Window(QtWidgets.QMainWindow):
    """
    A window for editing supplies in the application.

    Attributes:
        model (EditableTableModel): The data model for the table.
        proxy (CustomProxyModel): The proxy model for filtering and sorting.
        db (object): Database connection.
        checkbox_states (dict): States of checkboxes.
        dict_valuesuniques (dict): Unique values for columns.
        dict_ordersort (dict): Sorting order for columns.
        hiddencolumns (list): List of hidden column indices.
        action_checkbox_map (dict): Map of actions to checkboxes.
        checkbox_filters (dict): Filters based on checkbox states.
        username (str): username associated with the window.
        variable (str): Variable used in the window.
    """
    def __init__(self,username,db):
        """
        Initializes the Ui_EditTags_Technical_Window with the specified username and database connection.

        Args:
            username (str): username associated with the window.
            db (object): Database connection.
        """
        super().__init__()
        self.model = EditableTableModel()
        self.proxy = CustomProxyModel()
        self.db = db
        self.checkbox_states = {}
        self.dict_valuesuniques = {}
        self.dict_ordersort = {}
        self.hiddencolumns = []
        self.action_checkbox_map = {}
        self.checkbox_filters = {}
        self.model.dataChanged.connect(self.saveChanges)
        self.username = username
        self.setupUi(self)

    def closeEvent(self, event):
        """
        Handles the event triggered when the window is closed. Ensures models are cleared and database connections are closed.

        Args:
            event (QCloseEvent): The close event triggered when the window is about to close.
        """
        if self.model:
            self.model.clear()
        self.closeConnection()

    def closeConnection(self):
        """
        Closes the database connection and clears any references to the models.
        Also removes the 'drawing_index' database connection from Qt's connection list if it exists.
        """
        self.tableSupplies.setModel(None)
        del self.model
        if self.db:
            self.db.close()
            del self.db
            if QtSql.QSqlDatabase.contains("qt_sql_default_connection"):
                QtSql.QSqlDatabase.removeDatabase("qt_sql_default_connection")

    def setupUi(self, Supplies_Window):
        """
        Sets up the user interface for the Supplies_Window.

        Args:
            Supplies_Window (QtWidgets.QMainWindow): The main window for the UI setup.
        """
        Supplies_Window.setObjectName("Supplies_Window")
        Supplies_Window.resize(int(1174//1.5), int(600//1.5))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        Supplies_Window.setWindowIcon(icon)
        if self.username == 'd.marquez':
            Supplies_Window.setStyleSheet("QWidget {\n"
    "background-color: #121212; color: rgb(255, 255, 255)\n"
    "}\n"
    "\n"
    ".QFrame {\n"
    "    border: 2px solid white;\n"
    "}\n"
    "\n"
    "QComboBox {\n"
    "border: 1px solid white;\n"
    "border-radius: 3px;\n"
    "}\n"
    "QComboBox QAbstractItemView{\n"
    "min-width: 1200px;\n"
    "}\n"
    "\n"
    "QComboBox QAbstractItemView::item {\n"
    "min-height: 35px;\n"
    "}\n"
    "\n"
    "QPushButton {\n"
    "background-color: #33bdef;\n"
    "  border: 1px solid transparent;\n"
    "  border-radius: 3px;\n"
    "  color: #fff;\n"
    "  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
    "  font-size: 15px;\n"
    "  font-weight: 800;\n"
    "  line-height: 1.15385;\n"
    "  margin: 0;\n"
    "  outline: none;\n"
    "  padding: 8px .8em;\n"
    "  text-align: center;\n"
    "  text-decoration: none;\n"
    "  vertical-align: baseline;\n"
    "  white-space: nowrap;\n"
    "}\n"
    "\n"
    "QPushButton:hover {\n"
    "    background-color: #019ad2;\n"
    "    border-color: rgb(0, 0, 0);\n"
    "}\n"
    "\n"
    "QPushButton:pressed {\n"
    "    background-color: rgb(1, 140, 190);\n"
    "    border-color: rgb(255, 255, 255);\n"
    "}"
    )
        else:
            Supplies_Window.setStyleSheet("QWidget {\n"
    "background-color: rgb(255, 255, 255);\n"
    "}\n"
    "\n"
    ".QFrame {\n"
    "    border: 2px solid black;\n"
    "}\n"
    "\n"
    "QComboBox QAbstractItemView{\n"
    "min-width: 1200px;\n"
    "}\n"
    "\n"
    "QComboBox QAbstractItemView::item {\n"
    "min-height: 35px;\n"
    "}\n"
    "\n"
    "QPushButton {\n"
    "background-color: #33bdef;\n"
    "  border: 1px solid transparent;\n"
    "  border-radius: 3px;\n"
    "  color: #fff;\n"
    "  font-family: -apple-system,system-ui,\"Segoe UI\",\"Liberation Sans\",sans-serif;\n"
    "  font-size: 15px;\n"
    "  font-weight: 800;\n"
    "  line-height: 1.15385;\n"
    "  margin: 0;\n"
    "  outline: none;\n"
    "  padding: 8px .8em;\n"
    "  text-align: center;\n"
    "  text-decoration: none;\n"
    "  vertical-align: baseline;\n"
    "  white-space: nowrap;\n"
    "}\n"
    "\n"
    "QPushButton:hover {\n"
    "    background-color: #019ad2;\n"
    "    border-color: rgb(0, 0, 0);\n"
    "}\n"
    "\n"
    "QPushButton:pressed {\n"
    "    background-color: rgb(1, 140, 190);\n"
    "    border-color: rgb(255, 255, 255);\n"
    "}"
    )
        self.centralwidget = QtWidgets.QWidget(parent=Supplies_Window)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.frame = QtWidgets.QFrame(parent=self.centralwidget)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Raised)
        self.frame.setObjectName("frame")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.frame)
        self.gridLayout_2.setObjectName("gridLayout_2")
        spacerItem = QtWidgets.QSpacerItem(20, 5, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.gridLayout_2.addItem(spacerItem, 0, 1, 1, 1)
        self.label_Quotations = QtWidgets.QLabel(parent=self.frame)
        self.label_Quotations.setMinimumSize(QtCore.QSize(0, int(35//1.5)))
        self.label_Quotations.setMaximumSize(QtCore.QSize(16777215, int(35//1.5)))
        font = QtGui.QFont()
        font.setPointSize(int(16//1.5))
        font.setBold(True)
        self.label_Quotations.setFont(font)
        self.label_Quotations.setObjectName("label_Quotations")
        self.gridLayout_2.addWidget(self.label_Quotations, 1, 1, 1, 1)
        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Orientation.Vertical)
        self.tableQuotations = CustomTableWidget()
        self.tableQuotations.setObjectName("tableQuotations")
        self.tableQuotations.setColumnCount(7)
        self.tableQuotations.setRowCount(0)
        for i in range(7):
            item = QtWidgets.QTableWidgetItem()
            font = QtGui.QFont()
            font.setPointSize(int(14//1.5))
            font.setBold(True)
            item.setFont(font)
            self.tableQuotations.setHorizontalHeaderItem(i, item)
        self.splitter.addWidget(self.tableQuotations)
        self.tableSupplies=QtWidgets.QTableView(parent=self.frame)
        self.model = EditableTableModel()
        self.splitter.addWidget(self.tableSupplies)
        self.gridLayout_2.addWidget(self.splitter, 2, 1, 1, 15)
        self.Button_AddSupply = QtWidgets.QPushButton(parent=self.frame)
        self.Button_AddSupply.setObjectName("Button_AddSupply")
        self.gridLayout_2.addWidget(self.Button_AddSupply, 1, 15, 1, 1)
        self.Position = QtWidgets.QLineEdit(parent=self.frame)
        self.Position.setMinimumSize(QtCore.QSize(0, int(35//1.5)))
        self.Position.setMaximumSize(QtCore.QSize(500, int(35//1.5)))
        font = QtGui.QFont()
        font.setPointSize(int(14//1.5))
        self.Position.setFont(font)
        self.Position.setObjectName("Position")
        self.gridLayout_2.addWidget(self.Position, 4, 1, 1, 2)
        self.gridLayout.addWidget(self.frame, 0, 1, 1, 1)
        Supplies_Window.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=Supplies_Window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1174, 22))
        self.menubar.setObjectName("menubar")
        Supplies_Window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=Supplies_Window)
        self.statusbar.setObjectName("statusbar")
        Supplies_Window.setStatusBar(self.statusbar)

        self.tableQuotations.setSortingEnabled(False)
        self.tableQuotations.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
        if self.username == 'd.marquez':
            self.tableQuotations.setStyleSheet("gridline-color: rgb(128, 128, 128);")
            self.tableQuotations.horizontalHeader().setStyleSheet("QHeaderView::section {background-color: #33bdef; border: 1px solid white; font-weight: bold; font-size: 10pt;}")
        else:
            self.tableQuotations.horizontalHeader().setStyleSheet("QHeaderView::section {background-color: #33bdef; border: 1px solid black; font-weight: bold; font-size: 10pt;}")

        self.retranslateUi(Supplies_Window)
        QtCore.QMetaObject.connectSlotsByName(Supplies_Window)


        commands_comboboxes_measureunits= f"SELECT measure_unit FROM purch_fact.measure_units"

        conn = None
        try:
        # read the connection parameters
            params = config()
        # connect to the PostgreSQL server
            conn = psycopg2.connect(**params)
            cur = conn.cursor()
        # execution of commands one by one
            cur.execute(commands_comboboxes_measureunits)
            self.results_others=cur.fetchall()
        # close communication with the PostgreSQL database server
            cur.close()
        # commit the changes
            conn.commit()
        except (Exception, psycopg2.DatabaseError) as error:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("Ha ocurrido el siguiente error:\n"
                        + str(error))
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
            dlg.exec()
            del dlg, new_icon
        finally:
            if conn is not None:
                conn.close()

        self.tableSupplies.clicked.connect(self.item_clicked)
        self.tableSupplies.doubleClicked.connect(self.edit_supply)
        self.tableQuotations.itemDoubleClicked.connect(self.loadprice)
        self.tableSupplies.horizontalHeader().sectionClicked.connect(self.on_view_horizontalHeader_sectionClicked)
        self.tableQuotations.horizontalHeader().sectionClicked.connect(self.on_header_sectionquot_clicked)
        self.Button_AddSupply.clicked.connect(self.addsupply)
        self.Position.textChanged.connect(self.position_table)
        self.loadtablesupplies()

# Function to translate and updates the text of various UI elements
    def retranslateUi(self, Supplies_Window):
        """
        Translates and updates the text of various UI elements.
        """
        _translate = QtCore.QCoreApplication.translate
        Supplies_Window.setWindowTitle(_translate("Supplies_Window", "Suministros"))
        self.label_Quotations.setText(_translate("Supplies_Window", "Cotizaciones:"))
        item = self.tableQuotations.horizontalHeaderItem(0)
        item.setText(_translate("Supplies_Window", "Nombre"))
        item = self.tableQuotations.horizontalHeaderItem(1)
        item.setText(_translate("Supplies_Window", "Fecha"))
        item = self.tableQuotations.horizontalHeaderItem(2)
        item.setText(_translate("Supplies_Window", "Denominación"))
        item = self.tableQuotations.horizontalHeaderItem(3)
        item.setText(_translate("Supplies_Window", "Descripción"))
        item = self.tableQuotations.horizontalHeaderItem(4)
        item.setText(_translate("Supplies_Window", "Cantidad"))
        item = self.tableQuotations.horizontalHeaderItem(5)
        item.setText(_translate("Supplies_Window", "Valor"))
        item = self.tableQuotations.horizontalHeaderItem(6)
        item.setText(_translate("Supplies_Window", "Observaciones"))
        self.Button_AddSupply.setText(_translate("Supplies_Window", "Agregar"))

# Function to save changes into database
    def saveChanges(self):
        """
        Saves changes made to the data models and updates unique values for each column.
        """
        self.model.submitAll()

        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            for row in range(self.model.rowCount()):
                value = self.model.record(row).value(column)
                if value not in list_valuesUnique:
                    if isinstance(value, QtCore.QDate):
                        value=value.toString("dd/MM/yyyy")
                    list_valuesUnique.append(str(value))
                    if value not in self.checkbox_states[column]:
                        self.checkbox_states[column][value] = True
            self.dict_valuesuniques[column] = list_valuesUnique

# Function to add a new supply
    def addsupply(self):
        """
        It inserts the records into the appropriate table.
        """
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle('Suministros')
        dlg.setLabelText('Referencia:')

        dlg3 = QtWidgets.QInputDialog()
        new_icon3 = QtGui.QIcon()
        new_icon3.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg3.setWindowIcon(new_icon3)
        dlg3.setWindowTitle('Suministros')
        dlg3.setLabelText('Descripción:')

        while True:
            clickedButton = dlg.exec()
            if clickedButton == 1:
                reference_text = dlg.textValue()
                if reference_text != '':
                    while True:
                        clickedButton3 = dlg3.exec()
                        if clickedButton3 == 1:
                            description_text = dlg3.textValue()
                            if description_text != '':
                                conn = None
                                try:
                                # read the connection parameters
                                    params = config()
                                # connect to the PostgreSQL server
                                    conn = psycopg2.connect(**params)
                                    cur = conn.cursor()
                                # execution of commands
                                    commands_newsupply = ("""
                                    INSERT INTO purch_fact.supplies (reference, description) VALUES (%s, %s) 
                                    """)
                                    cur.execute(commands_newsupply, (reference_text, description_text,))
                                # close communication with the PostgreSQL database server
                                    cur.close()
                                # commit the changes
                                    conn.commit()

                                    self.tableSupplies.selectionModel().clearSelection()

                                    for i in range(self.model.rowCount()):
                                        index = self.model.index(i, 3)
                                        item_text = self.model.data(index, QtCore.Qt.ItemDataRole.DisplayRole)
                                        if item_text and reference_text.upper() in item_text.upper():
                                            self.tableSupplies.selectRow(index.row())

                                            new_selection = QtCore.QItemSelection(QtCore.QModelIndex(self.model.index(index.row(), 3)), QtCore.QModelIndex(self.model.index(index.row(), 3)))
                                            self.tableSupplies.selectionModel().select(new_selection, QtCore.QItemSelectionModel.SelectionFlag.Select)
                                            self.tableSupplies.setCurrentIndex(self.model.index(index.row(), 3))
                                            return

                                    dlg = QtWidgets.QMessageBox()
                                    new_icon = QtGui.QIcon()
                                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                                    dlg.setWindowIcon(new_icon)
                                    dlg.setWindowTitle("Líquidos Penetrantes")
                                    dlg.setText("Datos insertados con éxito")
                                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Information)
                                    dlg.exec()
                                    del dlg,new_icon

                                except (Exception, psycopg2.DatabaseError) as error:
                                    dlg = QtWidgets.QMessageBox()
                                    new_icon = QtGui.QIcon()
                                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                                    dlg.setWindowIcon(new_icon)
                                    dlg.setWindowTitle("ERP EIPSA")
                                    dlg.setText("Ha ocurrido el siguiente error:\n"
                                                + str(error))
                                    dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                                    dlg.exec()
                                    del dlg, new_icon
                                finally:
                                    if conn is not None:
                                        conn.close()
                                break
                            dlg_error = QtWidgets.QMessageBox()
                            new_icon = QtGui.QIcon()
                            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                            dlg_error.setWindowIcon(new_icon)
                            dlg_error.setWindowTitle("Suministros")
                            dlg_error.setText("La descripción no puede estar vacía")
                            dlg_error.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                            dlg_error.exec()
                            del dlg_error,new_icon
                        else:
                            break
                    break
                dlg_error = QtWidgets.QMessageBox()
                new_icon = QtGui.QIcon()
                new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                dlg_error.setWindowIcon(new_icon)
                dlg_error.setWindowTitle("Suministros")
                dlg_error.setText("La referencia no puede estar vacía")
                dlg_error.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                dlg_error.exec()
                del dlg_error,new_icon
            else:
                break

        self.loadtablesupplies()
        self.tableQuotations.setRowCount(0)
        self.position_table(reference_text)

# Function to load data of supplies in table
    def loadtablesupplies(self):
        """
        Queries the database for supplies, configures and populates tables with the query results, 
        and updates the UI accordingly. Handles potential database errors and updates the UI with appropriate messages.
        """
        self.model.setTable("purch_fact.supplies")
        self.tableSupplies.setModel(None)
        self.tableSupplies.setModel(self.proxy)
        self.model.setSort(3, QtCore.Qt.SortOrder.AscendingOrder)
        self.model.select()

        self.proxy.setSourceModel(self.model)
        self.tableSupplies.setModel(self.proxy)

        headers = ["ID", "Destino", "Clase", "Referencia", "Descripción",
                    "Un. Med.", "Val. Un.", "Notas", "Stk", "Stk Dsp.", "Pend.", "Ubicación"]

        self.model.setAllColumnHeaders(headers)

        if self.username == 'd.marquez':
            self.tableSupplies.setStyleSheet("gridline-color: rgb(128, 128, 128);")
            self.tableSupplies.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid white;}")
            self.tableSupplies.verticalHeader().setStyleSheet("::section{font: 10pt; background-color: #121212; border: 0.5px solid white;}")
        else:
            self.tableSupplies.horizontalHeader().setStyleSheet("::section{font: 800 10pt; background-color: #33bdef; border: 1px solid black;}")

        self.tableSupplies.setItemDelegate(AlignDelegate(self.tableSupplies))
        # self.color_delegate = ColorDelegate(self)
        # self.tableSupplies.setItemDelegateForColumn(6, self.color_delegate)
        for i in range(0,12):
            self.tableSupplies.horizontalHeader().setSectionResizeMode(i,QtWidgets.QHeaderView.ResizeMode.Stretch)
            self.tableSupplies.setColumnWidth(i, 75)
        self.tableSupplies.horizontalHeader().setSectionResizeMode(4,QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableSupplies.setColumnWidth(4, 510)
        self.tableSupplies.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableSupplies.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        # self.tableSupplies.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableSupplies.horizontalHeader().setSectionResizeMode(10, QtWidgets.QHeaderView.ResizeMode.Stretch)

        self.combo_itemtype = EditableComboBoxDelegate(self.tableSupplies, [''] + sorted([x[0] for x in self.results_others]))
        self.tableSupplies.setItemDelegateForColumn(5, self.combo_itemtype)

        for i in range(0,3):
            self.tableSupplies.hideColumn(i)
        self.tableSupplies.hideColumn(11)

    # Getting the unique values for each column of the model
        for column in range(self.model.columnCount()):
            list_valuesUnique = []
            if column not in self.checkbox_states:
                self.checkbox_states[column] = {}
                self.checkbox_states[column]['Seleccionar todo'] = True
                for row in range(self.model.rowCount()):
                    value = self.model.record(row).value(column)
                    if value not in list_valuesUnique:
                        if isinstance(value, QtCore.QDate):
                            value=value.toString("dd/MM/yyyy")
                        list_valuesUnique.append(str(value))
                        self.checkbox_states[column][value] = True
                self.dict_valuesuniques[column] = list_valuesUnique

# Function to load quotations
    def loadquotations(self, id_supply):
        """
        Queries the database for quotations based on the supply id, configures and populates tables with the query results, 
        and updates the UI accordingly. Handles potential database errors and updates the UI with appropriate messages.

        Args:
            id_supply (str):The string containing the id of the supply selected.
        """
        self.id_supply_toquery = id_supply
        commands_queryquotations = ("""
                        SELECT purch_fact.suppliers."name",
                        TO_CHAR(purch_fact.quotation_header."quot_date",'DD-MM-YYYY'),
                        purch_fact.supplies."reference",purch_fact.supplies."description",
                        purch_fact.quotation_details."quantity",purch_fact.quotation_details."value",
                        purch_fact.quotation_details."notes"
                        FROM purch_fact.quotation_details
                        LEFT JOIN purch_fact.supplies ON (purch_fact.supplies."id" = purch_fact.quotation_details."supply_id")
                        LEFT JOIN purch_fact.quotation_header ON (purch_fact.quotation_header."id" = purch_fact.quotation_details."quot_header_id")
                        LEFT JOIN purch_fact.suppliers ON (purch_fact.suppliers."id" = purch_fact.quotation_header."supplier_id")
                        WHERE purch_fact.quotation_details.supply_id = %s
                        ORDER BY purch_fact.quotation_header.quot_date DESC
                        """)
        conn = None
        try:
        # read the connection parameters
            params = config()
        # connect to the PostgreSQL server
            conn = psycopg2.connect(**params)
            cur = conn.cursor()
        # execution of commands one by one
            cur.execute(commands_queryquotations,(self.id_supply_toquery,))
            results_quotations=cur.fetchall()
        # close communication with the PostgreSQL database server
            cur.close()
        # commit the changes
            conn.commit()
        except (Exception, psycopg2.DatabaseError) as error:
            dlg = QtWidgets.QMessageBox()
            new_icon = QtGui.QIcon()
            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg.setWindowIcon(new_icon)
            dlg.setWindowTitle("ERP EIPSA")
            dlg.setText("Ha ocurrido el siguiente error:\n"
                        + str(error))
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
            dlg.exec()
            del dlg, new_icon
        finally:
            if conn is not None:
                conn.close()

        self.tableQuotations.setRowCount(len(results_quotations))
        tablerow=0

        font = QtGui.QFont()
        font.setPointSize(int(14//1.5))


    # fill the Qt Table with the query results
        for row in results_quotations:
            for column in range(7):
                value = row[column]
                if value is None:
                    value = ''
                it = QtWidgets.QTableWidgetItem(str(value))
                it.setFlags(it.flags() & ~QtCore.Qt.ItemFlag.ItemIsEditable)
                it.setFont(font)
                self.tableQuotations.setItem(tablerow, column, it)

            self.tableQuotations.setItemDelegateForRow(tablerow, AlignDelegate(self.tableQuotations))
            tablerow+=1

        self.tableQuotations.verticalHeader().hide()
        self.tableQuotations.setSortingEnabled(False)

        for i in range(0,6):
            self.tableQuotations.horizontalHeader().setSectionResizeMode(i,QtWidgets.QHeaderView.ResizeMode.Interactive)
            self.tableQuotations.setColumnWidth(i, 100)
        self.tableQuotations.setColumnWidth(0, 500)
        self.tableQuotations.horizontalHeader().setSectionResizeMode(3,QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableQuotations.horizontalHeader().setSectionResizeMode(6, QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function to update price
    def loadprice(self, item):
        """
        Updates the unit price of an item in the supply table.

        Args:
            item (QModelIndex): The index of the item in the supply table that was clicked.
        """
        if item.column() == 5:
            unit_value = item.text().replace(" €","").replace(".","").replace(",",".")

            dlg = QtWidgets.QMessageBox(self)
            dlg.setWindowTitle("Actualizar precio")
            dlg.setText("¿Quieres actualizar el precio a " + item.text())
            dlg.setStandardButtons(QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No)
            dlg.setIcon(QtWidgets.QMessageBox.Icon.Question)
            button = dlg.exec()

            if button == QtWidgets.QMessageBox.StandardButton.Yes:
                commands_modifysupply = ("""
                            UPDATE purch_fact.supplies
                            SET "unit_value" = %s
                            WHERE "id" = %s
                            """)
                commands_reference = ("""
                            SELECT reference FROM purch_fact.supplies
                            WHERE "id" = %s
                            """)
                conn = None
                try:
                # read the connection parameters
                    params = config()
                # connect to the PostgreSQL server
                    conn = psycopg2.connect(**params)
                    cur = conn.cursor()
                # execution of commands one by one
                    data=(unit_value,self.id_supply_toquery,)
                    cur.execute(commands_modifysupply,data)

                    data=(self.id_supply_toquery,)
                    cur.execute(commands_reference,data)
                    results=cur.fetchall()
                # close communication with the PostgreSQL database server
                    cur.close()
                # commit the changes
                    conn.commit()

                    self.loadtablesupplies()
                    self.position_table(results[0][0])

                except (Exception, psycopg2.DatabaseError) as error:
                    dlg_error = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg_error.setWindowIcon(new_icon)
                    dlg_error.setWindowTitle("ERP EIPSA")
                    dlg_error.setText("Ha ocurrido el siguiente error:\n"
                                + str(error))
                    dlg_error.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                    dlg_error.exec()
                    del dlg_error, new_icon
                finally:
                    if conn is not None:
                        conn.close()

# Function when header is clicked
    def on_view_horizontalHeader_sectionClicked(self, logicalIndex):
        """
        Displays a menu when a column header is clicked. The menu includes options for sorting, filtering, and managing column visibility.
        
        Args:
            logicalIndex (int): Index of the clicked column.
        """
        self.logicalIndex = logicalIndex
        self.menuValues = QtWidgets.QMenu(self)
        self.signalMapper = QtCore.QSignalMapper(self.tableSupplies)

        valuesUnique_view = []
        background_colors = set()
        for row in range(self.tableSupplies.model().rowCount()):
            index = self.tableSupplies.model().index(row, self.logicalIndex)
            value = index.data(QtCore.Qt.ItemDataRole.DisplayRole)
            background_color = index.data(QtCore.Qt.ItemDataRole.BackgroundRole)
            if value not in valuesUnique_view:
                if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
                valuesUnique_view.append(value)
            if background_color and isinstance(background_color, QtGui.QColor):
                background_colors.add(background_color)

        actionSortAscending = QtGui.QAction("Ordenar Ascendente", self.tableSupplies)
        actionSortAscending.triggered.connect(self.on_actionSortAscending_triggered)
        self.menuValues.addAction(actionSortAscending)
        actionSortDescending = QtGui.QAction("Ordenar Descendente", self.tableSupplies)
        actionSortDescending.triggered.connect(self.on_actionSortDescending_triggered)
        self.menuValues.addAction(actionSortDescending)
        self.menuValues.addSeparator()

        actionDeleteFilterColumn = QtGui.QAction("Quitar Filtro", self.tableSupplies)
        actionDeleteFilterColumn.triggered.connect(self.on_actionDeleteFilterColumn_triggered)
        self.menuValues.addAction(actionDeleteFilterColumn)
        self.menuValues.addSeparator()

        actionTextFilter = QtGui.QAction("Buscar...", self.tableSupplies)
        actionTextFilter.triggered.connect(self.on_actionTextFilter_triggered)
        self.menuValues.addAction(actionTextFilter)
        self.menuValues.addSeparator()

        color_submenu = QtWidgets.QMenu("Filtrar por Color de Fondo", self)
        color_signal_mapper = QtCore.QSignalMapper(self)

        for color in background_colors:
            color_action = QtGui.QAction(color, self.tableSupplies)
            # pixmap = QtGui.QPixmap(20, 20)
            # pixmap.fill(color)
            # color_action.setIcon(QtGui.QIcon(pixmap))
            # color_signal_mapper.setMapping(color_action, color)
            color_action.triggered.connect(lambda checked, col=color: self.proxy.setBackgroundColorFilter(col))
            color_submenu.addAction(color_action)

        clear_color_filter_action = QtGui.QAction("Quitar Filtro de Color", self)
        clear_color_filter_action.triggered.connect(lambda: self.proxy.setBackgroundColorFilter(None))
        color_submenu.addAction(clear_color_filter_action)

        self.menuValues.addMenu(color_submenu)
        self.menuValues.addSeparator()

        scroll_menu = QtWidgets.QScrollArea()
        if self.username == 'd.marquez':
            scroll_menu.setStyleSheet("background-color: #121212; color: rgb(255, 255, 255)")
        else:
            scroll_menu.setStyleSheet("background-color: rgb(255, 255, 255)")
        scroll_menu.setWidgetResizable(True)
        scroll_widget = QtWidgets.QWidget(scroll_menu)
        scroll_menu.setWidget(scroll_widget)
        scroll_layout = QtWidgets.QVBoxLayout(scroll_widget)

        checkbox_all_widget = QtWidgets.QCheckBox('Seleccionar todo')

        if not self.checkbox_states[self.logicalIndex]['Seleccionar todo'] == True:
            checkbox_all_widget.setChecked(False)
        else:
            checkbox_all_widget.setChecked(True)
        
        checkbox_all_widget.toggled.connect(lambda checked, name='Seleccionar todo': self.on_select_all_toggled(checked, name))

        scroll_layout.addWidget(checkbox_all_widget)
        self.action_checkbox_map['Seleccionar todo'] = checkbox_all_widget

        if len(self.dict_ordersort) != 0 and self.logicalIndex in self.dict_ordersort:
            list_uniquevalues = sorted(list(set(self.dict_valuesuniques[self.logicalIndex])))
        else:
            list_uniquevalues = sorted(list(set(valuesUnique_view)))

        for actionName in list_uniquevalues:
            checkbox_widget = QtWidgets.QCheckBox(str(actionName))

            if self.logicalIndex not in self.checkbox_filters:
                checkbox_widget.setChecked(True)
            elif actionName not in self.checkbox_filters[self.logicalIndex]:
                checkbox_widget.setChecked(False)
            else:
                checkbox_widget.setChecked(True)

            checkbox_widget.toggled.connect(lambda checked, name=actionName: self.on_checkbox_toggled(checked, name))

            scroll_layout.addWidget(checkbox_widget)
            self.action_checkbox_map[actionName] = checkbox_widget

        action_scroll_menu = QtWidgets.QWidgetAction(self.menuValues)
        action_scroll_menu.setDefaultWidget(scroll_menu)
        self.menuValues.addAction(action_scroll_menu)

        self.menuValues.addSeparator()

        accept_button = QtGui.QAction("ACEPTAR", self.tableSupplies)
        accept_button.triggered.connect(self.menu_acceptbutton_triggered)

        cancel_button = QtGui.QAction("CANCELAR", self.tableSupplies)
        cancel_button.triggered.connect(self.menu_cancelbutton_triggered)

        self.menuValues.addAction(accept_button)
        self.menuValues.addAction(cancel_button)

        if self.username == 'd.marquez':
            self.menuValues.setStyleSheet("QMenu { color: white; }"
                                            "QMenu { background-color: #121212; }"
                                            "QMenu::item:selected { background-color: #33bdef; }"
                                            "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")
        else:
            self.menuValues.setStyleSheet("QMenu { color: black; }"
                                            "QMenu { background-color: rgb(255, 255, 255); }"
                                            "QMenu::item:selected { background-color: #33bdef; }"
                                            "QMenu::item:pressed { background-color: rgb(1, 140, 190); }")

        headerPos = self.tableSupplies.mapToGlobal(self.tableSupplies.horizontalHeader().pos())        

        posY = headerPos.y() + self.tableSupplies.horizontalHeader().height()
        scrollX = self.tableSupplies.horizontalScrollBar().value()
        xInView = self.tableSupplies.horizontalHeader().sectionViewportPosition(logicalIndex)
        posX = headerPos.x() + xInView - scrollX

        self.menuValues.exec(QtCore.QPoint(posX, posY))

# Function when cancel button of menu is clicked
    def menu_cancelbutton_triggered(self):
        """
        Hides the menu when the cancel button is clicked.
        """
        self.menuValues.hide()

# Function when accept button of menu is clicked
    def menu_acceptbutton_triggered(self):
        """
        Applies the selected filters and updates the table model with the new filters.
        """
        for column, filters in self.checkbox_filters.items():
            if filters:
                self.proxy.setFilter(filters, column)
            else:
                self.proxy.setFilter(None, column)

# Function when select all checkbox is clicked
    def on_select_all_toggled(self, checked, action_name):
        """
        Toggles the state of all checkboxes in the filter menu when the 'Select All' checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the 'Select All' checkbox.
            action_name (str): The name of the action (usually 'Select All').
        """
        filterColumn = self.logicalIndex
        imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
                checkbox_widget.setChecked(checked)
                self.checkbox_states[self.logicalIndex][checkbox_name] = checked

            if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
                self.model.setIconColumnHeader(filterColumn, icono)
            else:
                self.model.setIconColumnHeader(filterColumn, '')
        
        else:
            for checkbox_name, checkbox_widget in self.action_checkbox_map.items():
                checkbox_widget.setChecked(checked)
                self.checkbox_states[self.logicalIndex][checkbox_widget.text()] = checked

# Function when checkbox of header menu is clicked
    def on_checkbox_toggled(self, checked, action_name):
        """
        Updates the filter state when an individual checkbox is toggled.
        
        Args:
            checked (bool): The checked state of the checkbox.
            action_name (str): The name of the checkbox.
        """
        filterColumn = self.logicalIndex
        imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
        icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))

        if checked:
            if filterColumn not in self.checkbox_filters:
                self.checkbox_filters[filterColumn] = [action_name]
            else:
                if action_name not in self.checkbox_filters[filterColumn]:
                    self.checkbox_filters[filterColumn].append(action_name)
        else:
            if filterColumn in self.checkbox_filters and action_name in self.checkbox_filters[filterColumn]:
                self.checkbox_filters[filterColumn].remove(action_name)

        if all(checkbox_widget.isChecked() for checkbox_widget in self.action_checkbox_map.values()):
            self.model.setIconColumnHeader(filterColumn, '')
        else:
            self.model.setIconColumnHeader(filterColumn, icono)

# Function to delete individual column filter
    def on_actionDeleteFilterColumn_triggered(self):
        """
        Removes the filter from the selected column and updates the table model.
        """
        filterColumn = self.logicalIndex
        if filterColumn in self.proxy.filters:
            del self.proxy.filters[filterColumn]
        self.model.setIconColumnHeader(filterColumn, '')
        self.proxy.invalidateFilter()

        self.tableSupplies.setModel(None)
        self.tableSupplies.setModel(self.proxy)

        if filterColumn in self.checkbox_filters:
            del self.checkbox_filters[filterColumn]

        self.checkbox_states[self.logicalIndex].clear()
        self.checkbox_states[self.logicalIndex]['Seleccionar todo'] = True
        for row in range(self.tableSupplies.model().rowCount()):
            value = self.model.record(row).value(filterColumn)
            if isinstance(value, QtCore.QDate):
                    value=value.toString("dd/MM/yyyy")
            self.checkbox_states[self.logicalIndex][str(value)] = True

        for i in range(0,3):
            self.tableSupplies.hideColumn(i)
        self.tableSupplies.hideColumn(11)

        self.tableSupplies.setItemDelegate(AlignDelegate(self.tableSupplies))
        for i in range(0,12):
            self.tableSupplies.horizontalHeader().setSectionResizeMode(i,QtWidgets.QHeaderView.ResizeMode.Stretch)
            self.tableSupplies.setColumnWidth(i, 75)
        self.tableSupplies.horizontalHeader().setSectionResizeMode(4,QtWidgets.QHeaderView.ResizeMode.Interactive)
        self.tableSupplies.setColumnWidth(4, 510)
        self.tableSupplies.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableSupplies.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        self.tableSupplies.horizontalHeader().setSectionResizeMode(10, QtWidgets.QHeaderView.ResizeMode.Stretch)

# Function to order column ascending
    def on_actionSortAscending_triggered(self):
        """
        Sorts the selected column in ascending order.
        """
        sortColumn = self.logicalIndex
        sortOrder = QtCore.Qt.SortOrder.AscendingOrder
        self.tableSupplies.sortByColumn(sortColumn, sortOrder)

# Function to order column descending
    def on_actionSortDescending_triggered(self):
        """
        Sorts the selected column in descending order.
        """
        sortColumn = self.logicalIndex
        sortOrder = QtCore.Qt.SortOrder.DescendingOrder
        self.tableSupplies.sortByColumn(sortColumn, sortOrder)

# Function when text is searched
    def on_actionTextFilter_triggered(self):
        """
        Opens a dialog to enter a text filter and applies it to the selected column.
        """
        filterColumn = self.logicalIndex
        dlg = QtWidgets.QInputDialog()
        new_icon = QtGui.QIcon()
        new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        dlg.setWindowIcon(new_icon)
        dlg.setWindowTitle('Buscar')
        clickedButton=dlg.exec()

        if clickedButton == 1:
            stringAction = dlg.textValue()
            if re.fullmatch(r'^(?:3[01]|[12][0-9]|0?[1-9])([\-/.])(0?[1-9]|1[1-2])\1\d{4}$', stringAction):
                stringAction=QtCore.QDate.fromString(stringAction,"dd/MM/yyyy")
                stringAction=stringAction.toString("yyyy-MM-dd")

            filterString = QtCore.QRegularExpression(stringAction, QtCore.QRegularExpression.PatternOption(0))
            # del self.proxy.filters[filterColumn]
            self.proxy.setFilter([stringAction], filterColumn)

            imagen_path = os.path.abspath(os.path.join(basedir, "Resources/Iconos/Filter_Active.png"))
            icono = QtGui.QIcon(QtGui.QPixmap.fromImage(QtGui.QImage(imagen_path)))
            self.model.setIconColumnHeader(filterColumn, icono)

# Function when clicking on quotation table header
    def on_header_sectionquot_clicked(self, logical_index):
        """
        Displays a menu when a column header is clicked. The menu includes options for sorting, filtering, and managing column visibility.
        
        Args:
            logicalIndex (int): Index of the clicked column.
        """
        header_pos = self.tableQuotations.horizontalHeader().sectionViewportPosition(logical_index)
        header_height = self.tableQuotations.horizontalHeader().height()
        popup_pos = self.tableQuotations.viewport().mapToGlobal(QtCore.QPoint(header_pos, header_height))
        self.tableQuotations.show_unique_values_menu(logical_index, popup_pos, header_height)

# Function to move table to specific item by text search
    def position_table(self, text_tocheck = None):
        """
        Selects and highlights the row in the supply table that contains the specified text.

        Args:
            text_tocheck (str, optional): The text to search for in the table. 
                                        If None, uses the text from the Position input field.
        """
        text_position = self.Position.text() if text_tocheck is None else text_tocheck
        self.tableSupplies.selectionModel().clearSelection()

        for i in range(self.model.rowCount()):
            index = self.model.index(i, 3)
            item_text = self.model.data(index, QtCore.Qt.ItemDataRole.DisplayRole)
            if item_text and text_position.upper() in item_text.upper():
                self.tableSupplies.selectRow(index.row())

                new_selection = QtCore.QItemSelection(QtCore.QModelIndex(self.model.index(index.row(), 3)), QtCore.QModelIndex(self.model.index(index.row(), 3)))
                self.tableSupplies.selectionModel().select(new_selection, QtCore.QItemSelectionModel.SelectionFlag.Select)
                self.tableSupplies.setCurrentIndex(self.model.index(index.row(), 3))
                return

# Function to events for keys
    def keyPressEvent(self, event: QtGui.QKeyEvent):
        """
        Handles custom key events for cell operations in the table.

        Args:
            event (QtGui.QKeyEvent): The key event to handle.
        """
        if event.key() == QtCore.Qt.Key.Key_Escape:
            focused_widget = QtWidgets.QApplication.focusWidget()
            if isinstance(focused_widget, QtWidgets.QLineEdit) or isinstance(focused_widget, QtWidgets.QTextEdit):
                focused_widget.clear()
            elif isinstance(focused_widget, QtWidgets.QComboBox):
                focused_widget.setCurrentIndex(0)

# Function to load item quotations
    def item_clicked(self, index):
        """
        Handles the event when an item in the table is clicked.

        Args:
            index (QModelIndex): The index of the clicked item in the table.
        """
        current_row = index.row()
        first_column_value = self.proxy.data(self.proxy.index(current_row, 0))

        if first_column_value != '':
            self.loadquotations(first_column_value)

# Function to edit reference or description of supplies
    def edit_supply(self, index):
        """
        Updates references or description of the records into the appropriate table.
        """
        if index.column() == 3:
            current_row = index.row()
            id_supply = self.proxy.data(self.proxy.index(current_row, 0))
            current_reference = self.proxy.data(self.proxy.index(current_row, 3))

            dlg3 = QtWidgets.QInputDialog()
            new_icon3 = QtGui.QIcon()
            new_icon3.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg3.setWindowIcon(new_icon3)
            dlg3.setWindowTitle('Suministros')
            dlg3.setLabelText('Antigua referencia:\n' +
                                current_reference + '\n\n' +
                                'Nueva referencia:')
            dlg3.setTextValue(current_reference)
            dlg3.resize(400, 200)

            while True:
                clickedButton3 = dlg3.exec()
                if clickedButton3 == 1:
                    reference_supply = dlg3.textValue()
                    if reference_supply != '':
                        conn = None
                        try:
                        # read the connection parameters
                            params = config()
                        # connect to the PostgreSQL server
                            conn = psycopg2.connect(**params)
                            cur = conn.cursor()
                        # execution of commands
                            commands_modifysupply = ("""
                                                    UPDATE purch_fact.supplies
                                                    SET "reference" = %s
                                                    WHERE "id" = %s
                                                    """)
                            cur.execute(commands_modifysupply, (reference_supply, id_supply,))

                        # close communication with the PostgreSQL database server
                            cur.close()
                        # commit the changes
                            conn.commit()

                            self.loadtablesupplies()
                            self.position_table(reference_supply)

                        except (Exception, psycopg2.DatabaseError) as error:
                            dlg = QtWidgets.QMessageBox()
                            new_icon = QtGui.QIcon()
                            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                            dlg.setWindowIcon(new_icon)
                            dlg.setWindowTitle("ERP EIPSA")
                            dlg.setText("Ha ocurrido el siguiente error:\n"
                                        + str(error))
                            dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                            dlg.exec()
                            del dlg, new_icon
                        finally:
                            if conn is not None:
                                conn.close()
                        break
                    dlg_error = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg_error.setWindowIcon(new_icon)
                    dlg_error.setWindowTitle("Suministros")
                    dlg_error.setText("El campo no puede estar vacío")
                    dlg_error.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                    dlg_error.exec()
                    del dlg_error,new_icon
                else:
                    break

        elif index.column() == 4:
            current_row = index.row()
            id_supply = self.proxy.data(self.proxy.index(current_row, 0))
            current_reference = self.proxy.data(self.proxy.index(current_row, 3))
            current_description = self.proxy.data(self.proxy.index(current_row, 4))

            dlg3 = QtWidgets.QInputDialog()
            new_icon3 = QtGui.QIcon()
            new_icon3.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
            dlg3.setWindowIcon(new_icon3)
            dlg3.setWindowTitle('Suministros')
            dlg3.setLabelText('Antigua descripción:\n' +
                                current_description + '\n\n' +
                                'Nueva descripción:')
            dlg3.setTextValue(current_description)
            dlg3.resize(400, 200)

            while True:
                clickedButton3 = dlg3.exec()
                if clickedButton3 == 1:
                    description_supply = dlg3.textValue()
                    if description_supply != '':
                        conn = None
                        try:
                        # read the connection parameters
                            params = config()
                        # connect to the PostgreSQL server
                            conn = psycopg2.connect(**params)
                            cur = conn.cursor()
                        # execution of commands
                            commands_modifysupply = ("""
                                                    UPDATE purch_fact.supplies
                                                    SET "description" = %s
                                                    WHERE "id" = %s
                                                    """)
                            cur.execute(commands_modifysupply, (description_supply, id_supply,))

                        # close communication with the PostgreSQL database server
                            cur.close()
                        # commit the changes
                            conn.commit()

                            self.loadtablesupplies()
                            self.position_table(current_reference)

                        except (Exception, psycopg2.DatabaseError) as error:
                            dlg = QtWidgets.QMessageBox()
                            new_icon = QtGui.QIcon()
                            new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                            dlg.setWindowIcon(new_icon)
                            dlg.setWindowTitle("ERP EIPSA")
                            dlg.setText("Ha ocurrido el siguiente error:\n"
                                        + str(error))
                            dlg.setIcon(QtWidgets.QMessageBox.Icon.Critical)
                            dlg.exec()
                            del dlg, new_icon
                        finally:
                            if conn is not None:
                                conn.close()
                        break
                    dlg_error = QtWidgets.QMessageBox()
                    new_icon = QtGui.QIcon()
                    new_icon.addPixmap(QtGui.QPixmap(os.path.abspath(os.path.join(basedir, "Resources/Iconos/icon.ico"))), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
                    dlg_error.setWindowIcon(new_icon)
                    dlg_error.setWindowTitle("Suministros")
                    dlg_error.setText("El campo no puede estar vacío")
                    dlg_error.setIcon(QtWidgets.QMessageBox.Icon.Warning)
                    dlg_error.exec()
                    del dlg_error,new_icon
                else:
                    break




if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    config_obj = configparser.ConfigParser()
    config_obj.read(r"C:\Program Files\ERP EIPSA\database.ini")
    dbparam = config_obj["postgresql"]
    # set your parameters for the database connection URI using the keys from the configfile.ini
    user_database = dbparam["user"]
    password_database = dbparam["password"]

    db = createConnection(user_database, password_database)
    if not db:
        sys.exit()

    EditTags_Window = Ui_Supplies_Window('d.marquez',db)
    EditTags_Window.show()
    sys.exit(app.exec())
